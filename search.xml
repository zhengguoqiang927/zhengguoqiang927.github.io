<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法——BFS和DFS</title>
    <url>/2020/07/15/algorithm-bfs-dfs/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,深度优先遍历,广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——图</title>
    <url>/2020/07/14/algorithm-graph/</url>
    <content><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是由一组顶点和一组能够将两个顶点相连的边组成的。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_define.png" alt="图"></p>
<p>图中A、B、C、D等这些元素就叫做顶点(vertext)。一个顶点可以与任意其他顶点建立连接关系，这种连接关系叫做边(edge)。</p>
<p>我们生活中就有很多符合图这种结构的例子。比如常用的社交网络，就是一个非常典型的图结构。就拿微信举例子，我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的<strong>度</strong>（degree），就是跟顶点相连接的边的条数。我们把微信的这种好友关系只需要简单连接就能表示的图叫做<strong>无向图</strong> .</p>
<p>微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。只需要将无向图稍微改造一下，引入边的“方向”的概念。</p>
<p>如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B 指向 A 的边。我们把这种边有方向的图叫作<strong>有向图</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_directed_graph.png" alt="有向图"></p>
<p>无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。</p>
<p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p>
<p>QQ 中的社交关系要更复杂的一点。不知道你有没有留意过 QQ 亲密度这样一个功能。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。如何在图中记录这种好友关系的亲密度呢？</p>
<p>这里就要用到另一种图，<strong>加权图</strong>（weighted graph）。在加权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_weighted.png" alt="加权图"></p>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）。</p>
<p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j] 和 A[j][i] 标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j] 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i] 标记为 1。对于带权图，数组中就存储相应的权重。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_adjacency_matrix.png" alt="邻接矩阵"></p>
<p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。因为对于无向图来说，如果 A[i][j] 等于 1，那 A[j][i] 也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。</p>
<p>还有，如果我们存储的是<strong>稀疏图</strong>（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p>
<p>但这也并不是说，邻接矩阵的存储方法就完全没有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall算法" target="_blank" rel="noopener">Floyd-Warshall 算法</a>，就是利用矩阵循环相乘若干次得到结果。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，<strong>邻接表</strong>（Adjacency List）。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_adjacency_list.png" alt="邻接表"></p>
<p>图中画的是一个有向图的邻接表存储方式，每个顶点对应一条链表，链表中存储的是指向的顶点。</p>
<p>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。典型的空间换时间、时间换空间的设计思想。</p>
<p>就像图中的例子，如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。但是链表可以换成其他高效动态数据结构，比如平衡二叉查找树（红黑树）、跳表等，甚至可以将链表改成有序动态数组，通过二分查找实现对数级的查找。</p>
<p>上述的邻接表在表示微博的用户关系时，可以很容易表示某个用户关注了哪些用户，因为链表中存储的是指向的顶点，那如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_adjacency_list_reverse.png" alt="逆邻接表"></p>
<p>逆邻接表中存储的是用户的被关注关系。对应到图上，邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点，逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。如果要查找某个用户关注了哪些用户，我们可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，我们从逆邻接表中查找。</p>
<p>基础的邻接表不适合快速判断两个用户之间是否是关注与被关注的关系，所以我们选择改进版本，将邻接表中的链表改为支持快速查找的动态数据结构。选择哪种动态数据结构呢？红黑树、跳表、有序动态数组还是散列表呢？</p>
<p>因为我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。</p>
<p>如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。这个时候该怎么办呢？</p>
<p>我们可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。你可以看下面这幅图，我们在机器 1 上存储顶点 1，2，3 的邻接表，在机器 2 上，存储顶点 4，5 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_adj_shard.png" alt="邻接表分片存储"></p>
<p>除此之外，我们还有另外一种解决思路，就是利用外部存储（比如硬盘），因为外部存储的存储空间要比内存会宽裕很多。数据库是我们经常用来持久化存储关系数据的，所以我这里介绍一种数据库的存储方式。</p>
<p>我用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，我们可以在表上建立多个索引，比如第一列、第二列，给这两列都建立索引。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_graph_adj_database.png" alt="邻接表外部存储"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构,图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(九)——堆</title>
    <url>/2020/07/12/algorithm-heap/</url>
    <content><![CDATA[<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种特殊的树，需要满足以下两个条件：</p>
<ul>
<li>堆是一个完全二叉树</li>
<li>堆中每一个结点的值都必须大于等于(或小于等于)其左右子结点的值</li>
</ul>
<p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作<strong>大顶堆</strong>。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作<strong>小顶堆</strong>。</p>
<a id="more"></a>

<h3 id="堆实现"><a href="#堆实现" class="headerlink" title="堆实现"></a>堆实现</h3><h4 id="堆存储"><a href="#堆存储" class="headerlink" title="堆存储"></a>堆存储</h4><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点，非常方便</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_store.png" alt="对存储"></p>
<p>数组第一个位置不存储元素，根结点储存在位置1上，子结点存储在位置2和3上，子结点的子结点存储在4、5、6、7上，以此类推。</p>
<p>从上图可知堆存储的的两个特点：</p>
<ul>
<li>位置k的结点的父结点的位置为k/2的向下取整，它的子结点的位置分别为2k和2k+1</li>
<li>元素个数为N的二叉堆的高度lgN的向下取整</li>
</ul>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>在实现插入和删除操作之前需要先了解下两个基本的堆有序化算法：上浮和下沉</p>
<p><strong>由下至上的堆有序化——上浮</strong>：当新增元素至数组末尾时，有可能因为当前元素大于其父结点而破坏堆的有序状态，所以就需要交换该结点和父结点，交换之后可能比当前父结点还要大，继续向上移动，直到碰到一个比它大的父结点为止。这个过程就是<strong>上浮</strong></p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_swim_1.png" alt="新增元素上浮"></p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_swim_2.png" alt="上浮过程"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">          exch(k/<span class="number">2</span>,k);</span><br><span class="line">          k = k/<span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由上至下的堆有序化</strong>——下沉：当从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，有可能因为其比两个子结点或者其中一个子结点小而破坏堆的有序状态，所以需要将其和两个子结点中的较大者进行交换，交换之后可能比当前的子结点还要小，继续向下移动，直到不在小于它的子结点或者到达堆的底部。这个过程就是<strong>下沉</strong></p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_sink.png" alt="下沉过程"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">          <span class="comment">//左子结点</span></span><br><span class="line">          <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">          <span class="comment">//不能超过数组大小，选取左右子结点较大者</span></span><br><span class="line">          <span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>)) j++;</span><br><span class="line">          <span class="comment">//父结点不在比子结点较大者小时，停止下沉</span></span><br><span class="line">          <span class="keyword">if</span>(!less(k,j)) <span class="keyword">break</span>;</span><br><span class="line">          exch(k,j);</span><br><span class="line">          k = j;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入删除代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueSimple</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueueSimple</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Key t = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 位置为k的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">            exch(k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 位置为k的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//取两个子结点中较大者</span></span><br><span class="line">            <span class="keyword">if</span> (j&lt;N &amp;&amp; less(j,j+<span class="number">1</span>)) j++;</span><br><span class="line">            <span class="comment">//当父结点不在小于子结点时，停止下沉</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,j)) <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span>&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];<span class="comment">//取出最大元素</span></span><br><span class="line"><span class="comment">//        pq[1] = pq[N--];//与最后一个结点交换</span></span><br><span class="line">        exch(<span class="number">1</span>,N--);</span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;<span class="comment">//防止对象游离</span></span><br><span class="line">        sink(<span class="number">1</span>);<span class="comment">//下沉</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"A"</span>,<span class="string">"O"</span>,<span class="string">"R"</span>,<span class="string">"T"</span>,<span class="string">"H"</span>,<span class="string">"N"</span>,<span class="string">"G"</span>,<span class="string">"S"</span>,<span class="string">"E"</span>,<span class="string">"I"</span>,<span class="string">"P"</span>&#125;;</span><br><span class="line">        PriorityQueueSimple&lt;String&gt; simple = <span class="keyword">new</span> PriorityQueueSimple&lt;&gt;(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">for</span> (String a:arr)&#123;</span><br><span class="line">            simple.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!simple.isEmpty())&#123;</span><br><span class="line">            System.out.print(simple.delMax() + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>完全二叉树的高度是logN，所以上浮过程比较次数不超过logN次，下沉过程涉及两次比较    （父结点与子结点、子结点与兄弟结点），所以比较次数不超过2logN。所以插入一个元素和删除堆顶元素的时间复杂度都是O(logn)</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>借助于堆这种数据结构实现的排序算法，就叫作堆排序。</p>
<p>堆排序分为两个阶段：1、构造堆；2、下沉排序</p>
<h4 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h4><p>构造堆有有两种思路：</p>
<ol>
<li>从左往右</li>
</ol>
<p>从左往右遍历数组，将下标从2到N的数据依次到堆中，用swim()保证扫描指针左侧的所有元素已经是一棵堆有序的完全二叉树，该方法的时间复杂度为O(NlogN)</p>
<ol start="2">
<li>从右往左</li>
</ol>
<p>从右往左用sink()构造子堆。数组中的每个位置已经是一个子堆，所以一个结点的两个子结点已经是子堆，那么在该结点上调用sink()可以将其合并成一个堆。因为从N/2右侧都是都是叶子结点，所以只需在N/2的左侧开始构建子堆就可以，最后在位置1上调用sink(1)使整个堆有序。该方法的时间复杂度是O(N)</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_sort_construct_time_1.png" alt="构造堆复杂度计算"></p>
<p>因为叶子节点不需要下沉，所以需要下沉的节点从倒数第二层开始。每个节点下沉的过程中，需要比较和交换的节点个数，跟这个节点的高度k 成正比。</p>
<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_sort_construct_time_2.png" alt="构造堆复杂度计算2"></p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_sort_construct_time_3.png" alt="构造堆复杂度计算3"></p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_sort_construct_time_4.png" alt="构造堆复杂度计算4"></p>
<p>然后将h=logN带入公式中，可以得到S=O(N)，所以建堆的时间复杂度就是O(N)，线性级别的。</p>
<h4 id="下沉排序"><a href="#下沉排序" class="headerlink" title="下沉排序"></a>下沉排序</h4><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 $n$ 的位置。</p>
<p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 $n$ 的元素放到堆顶，同时把删除的堆顶元素放到下标为$n$的位置，然后再通过堆化的方法，将剩下的 $n-1$ 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 $n-1$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $1$ 的一个元素，排序工作就完成了。</p>
<h4 id="堆排序示意图"><a href="#堆排序示意图" class="headerlink" title="堆排序示意图"></a>堆排序示意图</h4><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_sort_graph.png" alt="堆排序"></p>
<h4 id="堆排序实现代码"><a href="#堆排序实现代码" class="headerlink" title="堆排序实现代码"></a>堆排序实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//构造堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            sink(a, k, N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下沉排序</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            SortUtil.exch(a, <span class="number">1</span>, N--);</span><br><span class="line">            sink(a, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>整体时间复杂度：O(nlogn)</p>
<ol>
<li><p>构造堆</p>
<p> 用下沉构造N个元素的堆，所需要的比较次数少于2N次，交换次数少于N次。构造堆的时间复杂度是O(n)</p>
</li>
<li><p>下沉排序</p>
<p> 下沉操作每下一层需要2次比较，最坏情况下沉lgN层，即每下沉一个元素最多需要2lgN次比较，总共N个元素，最多需要N*2lgN次比较（交换次数减半）。排序的时间复杂度是O(nlogn).</p>
</li>
</ol>
<p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
<p>优缺点：</p>
<p>优点：能够同时最优的利用时间和空间，时间复杂度线性对数级。当空间十分紧张的情况下，非常适用，几行简单的代码就能提供较好的性能</p>
<p>缺点：现代系统许多应用很少适用堆排序，因为它无法利用缓存。数组元素很少和相邻的元素进行比较，而是对半比较，因此缓存命中的次数较和相邻元素进行比较的算法（比如快速排序、归并排序）要低的多</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>   优先队列是一种抽象数据类型，类似于队列和栈。不同的是，优先队列中的每个元素都有优先级，优先级高的元素先于优先级低的元素出队，如果两个元素的优先级相等则看其具体实现采取的措施。跟排序有关但是又不需要所有元素完全排序。</p>
<h5 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a>初级实现</h5><ul>
<li><p>数组实现（无序）：删除操作类似于选择排序</p>
</li>
<li><p>数组实现（有序）：插入操作类似于插入排序</p>
</li>
<li><p>链表表示法：分无序和有序，类似于数组的无序和有序实现</p>
<p>各种实现的时间复杂度如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入元素</th>
<th>删除最大元素</th>
</tr>
</thead>
<tbody><tr>
<td>有序数组</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>有序数组</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>堆（高级实现）</td>
<td>logN</td>
<td>logN</td>
</tr>
</tbody></table>
<p>   通常情况下，优先队列采用二叉堆表示，用堆来实现是最直接、最高效的。因为堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ol>
<li>合并有序小文件</li>
</ol>
<p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。优先级队列实现的复杂度是O(logn)，数组也可以实现，但是复杂度是O(n)。</p>
<p>思路就是将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p>
<ol start="2">
<li>高性能定时器</li>
</ol>
<h4 id="利用堆求TopK问题"><a href="#利用堆求TopK问题" class="headerlink" title="利用堆求TopK问题"></a>利用堆求TopK问题</h4><p>N个元素中找出前K个最大的（或者最小的）元素</p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>时间</th>
<th>空间</th>
</tr>
</thead>
<tbody><tr>
<td>排序算法</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td>初级实现的优先队列</td>
<td>NM</td>
<td>M</td>
</tr>
<tr>
<td>基于堆实现的优先队列</td>
<td>NlogK</td>
<td>M</td>
</tr>
</tbody></table>
<p>基于堆实现的优先队列的实现思路：我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出取数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p>
<p>遍历数组需要 O(n) 的时间复杂度，一次堆操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，所以时间复杂度就是 O(nlogK)。</p>
<h4 id="利用堆求中位数"><a href="#利用堆求中位数" class="headerlink" title="利用堆求中位数"></a>利用堆求中位数</h4><p><strong>中位数</strong>：更为通用的问题是找到一组数中第k小的元素（当k为中间值时，即不大于一半的元素又不小于另一半元素，为中位数），TopM的解决方案对于中位数（M=N/2）也同样适用，但效率不高。有两种效率更高的解决方案：</p>
<ol>
<li>建立两个堆：大顶堆和小顶堆</li>
</ol>
<p>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前n/2 个数据存储在大顶堆中，后n/2 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储n/2 + 1 个数据，小顶堆中就存储n/2个数据</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_middle_num_1.png" alt="中位数"></p>
<p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，我们就将这个新数据插入到小顶堆。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_heap_middle_num_2.png" alt="中位数"></p>
<p>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：如果 n 是偶数，两个堆中的数据个数都是 n/2；如果 n 是奇数，大顶堆有n/2+1 个数据，小顶堆有 n/2 个数据。这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p>
<p>移动数据因为需要涉及上浮下沉，所以时间复杂度变成了 O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，时间复杂度就是 O(1)，所以整体的时间复杂度是O(logn)。</p>
<ol start="2">
<li>快速排序的切分</li>
</ol>
<p>实现思路：利用快速排序的切分法，返回的整数j使得a[lo..j-1]小于等于a[j]且a[j+1..hi]大于等于a[j]。当j=k=N/2时，两边元素的个数相等，a[j]=a[k]即为中位数。如果j != k说明两边元素个数不相等，继续切分子数组直到j落到中间位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//k即为N/2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">select</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//混排，随机打散数组元素</span></span><br><span class="line">    StdRandom.shuffle(a);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>,hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//切分位置刚好处于中间</span></span><br><span class="line">        <span class="keyword">if</span>(j == k) <span class="keyword">return</span> a[k];</span><br><span class="line">        <span class="comment">//切分位置在中间右侧，再切分左子数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( j &gt; k) hi = j - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分位置在中间左侧，再切分右子数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) lo = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：假设每次都正好将数组二分，那么比较的总次数为 N + N/2 + N/4 + N/8 + …  &lt; 2N，所以是线性级别的复杂度O(n)</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？限制条件：单机内存1G</p>
<p>思路：</p>
<ol>
<li><p>首先要统计每个搜索关键词出现的频率。用散列表顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，我们去散列表中查询。如果存在，我们就将对应的次数加一；如果不存在，我们就将它插入到散列表，并记录次数为 1。以此类推，等遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</p>
</li>
<li><p>用求TopK的方法。建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。</p>
</li>
</ol>
<p>优化：</p>
<p>如果不重复的搜索关键词太多，导致内存放不下，我们可以用哈希算法将10亿条搜索关键词哈希分片到10个文件中。我们创建 10 个空文件 00，01，02，……，09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。分片之后每个分片上的不重复的搜索关键词就没那么多了，如果还多就加大分片数。</p>
<p>再对这10个文件分别用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构,堆</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 —— 二分查找</title>
    <url>/2020/07/03/algorithm-binary-search/</url>
    <content><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找（Binary Search）算法，也叫折半查找算法。思想非常简单，<strong>二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong></p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binary_search.png" alt="二分查找"></p>
<a id="more"></a>

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binary_search_time.png" alt="二分查找时间复杂度"></p>
<p>可以看出来，这是一个等比数列。其中 n/2k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。</p>
<p>扩展：数据采用链表存储时，也就是有序的链表二分查找的时间复杂度为O(n)</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>非递归实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//注意点1：循环退出条件是low &lt;= high</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    <span class="comment">//注意点2：也可以采用 low + ((high-low)&gt;&gt;1),效率更高，但不推荐 (low+high)/2,因为如果low和high都很大的话，两者之和可能发生溢出</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == a[mid])&#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; a[mid])&#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchByRecusive</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (value == a[mid])&#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; a[mid])&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchByRecusive(a,mid + <span class="number">1</span>,hi,value);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchByRecusive(a,lo,mid - <span class="number">1</span>,value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景的局限"><a href="#适用场景的局限" class="headerlink" title="适用场景的局限"></a>适用场景的局限</h4><ol>
<li>二分查找依赖于顺序表结构，其实就是必须用数组来存储数据</li>
</ol>
<p>因为二分查找算法需要按照下标随机访问元素</p>
<ol start="2">
<li>二分查找针对的是有序数据</li>
</ol>
<p>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。因为动态变化的数据集合，要维护它的有序性，需要花费很高的成本</p>
<ol start="3">
<li>二分查找的数据量不能太大也不能太小</li>
</ol>
<p>如果需要处理的数据量较少，直接使用顺序遍历就可以了，因为两者的处理速度差不多。但有一个例外，当数据的比较操作非常耗时，比如长度超过300的字符串，这时应该尽量减少比较次数，所以应该采用二分查找</p>
<p>同样，数据量也不能太大，因为二分查找依赖支持随机访问的数组，而数组需要连续的内存空间，如果数据量过大的话，需要有够大的连续的内存空间的支持，而通常内存空间是零散的，很难申请一个非常大的连续的内存空间，所以这种情况下二分查找也无法使用</p>
<blockquote>
<p>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</p>
</blockquote>
<h4 id="二分查找变形问题"><a href="#二分查找变形问题" class="headerlink" title="二分查找变形问题"></a>二分查找变形问题</h4><p>上面代码实现的二分查找最简单的情况即有序数组中没有重复的元素，当数组中存在重复元素时，通常会有以下4中变形问题：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binary_search_mutation.png" alt="二分查找变形问题"></p>
<h5 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h5><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binary_search_m1.png" alt="二分查找变形举例"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch7</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 —— 排序</title>
    <url>/2020/07/03/algorithm-sort/</url>
    <content><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>常用的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_category.png" alt="常用排序算法"></p>
<a id="more"></a>

<h3 id="排序算法的衡量指标"><a href="#排序算法的衡量指标" class="headerlink" title="排序算法的衡量指标"></a>排序算法的衡量指标</h3><h4 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h4><p>执行效率的衡量指标同样有以下几种：</p>
<ol>
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
</li>
<li><p>时间复杂度的系数、常数、低阶</p>
<p> 当数据规模比较大时，我们通常只关注高阶项，而忽略低阶、常数、系数项，但通常情况我们排序的规模并不大，这时这些低阶、常数、系数也要考虑进去</p>
</li>
<li><p>比较次数和交换（或移动）次数</p>
</li>
</ol>
<h4 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h4><p>内存消耗可以通过空间复杂度衡量。</p>
<p><strong>原地排序</strong>（Sorted in place）：就是特指空间复杂度是 O(1) 的排序算法。也就是说不需要额外的辅助空间。</p>
<h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p><strong>稳定性</strong> ： 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_stability.png" alt="稳定排序"></p>
<p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p>
<h3 id="基于比较的排序算法"><a href="#基于比较的排序算法" class="headerlink" title="基于比较的排序算法"></a>基于比较的排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bubble.png" alt="冒泡排序"></p>
<p>冒泡排序优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bubble_optimize.png" alt="冒泡排序优化"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;=<span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="comment">//提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(a[j+<span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Comparable tmp = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;<span class="comment">//表示有数据交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;<span class="comment">//没有数据交换，表示数组已经有序，直接退出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析"><a href="#衡量指标分析" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>冒泡排序是原地排序</li>
</ol>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<ol start="2">
<li>冒泡排序是稳定的排序算法</li>
</ol>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<ol start="3">
<li>冒泡排序的时间复杂度</li>
</ol>
<p>最好情况时间复杂度为O(n)，也就是在完全有序的情况下，只需要执行1次冒泡过程，即比较n-1次</p>
<p>最坏情况时间复杂度为O($n^2$)，就是在完全逆序的情况下，需要执行n次冒泡过程</p>
<p>平均情况时间复杂度为O($n^2$)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先，找到元素中最小的元素并与第一个元素交换位置，在从剩余的元素中找到最小的元素并与第二个元素交换位置，以此类推，直到整个数组有序。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_select.png" alt="选择排序"></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="comment">//min用来标记最小元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SortUtil.less(a[j], a[min])) min = j;</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtil.exch(a,i,min);</span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-1"><a href="#衡量指标分析-1" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>选择排序是原地排序</li>
<li>选择排序是不稳定的排序算法</li>
</ol>
<p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<ol start="3">
<li>选择排序的时间复杂度</li>
</ol>
<p>选择排序的最好、最坏、平均情况时间复杂度都为O($N^2$ )</p>
<p>​    比较次数：第n个元素需要比较的次数为(N-n)，总的比较次数为(N-1) + (N-2) + (N-3) + … + 3 + 2 + 1 = N(N-1)/2</p>
<p>​    交换次数：N次</p>
<p>特点：</p>
<ul>
<li>运行时间与元素的初始顺序无关</li>
<li>数据移动最少</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h5><ol>
<li>每插入一个元素，就从该元素开始与左侧的元素进行比较，如果小于则交换位置，然后在与交换后的位置前面的元素进行比较，如果小于则交换位置，以此类推。</li>
<li>然后在插入一个元素，重复步骤1，直到插入最后一个元素。</li>
</ol>
<p>要点就是每插入一个元素之前，其左侧元素已然有序，插入该元素后进行比较和交换，保证当前索引左侧所有元素有序</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_insert.png" alt="插入排序"></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(a[j - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable tmp = a[j];</span><br><span class="line">        a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换时只需一个赋值操作的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertTwo</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    Comparable value = a[i];<span class="comment">//要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];<span class="comment">//将比插入元素大的元素后移</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入新元素，注意循环时j--多执行了一次，所以需要j+1</span></span><br><span class="line">    a[j+<span class="number">1</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-2"><a href="#衡量指标分析-2" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>插入排序是原地排序</li>
</ol>
<p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。</p>
<ol start="2">
<li>插入排序是稳定的排序算法</li>
</ol>
<p>插入排序算法对于新插入的元素与已排序好的元素进行比较，元素相等时是不进行交换的，所以可以保持相等元素的原有相对顺序，所以插入排序是稳定的排序算法。</p>
<ol start="3">
<li>插入排序的时间复杂度</li>
</ol>
<p>最好情况时间复杂度：O(n)</p>
<p>​        输入元素的顺序正好是正向的（与你所期望的顺序一样），只需要比较不需要交换</p>
<p>​        比较次数：N-1 次</p>
<p>最坏情况时间复杂度：O($n ^ 2$)</p>
<p>​        输入元素的顺序正好是反向的，每次插入都相当于在数组的第一个位置插入新的数据</p>
<p>​        比较次数：1 + 2 + 3 + … + (N-3) + (N-2) + (N-1) = N(N-1)/2</p>
<p>​        交换次数：1 + 2 + 3 + … + (N-3) + (N-2) + (N-1) = N(N-1)/2</p>
<p>平均情况时间复杂度：O($n ^ 2$)</p>
<p>​        可以理想化为最坏情况下有一半元素是正向的</p>
<p>​        比较次数：1/2 + 2/2 + …. + (N-2)/2 + (N-1)/2 = N(N-1)/4</p>
<p>​        交换次数：1/2 + 2/2 + …. + (N-2)/2 + (N-1)/2 = N(N-1)/4 </p>
<p>​        还可以理解为在数组中插入一个元素的平均时间复杂度，并执行n次的效果，数组中插入一个元素的平均时间复杂度为O(n)，循环执行n次插入复杂度为O($n ^ 2$)</p>
<p>特点：</p>
<ul>
<li>插入排序对部分有序的数组十分高效</li>
<li>适合小规模数组</li>
</ul>
<p><strong>部分有序</strong>的数组特征：</p>
<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h5><p>实际上就是使用不同增量的插入排序。插入排序是相邻元素之间的交换，而希尔排序是间隔为h的元素之间交换。其中h是按照某种序列递减，比如从N/3开始递减至1，这种序列被称为<strong>递增序列</strong></p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//1,4,13,40,121,364,...</span></span><br><span class="line">  <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&gt;=h &amp;&amp; SortUtil.less(a[j],a[j-h]);j-=h)&#123;</span><br><span class="line">        SortUtil.exch(a,j,j-h);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h = h/<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-3"><a href="#衡量指标分析-3" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><p>时间复杂度：O($N^{5/4}$)</p>
<p>​    不到平方级别，具体执行时间依赖于递增序列，通常应用中采用上面代码中的序列[$1/2(3^k - 1)$]就足够了。</p>
<p>特点：</p>
<ul>
<li>数组越大，优势越大</li>
</ul>
<p>高效原因：</p>
<p>​    权衡了子数组的规模和有序性，排序之前，子数组都很短，排序之后子数组都是部分有序的，这两种情况正好适合插入排序。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h5><p>算法设计中分治思想的典型实现。先将数组拆分成两半分别排序，然后在将结果归并起来，使得数组整体有序，再递归的对两半数组分别拆分排序归并。正是分治思想将大的任务拆解成小的任务，再把小任务分别解决从而解决大任务的体现。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge.png" alt="归并排序"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo,hi]排序</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);<span class="comment">//左半边排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);<span class="comment">//右半边排序</span></span><br><span class="line">        merge(a, lo, mid, hi);<span class="comment">//归并排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组拷贝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;       <span class="comment">//左半边用尽，直接取右半边元素</span></span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;  <span class="comment">//右半边用尽，直接取左半边元素</span></span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SortUtil.less(aux[j], aux[i])) &#123;<span class="comment">//右半边的元素小于左半边的元素，取右半边元素</span></span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右半边元素大于等于左半边元素，取左半边元素</span></span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"M"</span>, <span class="string">"E"</span>, <span class="string">"R"</span>, <span class="string">"G"</span>, <span class="string">"E"</span>, <span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge_trace.png" alt="归并排序路径追踪"></p>
<h5 id="衡量指标分析-4"><a href="#衡量指标分析-4" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>归并排序不是原地排序算法</li>
</ol>
<p>在合并的时候使用了辅助空间，所以该算法的空间复杂度为O(n)</p>
<ol start="2">
<li>归并排序是稳定的排序算法</li>
</ol>
<p>归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码，当两个元素相等时，取左半部分元素，这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p>
<ol start="3">
<li>归并排序的时间复杂度</li>
</ol>
<p>最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge_complexity.png" alt="归并排序时间复杂度计算"></p>
<p>上图中每层需要比较的次数为N，所以需要比较的总次数为NlgN</p>
<p><strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p>
<p>假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C;n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) &#x3D; 2 * T(n&#x2F;2) + n;</span><br></pre></td></tr></table></figure>

<p>计算公式推到过程：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n</span><br><span class="line">     = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>) + n/<span class="number">2</span>) + n = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n</span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n</span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n</span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>

<p>得到T(n) = $2^k$  * T(n/$2^k$) + k * n ，当T(n/$2^k$) = T(1)时终止，即 n/$2^k$ = 1,k = $\log_2{n}$  , T(n) = Cn + n*$\log_2n$ ,采用大O标记法表示 T(n) = O(nlogn)，所以归并排序的时间复杂度为O(nlogn).</p>
<p>从实现思路及代码分析可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<p>特点：</p>
<ul>
<li>辅助数组需要占用额外的空间，并且大小与N成正比</li>
<li>可以处理大规模数组</li>
</ul>
<p>优化：</p>
<ul>
<li><p>对小规模子数组使用插入排序</p>
<p>  因为递归会使小规模问题中方法的调用过于频繁，所以使用插入排序处理小规模子数组（比如长度小于15），一般可以将归并排序的时间缩短10% ~ 15%</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>  归并的时候可以通过判断a[mid] &lt;= a[mid+1] 来避免merge过程</p>
</li>
<li><p>不将元素复制到辅助数组</p>
</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h5><p>也是基于分治思想。归并排序是将数组分成两个子数组分别排序，并将有序的子数组归并使整个数组有序。而快速排序是在拆分子数组的时候就确保了左子数组中的最大元素小于右子数组中的最小元素，通过partition切分，然后在进行递归调用。归并排序数组等分为两半；快速排序切分(partition)的位置取决于数组的内容</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_overview.png" alt="快排概览"></p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo,i-1],a[i],a[i+1,hi]</span></span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//停留在不小于v的元素下标上</span></span><br><span class="line">            <span class="keyword">while</span> (SortUtil.less(a[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//停留在不大于v的元素下标上</span></span><br><span class="line">            <span class="keyword">while</span> (SortUtil.less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//左右扫描指针相交时退出</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            SortUtil.exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将切分元素放入正确的位置</span></span><br><span class="line">        SortUtil.exch(a,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"Q"</span>, <span class="string">"U"</span>, <span class="string">"I"</span>, <span class="string">"C"</span>, <span class="string">"K"</span>, <span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//混排：将数组随机排序就是为了避免切分不平衡，比如每次选的切分元素恰好是最小或者最大的元素，则会导致一个子数组为空，每次排序只能排好一个元素，类似于选择排序</span></span><br><span class="line">        Collections.shuffle(Arrays.asList(arr));</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排执行流程跟踪如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_trace.png" alt="快排执行流程"></p>
<p>快排分区的执行流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_partition_trace.png" alt="快排分区执行流程"></p>
<h5 id="衡量指标分析-5"><a href="#衡量指标分析-5" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>快速排序是原地排序算法</li>
<li>快速排序不是稳定的排序算法</li>
<li>快速排序的时间复杂度</li>
</ol>
<p>快速排序的执行时间取决于切分元素（pivot 又叫分区点）的选择，如果每次分区恰好二分，那么时间复杂度递推公式与归并排序是相同的，时间复杂度就是O(nlogn)。如果每次分区后，一侧为空，一侧为满，则需要进行n次分区，每次分区只能排序一个元素，这时就有点类似选择排序，时间复杂度降为O($n^2$)。分别对应着快速排序的最好情况时间复杂度O(nlogn)和最坏情况时间复杂度 O($n^2$)。平均情况时间复杂度可以采用<strong>递归树</strong>进行分析，平均情况时间复杂度为O(nlogn)。</p>
<p>特点：</p>
<ul>
<li>原地排序（只需要很小的辅助栈）</li>
<li>切分不平衡时可能极为低效</li>
</ul>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ol>
<li><p>切换到插入排序</p>
<p> 对于小数组，快速排序比插入排序要慢，因为在小数组中，sort()方法还是会递归的调用自己。(个人理解：从元素重复度分析排序效率：1. 重复元素很少：当数组拆分的足够小且重复元素较少，这时大概率数组中元素已经部分有序，这时的递归调用效率要比插入排序低。2.重复元素较多：与产生三向切分的原因一样，在大量重复元素的情况下，再次递归经常会产生数组元素完全重复的子数组，而这样的子数组就不需要排序了)</p>
<p> 切换到插入排序的做法只需将sort()方法中的语句</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p> 替换为</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换参数M的最佳值与系统先关，通常情况下采用5 ~ 15 之间的任意值</span></span><br><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M) &#123;</span><br><span class="line">  Insertion.sort(a,lo,hi);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三取样切分</p>
<p> 使用子数组的一小部分元素的中位数来切分数组，代价是需要计算中位数。</p>
</li>
<li><p>三向切分快速排序</p>
<p> 排序库函数的最佳算法选择。</p>
<p> 实现思路：从左到右遍历数组，维护三个指针：一个指针lt使得a[lo,lt-1]的元素都小于v，一个指针gt使得a[gt+1,hi]的元素都大于v，一个指针i使得a[lt,i-1]的元素都等于v，a[i,gt]的元素待排序。具体处理步骤如下：</p>
<ol>
<li><p>a[i] 小于 v，交换a[i]和a[lt]，i 和 lt 加一</p>
</li>
<li><p>a[i] 大于 v，交换a[i]和a[gt]，gt 减一</p>
</li>
<li><p>a[i] 等于 v，i 加一</p>
<p>示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way_partition_overview.png" alt="三向切分示意图"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3way</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                SortUtil.exch(a, i++, lt++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                SortUtil.exch(a, i, gt--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"R"</span>, <span class="string">"B"</span>, <span class="string">"W"</span>, <span class="string">"W"</span>, <span class="string">"R"</span>, <span class="string">"W"</span>, <span class="string">"B"</span>, <span class="string">"R"</span>, <span class="string">"R"</span>, <span class="string">"W"</span>, <span class="string">"B"</span>, <span class="string">"R"</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>三项快速切分执行轨迹：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way_trace.png" alt="三项快速切分执行轨迹"></p>
<h5 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h5><ol>
<li>O(n)时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</li>
</ol>
<p>其实就是利用快速排序分区的思想，选取数组区间A[0…n-1]的第一个元素A[0]作为pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_pivot_topk.png" alt="快排TopK问题"></p>
<p>时间复杂度计算：就是每次分区后遍历元素之和，即n + n/2 + n/4 + … + 1 = 2n-1,所以时间复杂度为O(n)</p>
<h3 id="非基于比较的排序算法-线性排序"><a href="#非基于比较的排序算法-线性排序" class="headerlink" title="非基于比较的排序算法-线性排序"></a>非基于比较的排序算法-线性排序</h3><p>三种非基于比较的排序算法：桶排序、计数排序、基数排序，这些排序算法的时间复杂度都为O(n)，因为这些算法的时间复杂度都是线性的，所以也将这类排序算法称为<strong>线性排序(Linear Sort)</strong></p>
<h4 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序(Bucket Sort)"></a>桶排序(Bucket Sort)</h4><h5 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h5><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bucket.png" alt="桶排序"></p>
<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<h4 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h4><h5 id="实现思路-7"><a href="#实现思路-7" class="headerlink" title="实现思路"></a>实现思路</h5><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>举个例子：假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8] 中，它们分别是：2，5，3，0，2，3，0，3。</p>
<p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6] 的值。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_1.png" alt="计数排序步骤一"></p>
<p>然后对 C[6] 数组顺序求和，C[6] 存储的数据就变成了下面这样子。C[k] 里存储小于等于分数 k 的考生个数。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_2.png" alt="计数排序步骤二"></p>
<p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。以此类推。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_3.png" alt="计数排序步骤三"></p>
<p><strong>注意：扫描数组A的时候必须从末尾开始，这样才能保证计数排序是稳定排序算法</strong></p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<h4 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h4><p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_radix.png" alt="基数排序"></p>
<p>上图中只需要进行三次桶排序，分别从字符串的最后一位进行第一次桶排序，到第一位进行最后一次桶排序，因为基于稳定的排序算法，所以三次桶排序后所有字符串已有序。</p>
<p>10万手机号号码，按照从小到大进行排序，用基数排序可以在线性时间复杂度内完成，原理跟上图类似。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 —— 复杂度分析</title>
    <url>/2020/06/29/algorithm-complexity-analysis/</url>
    <content><![CDATA[<p>复杂度分析就是分析算法的执行效率和资源消耗与数据规模之间的增长关系。</p>
<a id="more"></a>

<h3 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h3><p>算法的执行效率可以简单的理解为所有代码的执行时间总和，记为T(n)，而所有代码的执行时间与每行代码的执行时间成正比，公式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) &#x3D; O(f(n));</span><br></pre></td></tr></table></figure>

<p>T(n)表示代码执行的时间；n表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>这就是<strong>大O时间复杂度表示法</strong>  。大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong> (asymptotic time complexity)，简称<strong>时间复杂度</strong>。</p>
<p>随着n的增长，公司中的低阶、常量、系数并不左右增长趋势，所以都可以忽略，只需要记住最大量级就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//1个unit_time</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//1个unit_time</span></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">//1个unit_time</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;<span class="comment">//n个unit_time</span></span><br><span class="line">    j = <span class="number">1</span>;<span class="comment">//n个unit_time</span></span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;<span class="comment">//n的平方个unit_time</span></span><br><span class="line">      sum = sum +  i * j;<span class="comment">//n的平方个unit_time</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设每行代码的执行时间为一个单元时间(unit_time)，那么上面代码的总执行时间T(n) = (2 $n^2$  + 2n + 3) * unit_time ，大O复杂度表示为T(n) = O(2 $n^2$  + 2n + 3) ，忽略低阶、常量、系数后，时间复杂度T(n) = O($n^2$)</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>分析时间复杂度时主要关注点：</p>
<ol>
<li>只关注循环执行次数最多的一段代码</li>
</ol>
<p><strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>
<ol start="2">
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     <span class="comment">//这段代码执行了100次，跟n无关，所以就是常量级的执行时间。因为我们此处考虑的是算法执行效率与数据规模增长的变化趋势，因此不管常量级的执行时间多大，都可以忽略。</span></span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述三段代码的时间复杂度分别为：常量时间、O(n)、O($n^2$) ，影响算法执行效率的一定是量级最大的那段代码，也就是第三段代码，所以上述代码的时间复杂度T(n) = O($n^2$) </p>
<ol start="3">
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);<span class="comment">//执行n次，T1(n)=O(n)</span></span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;<span class="comment">//每调一次f(n)方法该语句都会执行n次，T2(n)=O(n)</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码循环部分总的执行次数为 1 + 2 + 3 + … + n = n*(n+1) / 2 ，时间复杂度T(n) = O( $n^2$)，实际上就是两段for循环时间复杂度的乘积T1(n) * T2(n)</p>
<h3 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h3><p>常见时间复杂度量级：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_complexity_analysis_O.png" alt="常见时间复杂度"></p>
<p>以上复杂度量级可以粗略的分为：<strong>多项式量级</strong>和<strong>非多项式量级</strong>，而非多项式量级只有两个：O($2^n$) 和 O(n!)</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作<strong>NP</strong>（Non-Deterministic Polynomial，非确定多项式）<strong>问题</strong>。</p>
<p>随着数据规模n的增长，非多项式量级算法的执行时间会急剧增加，非常低效，不做讨论。这里只列举多项式量级的复杂度实例分析。</p>
<ol>
<li>O(1)</li>
</ol>
<p><strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千 上万行的代码，其时间复杂度也是Ο(1)</strong>。</p>
<ol start="2">
<li>O(logn) 、O(nlogn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码执行次数最多的是第三行，所以只要知道第三行代码的执行次数就能分析出该段代码的时间复杂度。这行代码最多执行次数满足条件 $2^x$ = n，x = logn。所以T(n) = O(logn).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的时间复杂度为O($log_3n$)</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)，因为对数之间是可以相互转换的，比如 $log_3n$ = $log_32$ * $log_2n$ ，计算复杂度的时候系数可以省略，所以O($log_3n$)=O($log_2n$)=O(logn)</p>
<ol start="3">
<li>O(m+n)、O(m*n)</li>
</ol>
<p>这是一种特殊的情况，代码的复杂度<strong>由两个数据的规模</strong>来决定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为无法评估m和n谁的量级大，所以无法进行省略，所以这段代码的时间复杂度就是O(m+n)</p>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>(asymptotic space complexity)，<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//存储变量i的空间</span></span><br><span class="line"> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储n个整型的数组所需的空间</span></span><br><span class="line"> <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">	a[i] = i * i;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"> print out a[i]</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码只有第三行申请了一个大小为n的int类型数组，所以空间复杂度为O(n).</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O($n^2$)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到.</p>
<h3 id="常见复杂度曲线图"><a href="#常见复杂度曲线图" class="headerlink" title="常见复杂度曲线图"></a>常见复杂度曲线图</h3><p>常见的复杂度从低阶到高阶：O(1)、O(logn)、O(n)、O(nlogn)、O($n ^ 2$)</p>
<p>algorithm_complexity_analysis_curve.png</p>
<p><img src="https://github.com/zhengguoqiang927/Figure-bed/blob/master/img/algorithm_complexity_analysis_curve.png?raw=true" alt="常见复杂度曲线图"></p>
<h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><p><strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。</strong></p>
<p><strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的意图是在长度为n的数组里查找x，那么最理想的情况是x恰好就在数组第一个位置，那么最好情况时间复杂度就是O(1)，最糟糕情况就是x不在数组中，那么就要遍历整个数组，那么最坏情况时间复杂度就是O(n)</p>
<h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>上面的代码平均情况时间复杂度分析：</p>
<p>要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p>
<p>1+2+3+….+n+n / n + 1 = n(n+3)/2(n+1) ~ O(n)</p>
<p>上面这种计算方式存在一个问题，就是没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，计算方式如下：</p>
<p>我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)，计算公式如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_complexity_analysis_average_time.png" alt="平均时间复杂度计算"></p>
<p>这个值就是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p>
<p>这个公式的结果去掉常量及系数后，平均时间复杂度为O(n)</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>均摊时间复杂度就是一种特殊的平均时间复杂度</p>
<p>摊还分析法：思路就是对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。</p>
<p>通过摊还分析法得到的时间复杂度叫做均摊时间复杂度。在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     array = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组空间够的时候每次插入操作的时间复杂度为O(1)，随着数据的插入，当i == len需要进行扩容，扩容操作的时间复杂度为O(n)，我们可以将这次扩容耗时多的操作均摊到前len-1次耗时少的插入操作上，均摊下来之后，每次插入操作的时间复杂度还是常量级的，即为O(1)。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程基础理论(二)——内存模型</title>
    <url>/2020/06/20/java-concurrency-jmm/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_bridging.png" alt="内存模型与硬件内存架构"></p>
<a id="more"></a>

<p>在上一篇中讲到在多处理器系统中，为了提高程序性能，硬件、操作系统还有编译器及处理器都做了很多努力，但性能提升的同时也带来了新的问题：可见性、原子性、有序性问题。Java内存模型就是为了解决这些问题应运而生。</p>
<p>Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。</p>
<p>Java包含了几个语言级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能正确的运行。</p>
<p>Java内存模型主要分为两部分，前面说的属于其中一部分，这部分主要是面向我们这些程序员的，还有另一部分是面向JVM开发人员的，这部分主要实现JVM与计算机内存之间的协同工作。</p>
<h3 id="Java内存模型内部原理"><a href="#Java内存模型内部原理" class="headerlink" title="Java内存模型内部原理"></a>Java内存模型内部原理</h3><p>Java内存模型把Java虚拟机内部划分为线程栈和堆，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_jmm.png" alt="Java内存模型逻辑图"></p>
<p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息（栈帧）。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程仍然在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p>
<p>下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_threadstack_heap.png" alt="Java线程栈和堆"></p>
<p>关于对象、引用、基础类型的存储位置可以总结为以下几种情况：</p>
<ol>
<li><p>局部变量可以是原始类型，这种情况下存储在线程栈中。</p>
</li>
<li><p>局部变量也可以是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</p>
</li>
<li><p>一个对象可能包含方法，而这些方法可能包含局部变量。即使方法所属的对象存储在堆中，这些局部变量也存储在线程栈中。</p>
</li>
<li><p>对象的成员变量与对象本身一起存储在堆中，不管这个成员变量是原始类型还是引用类型。</p>
</li>
<li><p>静态成员变量跟随着类定义一起也存放在堆上。</p>
</li>
<li><p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</p>
</li>
</ol>
<h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><p>现代计算机硬件架构的简单图示：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_hardware_memory.png" alt="硬件内存架构"></p>
<p>通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p>
<p>当CPU需要将其他内容存储在高速缓存中时，通常会将高速缓存中存储的值刷新回主存储器。CPU不会一次性的读取或者写入高速缓存的全部内容，刷新也是一样，CPU读写和刷新高速缓存是以缓存行（cache lines）为单位，每次会从内存中读取一个或者多个缓存行的数据到高速缓存中，同样每次会将一个或者多个缓存行的数据从高速缓存刷新到内存中。</p>
<h3 id="Java内存模型与硬件内存架构之间的桥接"><a href="#Java内存模型与硬件内存架构之间的桥接" class="headerlink" title="Java内存模型与硬件内存架构之间的桥接"></a>Java内存模型与硬件内存架构之间的桥接</h3><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_bridging.png" alt="内存模型与硬件内存架构"></p>
<p>上面这三部分主要介绍了java内存模型对java虚拟机与计算机内存之间协同工作的规范，下面介绍java内存模型对多线程在内存中操作共享变量的规范</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before是JMM最核心的概念，所以理解happens-before是理解JMM的关键。</p>
<p>设计JMM的核心目标就是能够找到一个平衡点：一方面能够为程序员提供足够强的内存可见性保证；另一方面又对编译器和处理器优化程序不会有太多的限制。而JMM提供的happens-before规则就是这个平衡点，JMM的happens-before规则简单易懂，而且向程序员提供了足够强的内存可见性保证，同时对编译器和处理器的束缚已经尽可能少。</p>
<p>其实JMM在遵循一个基本原则：只要不改变程序的执行结果(指的是单线程程序和正确同步的多线程程序)，编译器和处理器怎么优化都行。例如，编译器经过细致的分析后发现一个锁只会被单个线程访问，那么这个锁就会被消除。又或者一个volatile变量只会被单个线程访问，那么编译器会将这个volatile变量当成一个普通变量来使用。这些优化都不会改变程序的执行结果，但是又能提高执行效率。</p>
<h4 id="happens-before定义"><a href="#happens-before定义" class="headerlink" title="happens-before定义"></a>happens-before定义</h4><p>JSR-133中对happens-before定义如下：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一操作的执行结果对第二个操作可见，而且第一个操作的执行顺序在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before指定的顺序来执行。如果重排序之后的执行结果，与按照happens-before关系的执行结果一致，那么这种重排序并不非法（<br> JMM允许这种重排序）</li>
</ol>
<p>1是JMM对程序员的保证，即A happens-before B，那么A的结果对B一定可见。</p>
<p>2是JMM对编译器和处理器重排序的约束。即只要不改变程序的执行结果(单线程程序和正确同步的多线程程序)，编译器和处理器怎么优化都行。这个优点类似于as-if-serial语义，只不过as-if-serial是针对单线程的。</p>
<h4 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h4><p>JSR-133中定义的happens-before规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</li>
<li>传递性：如果 A happens-before B，且B happens-before C，则A happens-before C</li>
<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作</li>
<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回（意思就是在线程A调用的B.join()返回时能够看到B中的执行结果）</li>
</ol>
<h3 id="同步原语-volatile、synchronized、final"><a href="#同步原语-volatile、synchronized、final" class="headerlink" title="同步原语 volatile、synchronized、final"></a>同步原语 volatile、synchronized、final</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile变量特性：</p>
<ol>
<li>可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
<li>禁止必要的重排序：对于会改变程序执行结果的重排序进行禁用</li>
</ol>
<h5 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h5><ul>
<li>volatile写</li>
</ul>
<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</p>
<ul>
<li>volatile读</li>
</ul>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，并从主内存中读取共享变量</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_volatile.png" alt="volatile写-读内存语义"></p>
<h5 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h5><p>在介绍volatile内存语义的实现之前先介绍下内存屏障，因为volatile的内存语义就是<strong>通过编译器在生成字节码时，在指令序列中插入内存屏障来禁止特定类型的处理器重排序</strong>。</p>
<p>JMM把内存屏障指令分为4类，如下表所示：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保Load1数据的装载先于Load2及所有后续装载指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>确保Store1数据对其他处理器可见(刷新到内存)先于Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>确保Store1数据对其他处理器可见(刷新到内存)先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存指令访问(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers是一个全能型的屏障，同时具有其他三个屏障的效果。现代的多处理器大多支持该屏障。<strong>执行该屏障的开销很大，因为当前处理器通常需要把写缓冲区中的数据全部刷新到内存中(Buffer Fully Flush)</strong>。</p>
<p>JMM针对编译器制定的volatile重排序规则表：</p>
<table>
<thead>
<tr>
<th>是否重排序</th>
<th>第二个操作</th>
<th>第二个操作</th>
<th>第二个操作</th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读/写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读/写</td>
<td></td>
<td></td>
<td>NO</td>
</tr>
<tr>
<td>volatile读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p>从上表可以得出的结论：</p>
<ol>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序</li>
</ol>
<p>JMM采用保守的内存屏障插入策略，这样可以保证在任意处理器平台，任意程序中都能得到正确的volatile内存语义。</p>
<ul>
<li>在每个volatile写操作之前插入一个StoreStore屏障</li>
<li>在每个volatile写操作之后插入一个StoreLoad屏障</li>
<li>在每个volatile读操作之后分别插入一个LoadLoad屏障和一个LoadStore屏障</li>
</ul>
<p>volatile写插入内存屏障后生成的指令序列示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_volatile_write.png" alt="volatile写内存语义实现示意图"></p>
<p>volatile读插入内存屏障后生成的指令序列示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_volatile_read.png" alt="volatile读内存语义实现示意图"></p>
<p>在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p>
<h5 id="JSR-133对volatile的语义增强"><a href="#JSR-133对volatile的语义增强" class="headerlink" title="JSR-133对volatile的语义增强"></a>JSR-133对volatile的语义增强</h5><p>在旧的内存模型下，访问volatile变量不能被重排序，但是，它们可能和访问非volatile变量一起被重排序。这破坏了volatile字段从一个线程到另外一个线程作为一个信号条件的手段。</p>
<p>在新的内存模型下，volatile变量仍然不能彼此重排序。和旧模型不同的时候，volatile周围的普通字段的也不再能够随便的重排序了。写入一个volatile字段和释放监视器有相同的内存影响，而且读取volatile字段和获取监视器也有相同的内存影响。</p>
<p><strong>JSR-133增强volatile语义的目的就是为了提供一种比锁更轻量级的线程之间通信的机制</strong> 。增强后的volatile内存语义：<strong>严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义</strong> 。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>有序性和可见性仅对volatile字段进行一次读取或更新操作起作用。</li>
<li>声明一个引用变量为volatile，不能保证通过该引用变量访问到的非volatile变量的可见性。比如声明一个数组变量为volatile不能确保数组内元素的可见性。volatile的特性不能在数组内传递，因为数组里的元素不能被声明为volatile。</li>
<li>通常情况下，一个volatile字段很适合作为完成某些工作的标志。</li>
</ol>
<h4 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h4><p>锁释放内存语义：</p>
<p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到内存中。</p>
<p>锁获取内存语义：</p>
<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效，并使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p>
<h5 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h5><ul>
<li>synchronized</li>
</ul>
<ul>
<li>ReentrantLock 内存语义实现</li>
</ul>
<p>ReentrantLock基于Java同步器框架AbstractQueuedSynchronizer（简称AQS）实现，AQS通过一个volatile变量state来维护同步状态，所以ReentrantLock的内存语义也是变向的基于volatile内存语义实现的。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_jmm_reentrantlock.png" alt="ReentrantLock类图"></p>
<p>图中红线表示内部类。也就是说ReentrantLock有三个内部类：Sync、FairSync、NonfairSync，其中抽象类Sync继承自Java同步器框架AbstractQueuedSynchronizer，FairSync和NonfairSync分别是抽象类Sync的公平锁与非公平锁实现。</p>
<p>非公平锁NonfairSync的加锁方法lock()调用轨迹如下：</p>
<ol>
<li>ReentrantLock : lock()</li>
<li>AbstractQueuedSynchronizer : tryAcquire(int arg)</li>
<li>NonfairSync : tryAcquire(int arg)</li>
<li>Sync : nonfairTryAcquire(int arg)</li>
</ol>
<p>最终在第4步开始加锁，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">     <span class="keyword">int</span> c = getState();<span class="comment">//开始获取锁，首先读取volatile变量state</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//加锁操作，原子更新同步状态变量state</span></span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">          <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">          <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">          setState(nextc);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的加锁操作是通过执行同步器AbstractQueuedSynchronizer的<code>compareAndSetState(0, acquires)</code> 方法以原子的方式更新同步状态state，<code>compareAndSetState</code>的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">     * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">     * and write.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">     *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);<span class="comment">//java9之后采用VarHandle变量STATE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK文档对该方法的注释：如果当前状态值等于期望值，则以原子方式将同步状态值设置为给定的更新值。该操作具有volatile读和写的内存语义。</p>
<p>CAS同时具有volatile读和写的内存语义的实现原理：基于处理器提供的cmpxchg指令，该指令在多处理器上运行时会加lock前缀，lock前缀的效果如下：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。通过缓存锁定（Cache Lock）来保证指令执行的原子性</li>
<li>禁止该指令与之前和之后的读和写指令重排序</li>
<li>把写缓冲区中的所有数据刷新到内存中</li>
</ol>
<p>由这三条规则可知：CAS能够同时保证原子性、可见性、有序性，可见CAS与synchronized具有相同的内存语义。</p>
<p>ReentrantLock锁释放-获取的内存语义主要通过以下两方面来实现：</p>
<ol>
<li>利用volatile变量的写-读所具有的内存语义</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义</li>
</ol>
<p>ReentrantLock锁的实现是一种通用化的实现模式，整个java.util.concurrent包都是采用这种模式实现，这种通用模式可以简述为以下几步：</p>
<ol>
<li>声明共享变量为volatile</li>
<li>使用CAS的原子更新实现线程之间的安全同步</li>
<li>在通过volatile变量的读-写和CAS所具有的volatile读-写的内存语义来实现线程之间的通信</li>
</ol>
<p>AQS、非阻塞数据结构和原子变量类，这些concurrent包中的基础类都是使用这种模式实现的。而高层类又是依赖这些基础类实现的。整个concurrent的实现可以用下图表示：</p>
<h4 id="final的内存语义"><a href="#final的内存语义" class="headerlink" title="final的内存语义"></a>final的内存语义</h4><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ol>
<h5 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h5><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：</p>
<ul>
<li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_jmm_final_write.png" alt="final写重排序"></p>
<p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p>
<p>写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 2 还没有写入普通域 i）。</p>
<h5 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h5><p>读 final 域的重排序规则如下：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_jmm_final_read.png" alt="final读重排序"></p>
<p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p>
<h5 id="final域是引用类型"><a href="#final域是引用类型" class="headerlink" title="final域是引用类型"></a>final域是引用类型</h5><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p>
<ol>
<li>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_jmm_final_reference.png" alt="final引用重排序"></p>
<p>在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p>
<p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p>
<h5 id="final引用逃逸"><a href="#final引用逃逸" class="headerlink" title="final引用逃逸"></a>final引用逃逸</h5><p>写 final 域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的 final 域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逃逸”。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_jmm_final_escape.png" alt="final逃逸分析"></p>
<p>当1和2发生重排序时，线程B读取到obj不为空，则执行获取final域，而此时线程A还没有完成final域的初始化操作，导致线程B读取到不正确的值。</p>
<h5 id="JSR-133对final语义的增强"><a href="#JSR-133对final语义的增强" class="headerlink" title="JSR-133对final语义的增强"></a>JSR-133对final语义的增强</h5><p>在旧的 Java 内存模型中 ，最严重的一个缺陷就是线程可能看到 final 域的值会改变。比如，一个线程当前看到一个整形 final 域的值为 0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个 final 域的值时，却发现值变为了 1（被某个线程初始化之后的值）。最常见的例子就是在旧的 Java 内存模型中，String 的值可能会改变。</p>
<p>为了修补这个漏洞，JSR-133 专家组增强了 final 的语义。通过为 final 域增加写和读重排序规则，可以为 java 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>Java并发编程的艺术</p>
<p><a href="https://time.geekbang.org/column/article/84017" target="_blank" rel="noopener">Java内存模型：看Java如何解决可见性和有序性问题</a></p>
<p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">JSR 133 (Java Memory Model) FAQ</a></p>
<p><a href="http://ifeve.com/jmm-faq/" target="_blank" rel="noopener">Java内存模型FAQ</a></p>
<p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: JavaTM Memory Model and Thread Specification</a></p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="noopener">Java Memory Model</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程基础理论(一)——可见性、原子性、有序性</title>
    <url>/2020/06/19/java-concurrency-visibility-atomicity-orderly/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory1_multicpu.png" alt="多核CPU的缓存与内存关系图"></p>
<a id="more"></a>

<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>随着计算机的快速发展，我们的硬件设备CPU、内存、磁盘都在不停的更新换代，速度也越来越快，但是他们三者的本质问题并没有解决，那就是<strong>三者之间的速度差异</strong> ，三者的速度不在一个量级，CPU的速度比内存快，内存的速度比磁盘快，根据木桶理论，程序的性能取决于三者中速度最慢的那一个——磁盘（I/O读写）。</p>
<p>为了平衡三者的速度差异，提高CPU的利用率，计算机体系结构、操作系统、编译程序都做出了贡献，体现为：</p>
<ol>
<li>CPU增加了缓存，用来均衡与内存的速度差异</li>
<li>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异</li>
<li>编译程序优化指令执行顺序，进而更加充分的利用缓存</li>
</ol>
<p>这些优化给程序性能带来了极大的提升，但同时也带来了诸多的问题，接下来我们逐个这三项优化带来的问题</p>
<h3 id="缓存带来的可见性问题"><a href="#缓存带来的可见性问题" class="headerlink" title="缓存带来的可见性问题"></a>缓存带来的可见性问题</h3><p>单核时代不存在可见性问题，因为多个线程操作的都只是这一个CPU的缓存，一个线程A更新了共享变量的值，另一个线程B访问共享变量，因为是顺序执行，所以线程B一定能够得到最新的值</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory1_singlecpu.png" alt="单核CPU的缓存与内存关系图"></p>
<p><strong>可见性</strong> ：一个线程对共享变量的修改，其他线程能够立刻看到</p>
<p>多核时代，每个CPU都有自己的缓存，当多个线程在不同的CPU上执行时，每个线程操作的都是不同的CPU缓存，那么这时一个线程对共享变量的修改对其他线程来说就不再是可见的了，所以就产生了缓存与内存的数据一致性问题。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory1_multicpu.png" alt="多核CPU的缓存与内存关系图"></p>
<p>举个简单的例子，创建两个线程a、b，分别对同一个对象的成员变量count累加一万次，会得到什么结果？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add10K</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10k</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (idx++ &lt; <span class="number">10000</span>)&#123;</span><br><span class="line">               count += <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="comment">//共享变量</span></span><br><span class="line">          <span class="keyword">final</span> Add10K instance = <span class="keyword">new</span> Add10K();</span><br><span class="line">          Thread a = <span class="keyword">new</span> Thread(() -&gt; instance.add10k());</span><br><span class="line">          Thread b = <span class="keyword">new</span> Thread(() -&gt; instance.add10k());</span><br><span class="line">          <span class="comment">//启动线程</span></span><br><span class="line">          a.start();</span><br><span class="line">          b.start();</span><br><span class="line">          <span class="comment">//当前线程等待子线程结束</span></span><br><span class="line">          a.join();</span><br><span class="line">          b.join();</span><br><span class="line">          <span class="keyword">return</span> instance.count;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          System.out.println(calc());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？</p>
<p>我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。</p>
<h3 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="headerlink" title="线程切换带来的原子性问题"></a>线程切换带来的原子性问题</h3><p>操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory1_threadchange.png" alt="线程切换"></p>
<p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。</p>
<p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p>
<p>任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。</p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>
<p>操作系统做任务切换，可以发生在任何一条 CPU 指令执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory1_atomic.png" alt="非院子操作的执行路径"></p>
<p><strong>原子性</strong> ：一个或者多个操作在 CPU 执行的过程中不被中断的特性</p>
<p>CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符</p>
<h3 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="headerlink" title="编译优化带来的有序性问题"></a>编译优化带来的有序性问题</h3><p><strong>有序性</strong> ：就是指按照代码的先后顺序执行</p>
<p>有序性典型的案例就是单例模式中双重检查锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题出在new操作上，我们以为的 new 操作应该是：</p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量</li>
</ol>
<p>但是实际上优化后的执行路径却是这样的：</p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象</li>
</ol>
<p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory1_doublecheck.png" alt="双重检查创建单例的异常执行路径"></p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>引起上面这个问题的原因就是编译器对指令进行了重排序，以提高性能，其实除了编译器可以对指令进行重排序，处理器也可以，下面简单介绍下重排序</p>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序分为三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序。现在处理器采用了指令级并行技术(Instruction-Level Parallelism,ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能实在乱序执行</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，经历重排序的顺序如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_theory2_reorder.png" alt="源码到最终实际执行的指令序列"></p>
<p>1属于编译器重排序，2和3属于处理器重排序。</p>
<p>重排序需要注意的事项如下：</p>
<ul>
<li>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</li>
<li>必须遵守as-if-serial语义，即不管怎么重排序，单线程程序的执行结果不能被改变</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以在<strong>采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避</strong>。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2020/04/30/java-concurrency-Concurrency-Programming/</url>
    <content><![CDATA[<p>本文简单介绍并发编程的基础内容</p>
<a id="more"></a>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><h4 id="线程带来的好处"><a href="#线程带来的好处" class="headerlink" title="线程带来的好处"></a>线程带来的好处</h4><ol>
<li>提升资源利用率，比如多核处理器、IO操作</li>
<li>简化建模</li>
<li>简化异步事件处理</li>
<li>提升GUI响应速度</li>
</ol>
<h4 id="线程带来的问题"><a href="#线程带来的问题" class="headerlink" title="线程带来的问题"></a>线程带来的问题</h4><ol>
<li>安全性问题：多线程情况下，无法保证程序执行的正确性。正确性的含义就是类的行为与其规范完全一致。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_unsafesequence.png" alt="UnsafeSequence错误执行情况"></p>
<p>不安全的原因：value++不是一个原子操作，而是一个复合操作：读取value、将value加1、value回写到内存</p>
<blockquote>
<p>线程安全性定义：当多个线程访问某个类时，在没有额外的协同或者同步的情况下，这个类始终都能表现出正确的行为，就称这个类是线程安全的。</p>
</blockquote>
<p><strong>无状态对象一定是线程安全的</strong></p>
<ol start="2">
<li>活跃性问题：正确的事情最终会发生。典型问题比如死锁、饥饿、活锁</li>
<li>性能问题：比如频繁的线程上下文切换（多线程程序中，线程调度器临时挂起活跃线程转而执行另一个线程时，就需要执行线程上下文的切换，当频繁的进行线程切换时，将会带来极大的开销：保存/恢复上下文，CPU将更多的时间花费在线程调度而不是线程运行）以及共享数据采用同步机制时会抑制某些编译器优化，使内存缓冲区中的数据无效，从而增加内存总线的同步流量。</li>
</ol>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>原子操作定义：有A、B两个操作，从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么不执行，同理B看A也是如此，那么就成AB之间是原子的。原子操作是指，对于访问同一个状态的所有操作，都是以原子方式执行的。比如AtomicXXX类中的方法都是原子的</p>
</blockquote>
<h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><blockquote>
<p>当一个线程修改了对象状态后，其他线程能够看到修改之后的状态变化</p>
</blockquote>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile变量是一种比synchronized关键字更轻量级的同步机制，用来确保将变量的更新操作通知到其他线程。volatile变量不会被缓存在寄存器或者其他处理器看不见的地方，因此在读取volatile变量都会从内存拉取最新的值。</p>
<p>volatile另外一个作用是<strong>禁止指令重排序</strong></p>
<p><strong>注意</strong> ：加锁机制既可以确保可见性又可以确保原子性，而volatile只能保证可见性，无法保证原子性</p>
<p>使用volatile需要满足的条件：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者确保只在单个线程中更新变量（一个线程写，其他线程读）</li>
<li>访问变量不需要加锁</li>
<li>不与其他变量一起纳入不变性条件中</li>
</ul>
<h4 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h4><p><strong>发布</strong> 是指使一个对象能够在当前作用域之外的代码中使用。 <strong>逸出</strong>：某个不应该发布的对象被发布。</p>
<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>当访问共享的可变数据时，通常需要使用同步。要想不使用同步，要么不共享，要么不可变。</p>
<p>线程封闭就是不共享数据，将其封闭在单线程内，即便数据是可变的，那对其他线程也没有影响，同时也不需要同步处理，是实现线程安全性的最简单方式之一。 </p>
<h5 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h5><p>Ad-hoc线程封闭是指，维护线程封闭性的 职责完全由程序实现来承担。Ad-hoc线程封闭是脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。所以在可能的情况下尽量少使用它，转而使用封闭性更强的线程封闭技术（比如 栈封闭和ThreadLocal）</p>
<p>线程封闭典型的例子：volatile变量封闭，即确保只有一个线程对共享的volatile变量执行写入操作，其他线程只进行读取操作。实际上是通过避免在多线程同时修改共享的volatile变量产生的竞态条件，同时volatile的可见性保证其他线程能够即时感知到变量状态的变化，从实现线程安全性。</p>
<h5 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h5><p>栈封闭实际上就是通过局部变量访问对象。也就是在本线程内创建对象，该对象只有本线程的局部变量可以访问，局部变量（对象引用）是存储在栈上的，而栈是线程私有的数据结构，因此局部变量只能在各个线程内部访问，线程间是不共享的，所以是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123; </span><br><span class="line"> 	SortedSet&lt;Animal&gt; animals; </span><br><span class="line">    <span class="comment">//基础类型的局部变量始终封闭在线程内，因为基础类型、对象引用、返回地址存储于栈中</span></span><br><span class="line"> 	<span class="keyword">int</span> numPairs = <span class="number">0</span>; </span><br><span class="line"> 	Animal candidate = <span class="keyword">null</span>; </span><br><span class="line"> 	<span class="comment">// animals对象在线程内部创建，只要确保其不逸出就能保证线程安全</span></span><br><span class="line"> 	animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator()); </span><br><span class="line"> 	animals.addAll(candidates); </span><br><span class="line"> 	<span class="keyword">for</span> (Animal a : animals) &#123; </span><br><span class="line"> 		<span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a)) </span><br><span class="line"> 			candidate = a; </span><br><span class="line"> 		<span class="keyword">else</span> &#123; </span><br><span class="line"> 			ark.load(<span class="keyword">new</span> AnimalPair(candidate, a)); </span><br><span class="line"> 			++numPairs; </span><br><span class="line"> 			candidate = <span class="keyword">null</span>; </span><br><span class="line"> 		&#125; </span><br><span class="line"> 	&#125;	 </span><br><span class="line"> 	<span class="keyword">return</span> numPairs; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>如果某个对象在创建完之后其状态就不可在修改，那么这个对象就是<strong>不可变对象</strong> 。</p>
<blockquote>
<p>不可变对象一定是线程安全的</p>
</blockquote>
<p><strong>注意</strong> ：不可变性不等于将对象的所有域都声明为final类型，即时将所有域都声明为final类型，该对象也仍然有可能是可变的，因为final类型的域可以保存可变对象的引用。比如final 修饰的集合类</p>
<p>不可变对象需要满足的条件：</p>
<ul>
<li>对象创建之后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的（对象创建期间，this引用没有逸出）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Immutable</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;(); </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		stooges.add(<span class="string">"Moe"</span>); </span><br><span class="line"> 		stooges.add(<span class="string">"Larry"</span>); </span><br><span class="line"> 		stooges.add(<span class="string">"Curly"</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> stooges.contains(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreeStooges对象是线程安全的，尽管final修饰的stooges变量可以保存可变对象，但是在ThreeStooges构造完成之后stooges就不在可变了，所以是线程安全的。</p>
<h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><p>得到一个线程安全的容器有以下三种情况：</p>
<ol>
<li>使用早期的Vector和Hashtable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </li>
<li>Collections.synchronizedXxx方法</li>
<li>Java 5.0提供的ConcurrentXXX类</li>
</ol>
<p>1和2存在的问题：</p>
<ul>
<li>复合操作（迭代、跳转、条件运算）需要在客户端额外的加锁 </li>
<li>性能低</li>
<li>迭代（包含显式迭代和隐氏迭代，比如toString方法就属于隐氏迭代）过程中并发修改会”及时失败（fail-fast）”，立刻抛出ConcurrentModificationException异常。实现机制就是通过判断计数器是否修改</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap vs HashTable</p>
<ol>
<li>HashTable是线程安全的(方法都有synchronized修饰)，HashMap是线程不安全的</li>
<li>HashTable不允许null 键和null值，HashMap允许一个null键和任意个null值</li>
</ol>
<p>由于HashMap是线程不安全的，所以在并发环境下执行put操作可能会引起死循环，导致CPU利用率达到100%.</p>
<p>原因是因为多线程导致HashMap的Entry链表形成环形数据结构</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap通过<strong>分段锁</strong>机制（一种粒度更细的加锁机制）来提供更高的并发性与伸缩性。同时提供的迭代器不会抛出ConcurrentModificationException异常，而是返回具有弱一致性（Weakly Consistent）的迭代器。</p>
<p>size方法返回一个近似值而不是一个精确值。</p>
<p><strong>注意</strong>：只有当应用程序需要加锁Map以进行独占访问时，才使用1和2方式，否则最好采用ConcurrentHashMap</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>juc中提供了以下几种常用实现：</p>
<ul>
<li>LinkedBlockingQueue</li>
<li>ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>Java 6增加了两个容器：Deque和BlockingDeque。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和删除。具体实现包括ArrayDeque和LinkedBlockingDeque。双端队列的一个典型应用场景：工作窃取（Work Stealing），而工作窃取的典型实现案例：Fork/Join框架</p>
<h4 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h4><ul>
<li>CountDownLatch</li>
<li>Semaphore </li>
<li>CyclicBarrier</li>
<li>Exchanger</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程可以有如下 6 种状态(线程状态在java.lang.Thread.State枚举中定义)：</p>
<ul>
<li>New（新创建）</li>
<li>Runnable（可运行）</li>
<li>Blocked（被阻塞）</li>
<li>Waiting（等待）</li>
<li>Timed waiting（计时等待）</li>
<li>Terminated（被终止）</li>
</ul>
<h4 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h4><p>当用 new 操作符创建一个新线程时，如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。</p>
<h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线程可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。</p>
<h4 id="阻塞线程和等待线程"><a href="#阻塞线程和等待线程" class="headerlink" title="阻塞线程和等待线程"></a>阻塞线程和等待线程</h4><h4 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h4><p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>run方法正常退出而自然终止</li>
<li>因为一个没有捕获的异常终止的run方法而意外终止</li>
</ul>
<p><code>java.lang.Thread 1.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待终止指定的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待指定的线程终止或者经过指定的毫秒数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程状态 NEW/RUNNABLE/BLOCKED/WAITING/TIMED_WAITING/TERMINATED</span></span><br><span class="line">Thread.<span class="function">State <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导致当前执行线程处于让步状态。 如果有其他的可运行线程具有至少与此线程同样高的优先级， 那么这些线程接下来会被调度。 注意，这是一个静态方法。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>包括线程优先级、守护线程、线程组以及处理未捕获异常的处理器</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在 Java 程序设计语言中，每一个线程有一个优先级。默认情况下， 一个线程继承它的父线程的优先级。可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5。</p>
<p>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。 但是， 线程 优先级是<strong>高度依赖于系统的</strong>。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多， 也许更少。</p>
<p>线程优先级是高度依赖于系统的。例如，Windows 有 7 个优先级别。一些 Java 优先级将映射到相同的操作系统优先级。在Oracle 为 Linux 提供的 Java 虚拟机中，线程的优先级被忽略，即所有线程具有相同的优先级</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>通过调用<code>t.setDaemon(true)</code>将线程转换为守护线程（daemon thread)。守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时， 虚拟机就退出了。守护线程应该永远不去访问固有资源， 如文件、 数据库， 因为它会在任何时候甚至在一个操作的中间发生中断。</p>
<h4 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h4><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>用ReentrantLock保护代码块的基本结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock();<span class="comment">//a ReentrantLock object</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    myLock.unlock();<span class="comment">//make sure the lock is unlocked even if an exception is thrown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一结构确保任何时刻只有一个线程进入临界区。</p>
<p><strong>注意</strong>：把解锁操作括在 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则， 其他线程将永远阻塞</p>
<p>锁是可重入的， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（ hold count) 来跟踪对 lock 方法的嵌套调用。线程在每一次调用 lock 都要调用 unlock 来释放锁。由于这一特性， 被一个锁保护的代码可以调用另一个使用相同的锁的方法。</p>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常， 线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。</p>
<p>一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sufficientFunds = bankLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    bankLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">            sufficientFunds.await();<span class="comment">//余额不足时，阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//transfer funds</span></span><br><span class="line">        ...</span><br><span class="line">        sufficientFunds.signalAll();<span class="comment">//唤起所有在该条件上等待的线程</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        bankLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意调用 signalAll 不会立即激活一个等待线程。它仅仅解除等待线程的阻塞， 以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。</p>
<p>另一个方法 signal, 则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行， 那么它再次被阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了。</p>
<p><code>java.util.concurrent.locks.Lock 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个与该锁相关的条件对象</span></span><br><span class="line"><span class="function">Condition new <span class="title">Condition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.locks.Condition 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将该线程放到条件的等待集中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒在该条件上阻塞的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒在该条件上阻塞的某一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>内部锁和条件存在一些局限。包括：</p>
<ul>
<li>不能中断一个正在试图获取锁的线程</li>
<li>试图获得锁时不能设定超时</li>
<li>每个锁仅有单一的条件，可能是不够的</li>
</ul>
<p>关于ReentrantLock和Synchronized的一些使用建议：</p>
<ul>
<li>最好既不使用 Lock/Condition 也不使用 synchronized 关键字。 在许多情况下你可以使用java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。</li>
<li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它， 这样可以减少编写的代 码数量， 减少出错的几率。</li>
<li>如果特别需要 Lock/Condition 结构提供的独有特性时， 才使用 Lock/Condition。</li>
</ul>
<p><code>java.lang.Object 1.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解除那些在该对象上调用 wait 方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。 如果当前线程不是对象锁的持有者， 该方法拋出一个 IllegalMonitorStateException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//随机选择一个在该对象上调用 wait 方法的线程， 解除其阻塞状态。 该方法只能在一 个同步方法或同步块中调用。 如果当前线程不是对象锁的持有者， 该方法抛出一个 IllegalMonitorStateException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//导致线程进入等待状态直到它被通知。该方法只能在一个同步方法中调用。 如果当前线程不是对象锁的持有者， 该方法拋出一个 IllegalMonitorStateException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//导致线程进入等待状态直到它被通知或者经过指定的时间。 这些方法只能在一个同步方法中调用。如果当前线程不是对象锁的持有者该方法拋出一个 IllegalMonitorStateException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><h4 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h4><p>volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p>
<p><strong>Volatile 变量不能提供原子性。</strong></p>
<h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h4><p>使用final声明一个共享变量时，多个线程可以安全的访问该共享变量，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他线程会在构造函数完成构造之后才看到这个 accounts 变量,如果不使用 final 就不能保证其他线程看到的是 accounts 更新后的值， 它们可能都只是看到null, 而不是新构造的HashMap。</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;String,Double&gt; account = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//final只是使account这个引用不允许改变</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：对这个映射表的操作并不是线程安全的。 如果多个线程在读写这个映射表， 仍然需要进行同步。</p>
<h4 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h4><p>java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性。 例如， Atomiclnteger 类提供了方法 incrementAndGet 和decrementAndGet, 它们分别以原子方式将一个整数自增或自减。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong nextNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//In some thread</span></span><br><span class="line"><span class="comment">//incrementAndGet 方法以原子方式将 AtomicLong 自增， 并返回自增后的值。 也就是说， 获得值、 增 1 并设置然后生成新值的操作不会中断。</span></span><br><span class="line"><span class="keyword">long</span> id = nextNumber.incrementAndGet();</span><br></pre></td></tr></table></figure>

<p>但是，如果希望完成更复杂的更新， 就必须使用 compareAndSet 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong largest = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//In some thread</span></span><br><span class="line">largest.set(Math.max(largest.get(),observed))<span class="comment">//线程不安全</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  oldValue = largest.get();</span><br><span class="line">  newValue = Math.max(oldValue,observed);</span><br><span class="line">&#125;<span class="keyword">while</span>(!largest.compareAndSet(oldValue,newValue))<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure>

<p>如果另一个线程也在更新 largest 就可能阻止这个线程更新。compareAndSet 会返回false, 而不会设置新值。在这种情况下，循环会再次尝试，读取更新后的值，并尝试 修改。 最终， 它会成功地用新值替换原来的值。 compareAndSet 方法会映射到一个处理器操作， 比使用锁速度更快。</p>
<p>Java8 就不用再写这样的样板式代码，可以使用Lambda表达式替代，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">largest.updateAndGet(x -&gt; Math.max(x,observed));</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">largest.accumulateAndGet(observed,Math::max);<span class="comment">//accumulateAndGet 方法利用一个二元操作符来合并原子值和所提供的参数。</span></span><br></pre></td></tr></table></figure>

<p>如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重 试。Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。 LongAdder 包括多 个变量(加数)， 其总和为当前值。可以有多个线程更新不同的加数， 线程个数增加时会自动 提供新的加数。 通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况， 这种方法会很高效。 性能会有显著的提升。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>要避免共享变量， 使用ThreadLocal 辅助类为各个线程提供各自的实例。 例如SimpleDateFormat 类不是线程安全的。假设有一个静态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="comment">//线程不安全</span></span><br><span class="line">String dateStamp = dateFormat.format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>可以通过为每个线程构造一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = </span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line"><span class="comment">//在一个给定线程中首次调用 get 时， 会调用 initialValue 方法。在此之后， get 方法会返回属于当前线程的那个实例</span></span><br><span class="line">String dateStamp = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>在多个线程中生成随机数也存在类似的问题。java.util.Random 类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器， 这会很低效。</p>
<p>可以使用 ThreadLocal 辅助类为各个线程提供一个单独的生成器， 不过 Java SE 7 还另外提供了一个便利类。只需要做以下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalRandom.current() 调用会返回特定于当前线程的 Random 类实例。</span></span><br><span class="line"><span class="keyword">int</span> random = ThreadLocalRandom.current().nextInt(upperBound);</span><br></pre></td></tr></table></figure>

<p><code>java.lang.ThreadLocal&lt;T&gt; 1.2</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到这个线程的当前值。如果是首次调用 get, 会调用 initialize 来得到这个值</span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//应覆盖这个方法来提供一个初始值。默认情况下，这个方法返回 mill。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置新值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="comment">//删除对应线程的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//创建一个线程局部变量， 其初始值通过调用给定的 supplier 生成。</span></span><br><span class="line"><span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt;  <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h4><p>线程在调用 lock 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。应该更加谨慎地申请锁。tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则， 立即返回false, 而且线程可以立即离开去做其他事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myLock.tryLock())&#123;</span><br><span class="line">    <span class="comment">//now the thread owns the lock</span></span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;myLock.unlock();&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.locks.Lock 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试获得锁而没有发生阻塞；如果成功返回真。这个方法会抢夺可用的锁， 即使该锁有公平加锁策略， 即便其他线程已经等待很久也是如此。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//尝试获得锁，阻塞时间不会超过给定的值；如果成功返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//获得锁， 但是会不确定地发生阻塞。如果线程被中断， 抛出一个 InterruptedException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.locks.Condition 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进人该条件的等待集， 直到线程从等待集中移出或等待了指定的时间之后才解除阻塞。如果因为等待时间到了而返回就返回 false , 否 则 返 回 true。如果等待的线程被中断， await 方法将抛出一个 InterruptedException 异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//进人该条件的等待集， 直到线程从等待集移出才解除阻塞。如果线程被中断， 该方法不会抛出 InterruptedException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读/写锁"></a>读/写锁</h4><p>如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，ReentrantReadWriteLock非常适合这类场景。</p>
<p>使用读/写锁的必要步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 构造一个ReentrantReadWriteLock对象</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//2. 抽取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock readLock = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock writeLock = rwl.writeLock();</span><br><span class="line"><span class="comment">//3. 对所有的获取方法加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;readLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. 对所有的修改方法加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;writeLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.concurrent.locks.ReentrantReadWriteLock 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个可以被多个读操作共用的读锁， 但会排斥所有写操作。</span></span><br><span class="line"><span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//得到一个写锁， 排斥所有其他的读操作和写操作。</span></span><br><span class="line"><span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生 产者线程向队列插入元素， 消费者线程则取出它们。 使用队列， 可以安全地从一个线程向另 一个线程传递数据。 当试图向队列添加元素而队列已满， 或是想从队列移出元素而队列为空的时候， 阻塞队 列(blocking queue ) 导致线程阻塞。 在协调多个线程之间的合作时， 阻塞队列是一个有用的 工具。 </p>
<p>阻塞队列方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动作</th>
<th>特殊情况下的动作</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加一个元素</td>
<td>如果队列满，则抛出IllegalStateException异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列的头元素</td>
<td>如果队列空，则抛出NoSuchElementException异常</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回头元素</td>
<td>如果队列空，则抛出NoSuchElementException异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列满，则返回false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列的头元素</td>
<td>如果队列空，则返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移出并返回头元素</td>
<td>如果队列空，则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满，则阻塞</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回头元素</td>
<td>如果队列空，则阻塞</td>
</tr>
</tbody></table>
<p>大体分为3类：抛出异常、返回null、阻塞</p>
<p>java.util.concurrent 包提供了阻塞队列的几个变种：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>LinkedBlockingDeque</li>
</ul>
<p>JavaSE 7 增加了一个 TransferQueue 接口， 允许生产者线程等待， 直到消费者准备就绪 可以接收一个元素。 如果生产者调用<code>q.transfer(item)</code>，这个调用会阻塞，直到另一个线程将元素（item）删除。LinkedTransferQueue实现了该接口。</p>
<p><code>java.util.concurrent.ArrayBlockingQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个带有指定的容量和公平性设置的阻塞队列。 该队列用循环数组实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.LinkedBlockingQueue&lt;E&gt; 5.0</code></p>
<p><code>java.util.concurrent.LinkedBlockingDeque&lt;E&gt; 6.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个无上限的阻塞队列或双向队列， 用链表实现。实际上有容量上限，容量上限为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定容量构建一个有限的阻塞队列或双向队列， 用链表实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.DelayQueue&lt;E extends Delayed&gt;  5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个包含 Delayed 元素的无界的阻塞时间有限的阻塞队列。 只有那些延迟已经超 过时间的元素可以从队列中移出。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.Delayed 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到该对象的延迟， 用给定的时间单位进行度量。</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.PriorityBlockingQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span>;</span><br><span class="line"><span class="comment">//构造一个无边界阻塞优先队列， 用堆实现。</span></span><br><span class="line"><span class="comment">//参数: initialCapacity 优先队列的初始容量。 默认值是 11。</span></span><br><span class="line"><span class="comment">//		 comparator 用来对元素进行比较的比较器， 如果没有指定， 则元素必须 实现 Comparable 接口。</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.BlockingQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个元素，如果队列已满则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回头元素，如果队列为空则阻塞</span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//添加一个元素，如果队列已满则最多等待指定（timeout）时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回头元素，如果队列为空，则最多等待超时时间为timeout，单位为TimeUnit</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.BlockingDeque&lt;E&gt; extends BlockingQueue&lt;E&gt;,Deque&lt;E&gt; 6</code> 接口支持多继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向队列头尾添加元素，如果队列已满则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回队列头尾元素，如果队列为空则阻塞</span></span><br><span class="line"><span class="function">E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function">E <span class="title">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列头尾添加元素，如果队列已满则等待指定的超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回头尾元素，如果队列为空则等待指定的超时时间</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.TransferQueue&lt;E&gt; extends BlockingQueue&lt;E&gt;  7</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//传输元素给消费者，如果此时正好有一个消费者在接收它（take）或者正好在等待时间内（poll(long,TimeUnit)）则立刻传输，否则阻塞等待直到消费者接收，或者等待时间超时（timeout）则返回false</span></span><br></pre></td></tr></table></figure>

<h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><h4 id="高效的映射、集合和队列"><a href="#高效的映射、集合和队列" class="headerlink" title="高效的映射、集合和队列"></a>高效的映射、集合和队列</h4><p>java.util.concurrent 包提供了映射、 有序集和队列的高效实现: ConcurrentHashMap、 ConcurrentSkipListMap、ConcurrentSkipListSet 和 ConcurrentLinkedQueue。</p>
<p>这些集合使用复杂的算法， 通过允许并发地访问数据结构的不同部分来使竞争极小化。与大多数集合不同， size 方法不必在常量时间内操作。 确定这样的集合当前的大小通常 需要遍历。</p>
<p><strong>注意</strong>：散列映射将有相同散列码的所有条目放在同一个“ 桶” 中。有些应用使用的散列函 数不当， 以至于所有条目最后都放在很少的桶中， 这会严重降低性能。 即使是一般意义上 还算合理的散列函数，如String类的散列函数，也可能存在问题。例如，攻击者可能会制 造大量有相同散列值的字符串， 让程序速度减慢。 在 JavaSE 8 中， 并发散列映射将桶组织 为树， 而不是列表， 键类型实现了 Comparable, 从而可以保证性能为 O(log(8))。</p>
<p><code>java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个可以被多线程安全访问的无边界非阻塞的队列。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.ConcurrentSkipListSet&lt;E&gt; 6</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span>;</span><br><span class="line"><span class="comment">//构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现 Comparable 接口。</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;  5.0</code></p>
<p><code>java.util.concurrent.ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentNavigableMap&lt;K,V&gt; 6</code></p>
<h4 id="写数组拷贝"><a href="#写数组拷贝" class="headerlink" title="写数组拷贝"></a>写数组拷贝</h4><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//阻塞等待获取结果 如果运行该计算的线程被中断， 拋出IntermptedException</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">  <span class="comment">//阻塞等待获取结果，如果等待超时抛出TimeoutException，如果运行该计算的线程被中断， 拋出IntermptedException</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">  <span class="comment">// 如果任务已经完成、任务已经取消、任务因为其他原因不能取消则返回false；如果计算还没有开始， 它被取消且不再开始。 如果任务已经开始，则mayInterruptIfRunning参数确定在尝试停止任务时是否应中断执行此任务的线程。</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">  <span class="comment">//如果任务在完成之前被取消了则返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//如果任务完成则返回true，任务正常终止、异常返回或者取消都算是任务完成</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask 包装器是一种非常便利的机制， 可将 Callable 转换成 Future 和 Runnable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; compute = ...;</span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask(compute);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(task);<span class="comment">//it's a Runnable</span></span><br><span class="line">thread.start();</span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p> Executors 类有许多静态工厂方法用来构建线程池</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td>该池包含固定数量的线程; 空闲线程会一直被保留</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程; 空闲线程会被保留 60 秒</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池， 替代 java.util.Timer</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的 “ 池”， 该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建的单线程 “ 池”</td>
</tr>
</tbody></table>
<p>以上方法内部都是通过ThreadPoolExecutor创建线程池，该类实现ExecutorService接口，该接口提供了三个方法进行任务的执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>当用完一个线程池的时候， 调用 shutdown。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后， 线程池中的线程死亡。另一种方法是调用 shutdownNow。该池取消尚未开始的所有任务并试图中断正在运行的线程.</p>
<p>newScheduledThreadPool和newSingleThreadScheduledExecutor返回实现ScheduledExecutorService接口的线程池，该接口具有延迟执行和定期执行的能力。</p>
<p><code>java.util.concurrent.ScheduledExecutorService 5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在指定的延迟时间之后执行一次</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,<span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预定在初始的延迟结束后， 周期性地运行给定的任务， 周期长度是 period。第一次执行时间为initialDelay，第二次为initialDelay + period，第三次为initialDelay + 2*period，以此类推。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"><span class="comment">//预定在初始的延迟结束后周期性地运行给定的任务， 在一次调用完成和下一次调用开始之间有长度为 delay 的延迟。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><h3 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术 - 基础知识卷2</title>
    <url>/2020/04/21/java-core-Java-Fundamentals-Two/</url>
    <content><![CDATA[<h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><blockquote>
<p>官方文档地址：<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html</a></p>
</blockquote>
<a id="more"></a>

<h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_exception_architype.png" alt="Java异常层次结构"></p>
<p>所有异常类都继承Throwable类，两大子类分别是Error和Exception。Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。Exception又分为RuntimeException和checked异常，划分两个分支的规则是：由程序错误导致的异常属于 RuntimeException，运行时异常属于unchecked异常; 而程序本身没有问题， 但程序中的一些代码会主动抛出checked异常，如果不处理这些异常则编译不通过。</p>
<p><strong>unchecked异常</strong>：是指编译时期不检测的异常</p>
<p><strong>checked异常</strong>：是指编译时期进行检测的异常，这种异常必须进行处理（try-catch）或者用throws关键字抛出异常</p>
<p>Java 语 言 规 范 将 派 生 于 Error 类 或 RuntimeException 类的所有异常称为非受查( unchecked ) 异常，所有其他的异常称为受查（ checked) 异常。</p>
<p>RuntimeException异常包括：</p>
<ul>
<li>错误的类型转换</li>
<li>数组下标越界</li>
<li>空指针异常</li>
</ul>
<h4 id="JVM异常处理过程"><a href="#JVM异常处理过程" class="headerlink" title="JVM异常处理过程"></a>JVM异常处理过程</h4><h5 id="默认异常处理"><a href="#默认异常处理" class="headerlink" title="默认异常处理"></a>默认异常处理</h5><p>当方法内出现异常时，该方法会创建一个异常对象，并将其传递给JVM。异常对象包含名字、异常描述和发生异常时当前程序的状态。创建异常对象并把它移交给JVM的过程叫做 <strong>抛出异常</strong> 。这里有一个被调用方法的方法列表，用来查找异常发生的方法。这个方法列表就是  <strong>调用堆栈（Call Stack）</strong> 。执行过程如下：</p>
<ul>
<li>JVM去调用堆栈里查找相应的方法，该方法含有处理当前发生的异常的代码块。这个代码块就是 <strong>异常处理器（Exception Handler）</strong></li>
<li>JVM从异常发生的方法开始在调用堆栈里倒序搜索</li>
<li>如果找到了合适的异常处理器，就把异常传给他。合适的处理器意味着它能处理的异常类型正好匹配抛出异常的类型</li>
<li>如果JVM检索了调用堆栈里的所有方法，都没有找到合适的处理器，JVM就会把异常对象传递给<strong>默认异常处理器（default exception handler）</strong> ，该处理器属于JVM自身的一部分。该处理器打印异常信息并且异常终止程序。打印的异常信息格式如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"xxx"</span> Name of Exception : Description</span><br><span class="line">... ...... ..  <span class="comment">// Call Stack</span></span><br></pre></td></tr></table></figure>

<p>JVM在调用堆栈上检索包含合适的异常处理器的方法流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java program to demonstrate exception is thrown </span></span><br><span class="line"><span class="comment">// how the runTime system searches th call stack </span></span><br><span class="line"><span class="comment">// to find appropriate exception handler. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThrown</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// It throws the Exception(ArithmeticException). </span></span><br><span class="line">	<span class="comment">// Appropriate Exception handler is not found within this method. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideByZero</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// this statement will cause ArithmeticException(/ by zero) </span></span><br><span class="line">		<span class="keyword">int</span> i = a/b; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> i; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The runTime System searches the appropriate Exception handler </span></span><br><span class="line">	<span class="comment">// in this method also but couldn't have found. So looking forward </span></span><br><span class="line">	<span class="comment">// on the call stack. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeDivision</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> res =<span class="number">0</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123; </span><br><span class="line">		res = divideByZero(a,b); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// doesn't matches with ArithmeticException </span></span><br><span class="line">		<span class="keyword">catch</span>(NumberFormatException ex) </span><br><span class="line">		&#123; </span><br><span class="line">		System.out.println(<span class="string">"NumberFormatException is occured"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> res; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// In this method found appropriate Exception handler. </span></span><br><span class="line">	<span class="comment">// i.e. matching catch block. </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">int</span> i = computeDivision(a,b); </span><br><span class="line">		</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// matching ArithmeticException </span></span><br><span class="line">		<span class="keyword">catch</span>(ArithmeticException ex) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// getMessage will print description of exception(here / by zero) </span></span><br><span class="line">			System.out.println(ex.getMessage()); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h5><p>自定义异常处理可以通过5个关键字：try、catch、throw、throws和finally。</p>
<p>try对能够引发异常的代码进行包裹；catch对抛出的异常进行捕获处理；手动抛出异常使用throw关键字；通过throws语句指定从方法抛出的异常；抛出异常后还有一些必须要执行的代码（比如释放数据库连接）则放在finally代码块中。</p>
<h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>编写方法时不必将所有可能抛出的异常都进行声明，遇到下面 4 种情况时应该抛出异常：</p>
<ol>
<li>调用一个抛出受査异常的方法， 例如， FilelnputStream 构造器</li>
<li>程序运行过程中发现错误， 并且利用 throw语句抛出一个受查异常</li>
<li>程序出现错误， 例如，a[-l]=0 会抛出一个 ArraylndexOutOffloundsException 这样的非受查异常</li>
<li>Java 虚拟机和运行时库出现的内部错误</li>
</ol>
<p>如果没有处理器捕获这个异常，当前执行的线程就会结束。</p>
<p>一个方法必须声明所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生（ RuntimeException)。如果方法没有声明所有可能发生的受查异常， 编译器就会发出一个错误消息。</p>
<h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">EOFException e = <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<p>注意：一旦方法抛出了异常， 这个方法就不可能返回到调用者。也就是说， 不必为返回的默认值或错误代码担忧</p>
<h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>自定义异常类：定义一个派生于Exception 的类，或者派生于 Exception 子类的类。定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器（超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="keyword">extends</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Throwable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个Throwable对象</span></span><br><span class="line">Throwable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个带异常详细描述信息的Throwable对象</span></span><br><span class="line">Throwable(String message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得Throwable对象的详细描述信息</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>捕获异常的规则：</p>
<ol>
<li>应该捕获那些知道如何处理的异常， 而将那些不知道怎样处理的异常继续进行传递。</li>
<li>所有异常都进行捕获处理有时也是不合理的，有时需要将异常传递给调用者，让调用者知道发生了什么异常并且进行处理</li>
</ol>
<h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><p>catch子句中也可以抛出异常，这样可以改变异常的类型。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//access the database</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"database error:"</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种更好的处理方式，可以让调用者知道原始异常产生的原因，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//access the database</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当捕获到异常时，可以使用该语句获取到原始异常</span></span><br><span class="line">Throwable e = se.getCause();</span><br></pre></td></tr></table></figure>

<p>如果在一个方法中发生了一个受查异常， 而不允许抛出它， 那么包装技术就十分有用。我们可以捕获这个受查异常，并将它包装成一个运行时异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//access the database</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    logger.log(level,message,e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h4><p>通常用于释放资源，如关闭数据库连接等等，不管是否有异常被捕获，finally 子句中的代码都被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    show error message;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，有下列 3 种情况会执行 finally 子句:</p>
<ol>
<li>代码没有抛出异常。在这种情况下， 程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码t 随后， 继续执行 try 语句块之后的第一条语句。也就是说，执行标注的 1、 2、 5、 6 处</li>
<li>抛出一个在 catch 子句中捕获的异常。<ol>
<li>如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。</li>
<li>如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注1、 3、 5 处的语句。</li>
</ol>
</li>
<li>代码抛出了一个异常， 但这个异常不是由 catch 子句捕获的。在这种情况下，程序将<br>执行 try 语句块中的所有语句，直到有异常被抛出为止。此时， 将跳过 try 语句块中的剩余代码， 然后执行 finally 子句中的语句， 并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。</li>
</ol>
<p>try 语句可以只有 finally 子句，而没有 catch 子句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种做法无论try块中是否有异常，finally都会执行。当遇到异常时会将异常抛出给调用者</span></span><br><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//code that might throw exceptions</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 当finally子句中有return语句时，返回值将会覆盖原始的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值 4。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的try语句</h4><p>假设资源属于一个实现了 AutoCloseable 接口的类，AutoCloseable 接口有一个方法：<code>void close() throws Exception</code>，Java SE 7之后可以用带资源的 try 语句（try-with-resources) 自动调用close方法来关闭资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//try块退出时，会自动调用 res.doseO。</span></span><br><span class="line"><span class="keyword">try</span>(Resource res=...)&#123;</span><br><span class="line">    <span class="comment">//work with res</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个块正常退出时， 或者存在一个异常时， 都会调用 in.close() 方法。类似于finally子句的效果</span></span><br><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"/usr/share/dict/words"</span>),<span class="string">"UTF-8"</span>))&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">        System.out.println(in.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带资源的 try 语句会将原来的异常重新抛出，而 close方法抛出的异常会”被抑制”， 这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法，它会得到从 close 方法抛出并被抑制的异常列表</p>
<p>带资源的 try 语句自身也可以有 catch 子句和一个 finally 子句。这些子句会在资源关闭后执行。但通常为了避免繁琐不会再加这么多子句。</p>
<h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹（ stack trace ) 是一个方法调用过程的列表， 它包含了程序执行过程中方法调用的特定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throw t = <span class="keyword">new</span> Throwable();</span><br><span class="line"><span class="comment">//printStackTrace 方法访问堆栈轨迹的文本描述信息</span></span><br><span class="line">t.printStackTrace();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更灵活的方法是使用 getStackTrace 方法</span></span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="comment">//StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法， 还含有能够获得类名和方法名的方法</span></span><br><span class="line"><span class="keyword">for</span>(StackTraceElement frame :frames)&#123;</span><br><span class="line">    <span class="comment">//analyze frame</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有线程的堆栈轨迹</span></span><br><span class="line">Map&lt;Thread,StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line"><span class="keyword">for</span>(Thread t : map.keySet())&#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    <span class="comment">//analyze frames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Throwable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用给定的异常原因构造一个Throwable对象</span></span><br><span class="line">Throwable(Throwable cause);</span><br><span class="line">Throwable(String message,Throwable cause);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置异常原因，如果已经设置过，则抛出一个异常</span></span><br><span class="line"><span class="function">Throwable <span class="title">initCause</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取异常原因，如果没设置则返回null</span></span><br><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得构造这个对象时调用堆栈的跟踪，获取当前执行点的堆栈轨迹</span></span><br><span class="line">StackTraceElement[] getStackTrace();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为这个异常增加一个“ 抑制” 异常。这出现在带资源的 try语句中， 其中 t 是 close 方法抛出的一个异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSuppressed</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line"><span class="comment">//得到这个异常的所有“ 抑制” 异常。一般来说，这些是带资源的 try语句中 close 方法拋出的异常。</span></span><br><span class="line">Throwable[] getSuppressed();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Exception</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用给定的“ 原因” 构造一个异常对象</span></span><br><span class="line">Exception(Throwable cause);</span><br><span class="line">Exception(String messge,Throwable cause);</span><br></pre></td></tr></table></figure>

<h4 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h4><ol>
<li>异常处理不能代替简单的测试，只在异常情况下使用异常机制</li>
<li>不要过分地细化异常</li>
<li>利用异常层次结构</li>
<li>不要压制异常</li>
<li>在检测错误时，“ 苛刻 ” 要比放任更好（早抛出）</li>
<li>不要羞于传递异常（晚捕获）</li>
</ol>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。</p>
<p>Java 语言引人了关键字 assert。这个关键字有两种形式：</p>
<ul>
<li>assert 条件；</li>
<li>assert 条件：表达式；</li>
</ul>
<p>这两种形式都会对条件进行检测， 如果结果为 false, 则抛出一个 AssertionError 异常。在第二种形式中，表达式将被传入 AssertionError 的构造器， 并转换成一个消息字符串。</p>
<h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>在默认情况下， 断言被禁用。可以在运行程序时用 -enableassertions 或 -ea 选项启用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -enableassertions MyApp</span><br></pre></td></tr></table></figure>

<p>需要注意的是， 在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器( class loader) 的功能。当断言被禁用时， 类加载器将跳过断言代码， 因此，不会降低程序运行的速度。</p>
<p>可以用选项 -disableassertions 或 -da 禁用某个特定类和包的断言：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -disableassertions MyApp</span><br></pre></td></tr></table></figure>

<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h3><p>类型参数（ type parameters)的魅力在于：使得程序具有更好的可读性和安全性。</p>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p>一个泛型类（ generic class) 就是具有一个或多个类型变量的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T seconde;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;first = <span class="keyword">null</span>;second=<span class="keyword">null</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;<span class="keyword">this</span>.first = first;<span class="keyword">this</span>.second = second&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pair 类引人了一个类型变量 T，用尖括号 ( &lt; &gt;) 括起来，并放在类名的后面。泛型类可以有多个类型变量。像这样</p>
<p><code>public class Pair&lt;T,U&gt;{......}</code></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</span><br><span class="line">    <span class="comment">//类型变量放在修饰符（这里是 public static) 的后面，返回类型的前面。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length /<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String middle  = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></table></figure>

<p>实际使用时可以省略<code>&lt;String&gt;</code> ,编译器会通过参数类型进行类型推导出泛型类型T是String类型。</p>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T smallest = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决这个问题的方案是将 T 限制为实现了 Comparable 接口（只含一个方法 compareTo 的标准接口）的类。可以通过对类型变量 T 设置限定（bound) 实现这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>T extends  BoundingType</code>表示 T 应该是绑定类型的子类型 （subtype)。T 和绑定类型可以是类， 也可以是接口。一个类型变量或通配符可以有多个限定， 例如：</p>
<p><code>T extends Comparable &amp; Serializable</code>限定类型用“ &amp;” 分隔，而逗号用来分隔类型变量。在 Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个</p>
<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机没有泛型类型对象—— 所有对象都属于普通类。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型 （ raw type )。原始类型的名字就是删去类型参数后的泛型类型名。擦除（ erased) 类型变量, 并替换为限定类型（无限定的变量用 Object)。</p>
<p>Pair<T>的原始类型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用 Object 替换。例如，类 Pair<T> 中的类型变量没有显式的限定， 因此， 原始类型用 Object 替换 T。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>〉<span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span> <span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; lower = second; upper = first; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型Interval如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable first,Comparable second)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调换了Comparable &amp; Serializable的顺序 ，原始类型用 Serializable 替换 T, 而编译器在必要时要向Comparable 插入强制类型转换。为了提高效率，应该将标签（tagging) 接口（即没有方法的接口）放在边界列表的末尾。</p>
<h4 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h4><p>当程序调用泛型方法时，如果擦除返回类型， 编译器插入强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure>

<p>擦除 getFirst 的返回类型后将返回 Object 类型。编译器自动插人 Employee 的强制类型转换。</p>
<p>也就是说，编译器把这个方法调用翻译为两条虚拟机指令：</p>
<ul>
<li>对原始方法Pair.getFirst的调用</li>
<li>将返回的Object类型强制转换成Employee类型</li>
</ul>
<h4 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h4><p>通过插入桥方法（bridge method）来保持多态性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;setSecond((Date)second);&#125;</span><br></pre></td></tr></table></figure>

<p>有关Java泛型转换的要点：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法（类型擦除）</li>
<li>所有的类型参数都用他们的限定类型替换</li>
<li>桥方法被合成来保持多态</li>
<li>为保持类型安全性，必要时插入强制类型转换</li>
</ul>
<h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>使用 Java 泛型时需要考虑的一些限制。大多数限制都是由类型擦除引起的</p>
<h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>不能用类型参数代替基本类型。因此， 没有 Pair<double>, 只 有 Pair<Double>。 当然,其原因是类型擦除。擦除之后， Pair 类含有 Object 类型的域， 而 Object 不能存储 double 值。</p>
<h4 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h4><p>所有的类型查询只产生原始类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;); <span class="comment">//Error</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;);<span class="comment">//Error</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;)a;<span class="comment">//Warning -- can only test that a is a Pair</span></span><br></pre></td></tr></table></figure>

<p>试图查询一个对象是否属于某个泛型类型时，倘若使用 instanceof 会得到一个编译器错误， 如果使用强制类型转换会得到一个警告。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = . .</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ..;</span><br><span class="line"><span class="comment">//两次调用 getClass 都将返回 Pair.class。</span></span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == employeePair.getClas()) <span class="comment">// they are equal</span></span><br></pre></td></tr></table></figure>

<h4 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];<span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p>擦除之后， table 的类型是 Pair[]， 可以把它转换为 Object[]:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objarray = table;</span><br><span class="line"><span class="comment">//数组会记住它的元素类型， 如果试图存储其他类型的元素， 就会抛出一个 ArrayStoreException 异常:</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="comment">//对于泛型类型， 擦除会使这种机制无效。能够通过数组存储检査， 不过仍会导致一个类型错误。</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a>Varargs警告</h4><h4 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h4><p>不能使用像 new T(…)， new T[…] 或 T.class 这样的表达式中的类型变量。例如， 下面的Pair<T> 构造器就是非法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> T();<span class="comment">//Error</span></span><br><span class="line">    second = <span class="keyword">new</span> T();<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除将 T 改变成 Object, 而且， 本意肯定不希望调用 new Object()。 在 Java SE 8 之后，最好的解决办法是让调用者提供一个构造器表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//makePair 方法接收一个 Supplier&lt;T&gt;，这是一个函数式接口，表示一个无参数而且返回类型为 T 的函数：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.ge())；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态域或方法中引用类型变量。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> T singlelnstance; <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T getSinglelnstanceO <span class="comment">// Error</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) construct <span class="keyword">new</span> instance of T</span><br><span class="line">    <span class="keyword">return</span> singlelnstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下定义就不能正常编译：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;<span class="comment">/*....*/</span>&#125;<span class="comment">//Error can't extend Throwable</span></span><br></pre></td></tr></table></figure>

<p>catch 子句中不能使用类型变量。以下方法将不能编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (T e) <span class="comment">// Error can 't catch type variable</span></span><br><span class="line">    &#123;</span><br><span class="line">    Logger,global.info(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在异常规范中使用类型变量是允许的。以下方法是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e) </span><br><span class="line">    &#123;</span><br><span class="line">        t.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h4><p>通过使用泛型类、 擦除和 @SuppressWamings 注解， 就能消除 Java 类型系统的部分基本<br>限制。</p>
<h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><p>通配符类型中， 允许类型参数变化。 例如， 通配符类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h4><p>通配符限定与类型变量限定十分类似，但是，还有一个附加的能力，即可以指定一个超类型限定 （supertypebound), <code>? super Manager</code></p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>例如：Pair&lt;?&gt;</p>
<h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>Class 类是泛型的。例如， String.class 实际上是一个<code>Class&lt;String&gt;</code> 类的对象（事实上，是唯一的对象。)</p>
<h4 id="使用Class参数进行类型匹配"><a href="#使用Class参数进行类型匹配" class="headerlink" title="使用Class参数进行类型匹配"></a>使用Class<T>参数进行类型匹配</h4><h4 id="虚拟机中的泛型类型信息"><a href="#虚拟机中的泛型类型信息" class="headerlink" title="虚拟机中的泛型类型信息"></a>虚拟机中的泛型类型信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该泛型方法类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果需要构造原始泛型方法，需要使用反射API来确定：</p>
<ul>
<li>这个泛型方法有一个叫做 T 的类型参数</li>
<li>这个类型参数有一个子类型限定， 其自身又是一个泛型类型</li>
<li>这个限定类型有一个通配符参数</li>
<li>这个通配符参数有一个超类型限定</li>
<li>这个泛型方法有一个泛型数组参数。</li>
</ul>
<p>为了表达泛型类型声明，使用java.lang.reflect 包中提供的接口 Type。这个接口包含下列子类型：</p>
<ul>
<li>Class类，描述具体类型</li>
<li>TypeVariable接口，描述类型变量（如T extends Comparable&lt;? super T&gt;）</li>
<li>WildcardType 接口， 描述通配符 （如？super T)</li>
<li>ParameterizedType 接口， 描述泛型类或接口类型（如 Comparable&lt;? super T&gt;)</li>
<li>GenericArrayType 接口，描述泛型数组（如 T[ ])</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Comsumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java SE 8中，甚至不用写循环。可以调用 forEachRemaining 方法并提供一个 lambda表达式（它会处理一个元素）。 将对迭代器的每一个元素调用这个 lambda 表达式，直到再没有元素为止。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element );</span><br></pre></td></tr></table></figure>

<p>应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p>Iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。如果调用 remove 之前没有调用 next 将是不合法的。如果这样做， 将会抛出一个 IllegalStateException 异常。</p>
<p>下面是如何删除字符串集合中第一个元素的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">it.next();<span class="comment">//skip over the first element</span></span><br><span class="line">it.remove();<span class="comment">//now remove it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连续删除两个元素</span></span><br><span class="line">it.remove();</span><br><span class="line">it.remove();<span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型使用方法"><a href="#泛型使用方法" class="headerlink" title="泛型使用方法"></a>泛型使用方法</h4><p><code>java.util.Collection&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个用于访问集合中每个元素的迭代器</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回当前存储在集合中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果集合中没有元素， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果集合中包含了一个与 obj 相等的对象， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">//如果这个集合包含 other 集合中的所有元素， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line"><span class="comment">//将 other 集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extend E&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除等于 obj 的对象。如果有匹配的对象被删除， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合删除 filter 返回 true 的所有元素。如果由于这个调用改变了集合， 则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除所有的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//返回这个集合的对象数组</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//返回这个集合的对象数组。如果 arrayToFill 足够大， 就将集合中的元素填入这个数组中。剩余空间填补 null ; 否则， 分配一个新数组， 其成员类型与 arrayToFill 的成员类型相同， 其长度等于集合的大小， 并填充集合元素</span></span><br><span class="line">&lt;T&gt; T[] toArray(T[] arrayToFill);</span><br></pre></td></tr></table></figure>

<p><code>java.util.Iterator&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果存在可访问的元素， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回将要访问的下一个对象。如果已经到达了集合的尾部， 将拋出一个 NoSuchElementException</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化， 这个方法将抛出一个 IllegalStateException</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h4><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_interface.png" alt="集合框架接口"></p>
<p>集合有两个基本接口：Collection 和 Map。</p>
<p>Listlterator 接口是 Iterator 的一个子接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//返回前一个对象。如果已经到达了列表的头部， 就抛出一个NoSuchElementException 异常</span></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//当反向迭代列表时， 还有可供访问的元素， 返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回下一次调用 next 方法时返回元素的整数索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回下一次调用 previous 方法时返回元素的整数索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。如果在 next 或 previous 上次调用之后列表结构被修改了， 将拋出一个 IllegalStateException 异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="comment">//在迭代器当前位置前面增加一个元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_implements.png" alt="集合实现类"></p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>在 Java 程序设计语言中，所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用。</p>
<p>如果链表有 n 个元素，有 n+1 个位置可以添加新元素。这些位置与迭代器的 n+1 个可能的位置相对应。例如， 如果链表包含 3 个元素，A、 B、 C，就有 4 个位置（标有丨）可以插入新元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|ABC</span><br><span class="line">A|BC</span><br><span class="line">AB|C</span><br><span class="line">ABC|</span><br></pre></td></tr></table></figure>

<p>检测并发修改的方法：每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致， 抛出一个 ConcurrentModificationException 异常。</p>
<p>注意：对于并发修改列表的检测肴一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、 删除元素。set 方法不被视为结构性修改。</p>
<h4 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h4><p>实现了<code>RandomAccess</code>接口可以对集合进行随机访问。</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列(Hashing)就是将对象转化成整数值的过程，这个整数值也叫作散列码（hashcode）。默认情况下，该整数值主要来自于堆中对象的内存地址（并不是强制的，可以自己重写该方法），从而为所有不同的对象生成不同的散列码（我理解是在内存地址之上加一层算法，并不能完全保证不同的对象产生不同的散列码，也就是可能会产生相同的散列码，也就是散列冲突）。</p>
<p>散列函数必须遵循的规则：两个相等（通过equals比较相等）的对象必须产生相同的散列码</p>
<p>Java中的所有对象都继承Object类中定义的hashCode()函数的默认实现。</p>
<p><code>java.lang.Object</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回这个对象的散列码。散列码可以是任何整数， 包括正数或负数。equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCode() 必须等于 y.hashCod()。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树集(TreeSet)是一个有序集合( sorted collection) 。 可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SortedSet&lt;String&gt; sorter = <span class="keyword">new</span> TreeSet&lt;&gt;();<span class="comment">//TreeSet implements SortedSet</span></span><br><span class="line">sorter.add(<span class="string">"Bob"</span>);</span><br><span class="line">sorter.add(<span class="string">"Amy"</span>);</span><br><span class="line">sorter.add(<span class="string">"Carl"</span>);</span><br><span class="line"><span class="keyword">for</span>(String s: sorter) System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：要使用树集， 必须能够比较元素。这些元素必须实现 Comparable 接口。或者构造集时必须提供一个 Comparator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeSetTest 代码</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.TreeSet&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet();</span><br><span class="line">TreeSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个树集， 并增加一个集合或有序集中的所有元素（对于后一种情况， 要使用同样的顺序。)</span></span><br><span class="line">TreeSet(Collection&lt;? extends E&gt; elements);</span><br><span class="line">TreeSet(SortedSet&lt;E&gt; s);</span><br></pre></td></tr></table></figure>

<p><code>java.util.SortedSet&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回用于对元素进行排序的比较器。</span></span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> E&gt; comparator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回有序集中的最小元素或最大元素。</span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.NavigableSet&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E value)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回大于等于 vaiue 的最小元素或小于等于 value 的最大元素， 如果没有这样的元素则返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E value)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除并返回这个集中的最大元素或最小元素， 这个集为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个按照递减顺序遍历集中元素的迭代器</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>队列：在尾部添加元素，在头部删除元素（FIFO）</p>
<p>双端队列：头部尾部都支持添加和删除元素</p>
<p>在 Java SE 6中引人了 Deque 接口，并由 ArrayDeque 和LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</p>
<p><code>java.util.Queue&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果队列没有满，将给定的元素添加到这个队列的尾部并返回 true。如果队列满了，第一个方法将拋出一个IllegalStateException, 而第二个方法返回 false。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出NoSuchElementException, 而第二个方法返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列不空，返回这个队列头部的元素， 但不删除。如果队列空，第一个方法将拋出一个 NoSuchElementException, 而第二个方法返回 null</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.Deque&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将给定的对象添加到双端队列的头部或尾部。如果队列满了，前面两个方法将拋出一个 IllegalStateException，而后面两个方法返回 false。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列不空，删除并返回队列头部或尾部的元素。如果队列为空，前面两个方法将拋出一个 NoSuchElementException, 而后面两个方法返回 null</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列非空，返回队列头部或尾部的元素， 但不删除。如果队列空，前面两个方法将拋出一个 NoSuchElementException, 而后面两个方法返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.ArrayDeque&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用初始容量 16 或给定的初始容量构造一个无限双端队列</span></span><br><span class="line">ArrayDeque();</span><br><span class="line">ArrayDeque(<span class="keyword">int</span> initialCapacity);</span><br></pre></td></tr></table></figure>

<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆（heap)。堆是一个可以自我调整的二叉树，对树执行添加（ add) 和删除（remove) 操作， 可以让最小的元素移动到根，而不必花费时间对元素进行排序。同TreeSet一样，优先级队列中的元素也是要实现Comparable接口，或者在构造器中提供Comparator对象</p>
<p>使用优先级队列的典型示例是任务调度，每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除（由于习惯上将 1 设为“ 最高” 优先级，所以会将最小的元素删除)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;LocalDate&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1906</span>,<span class="number">12</span>,<span class="number">9</span>));</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1815</span>,<span class="number">12</span>,<span class="number">10</span>));</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1903</span>,<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1910</span>,<span class="number">6</span>,<span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Iterating over elements..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (LocalDate date:pq)&#123;</span><br><span class="line">            System.out.println(date);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Removing elements..."</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            System.out.println(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.util.PriorityQueue&lt;E&gt;  5.0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个用于存放 Comparable 对象的优先级队列</span></span><br><span class="line">PriorityQueue();</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity);</span><br><span class="line"><span class="comment">//构造一个优先级队列， 并用指定的比较器对元素进行排序</span></span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity,Comparator&lt;? <span class="keyword">super</span> E&gt; c);</span><br></pre></td></tr></table></figure>

<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h4><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><h4 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h4><p>设计 WeakHashMap 类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再使用了， 将会出现什么情况呢？ 假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键 / 值对无法从映射中删除。</p>
<p>WeakHashMap 使用弱引用 （ weak references) 保存键。</p>
<h4 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h4><p>LinkedHashSet 和 LinkedHashMap类用来记住插入元素项的顺序。这样就可以避免在散歹表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。</p>
<p>访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。LinkedHashMap 对最近最少使用原则的简单实现方案就是重写<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现缓存100个元素</span></span><br><span class="line">Map&lt;K,V&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">128</span>,<span class="number">0.75F</span>,<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h4><p>EmimSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1</p>
<p>EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY,SUNDAY&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.FRIDAY,Weekday.SUNDAY);</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>在 EnumSet 的 API 文档中， 将会看到 E extends Enum<E> 这样奇怪的类型参数。简单地说， 它的意思是 “ E 是一个枚举类型。” 所有的枚举类型都扩展于泛型 Enum 类。例如，Weekday 4广展 Enum&lt;Weekday〉。</p>
<p>EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EnumMap&lt;Weekday, Employee&gt;  personlnCharge = <span class="keyword">new</span> EnumMap&lt;&gt;(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h4><p>类 IdentityHashMap 有特殊的作用。在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。在实现对象遍历算<br>法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</p>
<h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用视图( views) 可以获得其他的实现了 Collection 接口和 Map 接口的对象。映射类的 keySet 方法就是一个这样的示例。keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><p>Arrays 类的静态方法 asList 将返回一个包装了普通 Java 数组的 List 包装器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line"><span class="comment">//返回的对象不是 ArrayList。它是一个视图对象， 带有访问底层数组的 get 和 set 方法。</span></span><br><span class="line"><span class="comment">//改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法）都会抛出一个Unsupported OperationException 异常。</span></span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br><span class="line"></span><br><span class="line"><span class="comment">//asList还可以接收可变参数</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span>,<span class="string">"Bob"</span>,<span class="string">"Carl"</span>);</span><br></pre></td></tr></table></figure>

<p>下 面 的 调 用 将 创 建 一 个 包 含 1 0 0 个 字 符 串 的 List, 每 个 串 都 被 设 置 为“ DEFAULT”:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储代价很小</span></span><br><span class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>,<span class="string">"default"</span>);</span><br></pre></td></tr></table></figure>

<p>Collections类包含很多实用方法，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个视图对象，该对象实现了一个不可修改的单元素集合，并且不需要新建数据结构，节省开销。singletonList和singletonMap方法类似</span></span><br><span class="line">Collections.singleton(anObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于集合框架中的每一个接口，还有一些方法可以生成空集、 列表、 映射，等等。</span></span><br><span class="line">Set&lt;String&gt; deepThoughts = Collections.emptySet();</span><br></pre></td></tr></table></figure>

<h4 id="子范围视图"><a href="#子范围视图" class="headerlink" title="子范围视图"></a>子范围视图</h4><p>比如subList方法就可以获得列表的一个子范围视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List group2 = staff.subList(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//前闭后开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况。</span></span><br><span class="line">group2.clear();<span class="comment">//group2为空，staff中也会清除</span></span><br></pre></td></tr></table></figure>

<p>对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些方法将返回大于等于 from 且小于 to 的所有元素子集。</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,E to)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回映射视图， 该映射包含键落在指定范围内的所有元素</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K from,K to)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Java SE 6 引人的 NavigableSet 接口赋予子范围操作更多的控制能力。可以指定是否包括边界：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive,E to, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p>可以使用下面 8 种方法获得不可修改视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableCollection;</span><br><span class="line">Collections.unmodifiableList;</span><br><span class="line">Collections.unmodifiableSet;</span><br><span class="line">Collections.unmodifiableSortedSet;</span><br><span class="line">Collections.unmodifiableNavigableSet;</span><br><span class="line">Collections.unmodifiableMap;</span><br><span class="line">Collections.unmodifiableSortedMap;</span><br><span class="line">Collections.unmodifiableNavigableMap;</span><br></pre></td></tr></table></figure>

<p>由于视图只是包装了接口而不是实际的集合对象， 所以只能访问接口中定义的方法。例如， LinkedList 类有一些非常方便的方法，addFirst 和 addLast，它们都不是 List 接口的方法，不能通过不可修改视图进行访问。</p>
<h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。</p>
<p><code>Collections.synchronized*</code>方法，比如<code>Collections.synchronizedMap</code></p>
<h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p>“ 受査” 视图用来对泛型类型发生问题时提供调试支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; safeStrings = Collections.checkedList(strings,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>视图的 add 方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//fill collection</span></span><br><span class="line">Collections.sort(staff);<span class="comment">//元素需要实现Comparable接口</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));<span class="comment">//自定义比较器</span></span><br><span class="line">staff.sort(Comparator.reverseOrder());<span class="comment">//降序</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee.getSalary).reversed());<span class="comment">//按照工资降序排列</span></span><br></pre></td></tr></table></figure>

<p>Collections 类有一个算法 shuffle, 其功能与排序刚好相反， 即随机地混排列表中元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);<span class="comment">//混排</span></span><br></pre></td></tr></table></figure>

<p>如果提供的列表没有实现 RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<p><code>java.util.Collections</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用稳定的排序算法， 对列表中的元素进行排序。这个算法的时间复杂度是 O(n logn), 其中 n 为列表的长度。</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;  <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; elements)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机地打乱列表中的元素。这个算法的时间复杂度是 0(na(n)), n 是列表的长度，a (n)是访问元素的平均时间。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; elements)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; elements,Random r)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.List&lt;E&gt;</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用给定比较器对列表排序</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>; <span class="comment">//Java 8</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.Comparator&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成一个比较器， 将逆置 Comparable 接口提供的顺序</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//生成一个比较器， 将逆置这个比较器提供的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>Collections 类的 binarySearch方法实现了这个二分查找算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果 binarySearch 方法返回的数值大于等于 0, 则表示匹配对象的索引。如果返回负值， 则表示没有匹配的兀素。但是，可以利用返回值计算应该将 element 插入到集合的哪个位置， 以保持集合的有序性。插人的位置是insertPoint = - i - 1;</span></span><br><span class="line">i = Collections.binarySearch(c,element);</span><br><span class="line">i = Collections.binarySearch(c,element,comparator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    c.add(-i-<span class="number">1</span>,element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有采用随机访问，二分査找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分査找就完全失去了优势。因此，如果为 binarySearch 算法提供一个链表， 它将自动地变为线性查找。</p>
<h4 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h4><h4 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h4><p>数组转集合Arrays.asList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = ...;</span><br><span class="line">HashSet&lt;String&gt; staff = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(values));</span><br></pre></td></tr></table></figure>

<p>集合转数组：不能直接使用toArray方法，因为该方法返回Object[]数组，强制类型转换会报错，所以需要使用toArray方法的一个变体形式，提供一个所需类型而且长度为0的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = (String[]) staff.toArray();<span class="comment">//Error</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//OK</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">staff.toArray(<span class="keyword">new</span> String[staff.size()]);</span><br></pre></td></tr></table></figure>

<h4 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h4><p>HashTable、Enumeration、Properties、Stack、BitSet</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法第四版</title>
    <url>/2020/04/20/algorithm-algorithm-fourth-Algorithm/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据结构与算法简介"><a href="#数据结构与算法简介" class="headerlink" title="数据结构与算法简介"></a>数据结构与算法简介</h3><p>数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。</p>
<p>数据结构与算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p>
<a id="more"></a>

<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p><strong>定义</strong>：一种存储键值对的数据结构，支持插入和查找操作。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>不允许重复的键：每个键对应一个值，插入已存在的键时更新其值</li>
<li>不允许空键和空值：插入空键会产生运行时异常；空值可以用来判断键不存在，查找某个键如果返回空则表示该键不存在；插入空值可以对该键进行延时删除</li>
<li>延时删除和即时删除：延时删除是将键对应的值置为空，然后在将来的某个时候删除所有值为空的键；即时删除表示立刻从表中删除指定的键。当插入空值操作put(key,null)时即时删除<code>if(value == null) {delete(key); return;}</code>所以表中不存在空值的键</li>
</ul>
<h4 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h4><p><strong>特征</strong>：</p>
<ul>
<li>最大键和最小键</li>
<li>向下取整和向上取整</li>
<li>排名和选择：排名（rank），找出小于指定键的键的数量；选择（select），找出排名为k的键；对于0到size() - 1的所有i都满足 i == rank(select(i))，且所有的键都满足 key == select(rank(key))。</li>
<li>范围查找</li>
</ul>
<h4 id="无序链表中的顺序查找"><a href="#无序链表中的顺序查找" class="headerlink" title="无序链表中的顺序查找"></a>无序链表中的顺序查找</h4><p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       Key key;</span><br><span class="line">       Value value;</span><br><span class="line">       Node next;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> Node first;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node x = first;x != <span class="keyword">null</span>;x = x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key))&#123;</span><br><span class="line">                <span class="keyword">return</span> x.value;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node x = first;x != <span class="keyword">null</span>;x = x.next)&#123;</span><br><span class="line">           <span class="keyword">if</span> (key.equals(x.key))&#123;</span><br><span class="line">               x.value = value;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//未命中 新建头结点</span></span><br><span class="line">       first = <span class="keyword">new</span> Node(key,value,first);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>含有N对键值对的基于无序链表的符号表中，未命中的查找和插入操作都需要N次比较，命中的查找在最坏情况下也需要N次比较。向一个空表中插入N个不同的键需要$N^{2}/2$次比较</p>
<h4 id="有序数组中的二分查找"><a href="#有序数组中的二分查找" class="headerlink" title="有序数组中的二分查找"></a>有序数组中的二分查找</h4><p>该实现的核心是rank()方法，当key存在时，返回的整数i表示表中小于key的键的数量，并且keys[i] == key成立。当key不存在时，返回的整数i表示该key应该插入的位置（同时也表示表中小于key的键的数量）。另外采用一组平行的数组分别用来存储键和值。</p>
<p>二分查找的轨迹如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarysearch_trace.png" alt="有序数组二分查找轨迹"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> values[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="comment">//Key存在更新value</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Key不存在，则将排名之后的元素后移，插入新元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j--) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            values[j] = values[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归的二分查找</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果表中存在该键，rank()返回该键的位置，同时也表示表中小于该键的键的数量</span></span><br><span class="line"><span class="comment">     * 如果表中不存在该键，rank()还是返回表中小于该键的键的数量，同时也表示在何处插入新键</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hi</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> lo;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, lo, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">return</span> key.compareTo(keys[i]) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">return</span> keys[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rank(lo); i &lt; rank(hi); i++) &#123;</span><br><span class="line">            list.add(keys[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains(hi)) &#123;</span><br><span class="line">            list.add(keys[rank(hi)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：二分查找最多需要 lgN + 1次比较。但是构造一个基于有序数组的符号表需要访问数组的次数是数组长度的平方级别。因为有序数组中插入一个元素在最坏情况下需要访问2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问 $N^{2}$次数组</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线上服务CPU过载问题快速定位</title>
    <url>/2020/04/17/architect-road-CPU-Online/</url>
    <content><![CDATA[<h2 id="Java服务CPU100-问题定位"><a href="#Java服务CPU100-问题定位" class="headerlink" title="Java服务CPU100%问题定位"></a>Java服务CPU100%问题定位</h2><p>简单步骤如下：</p>
<ol>
<li>找到最耗CPU的进程</li>
<li>找到进程内最耗CPU的线程</li>
<li>查看堆栈日志，定位对应代码</li>
</ol>
<a id="more"></a>

<h3 id="1-找到最耗CPU的进程"><a href="#1-找到最耗CPU的进程" class="headerlink" title="1.找到最耗CPU的进程"></a>1.找到最耗CPU的进程</h3><p><strong>工具</strong>：top</p>
<p><strong>方法</strong>：</p>
<ul>
<li>执行<code>top -c</code>，显示进程运行信息列表</li>
<li>键入<code>P（大写p）</code>，进程按照CPU使用率排序</li>
</ul>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/om_cpu100_online.png" alt="om_cpu100_online"></p>
<p>如上图，最耗CPU的进程PID为<code>1010</code></p>
<h3 id="2-找到进程内最耗CPU的线程"><a href="#2-找到进程内最耗CPU的线程" class="headerlink" title="2. 找到进程内最耗CPU的线程"></a>2. 找到进程内最耗CPU的线程</h3><p><strong>工具</strong>：top</p>
<p><strong>方法</strong>：</p>
<ul>
<li>执行<code>top  -Hp 1010</code>，显示一个进程的线程运行信息列表</li>
<li>键入<code>P（大写p）</code>，线程按照CPU使用率排序</li>
</ul>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/om_cpu100_online_thread.png" alt="om_cpu100_online_thread"></p>
<p>如上图，最耗CPU的线程PID为<code>1588</code></p>
<h3 id="3-查看堆栈日志，定位对应代码"><a href="#3-查看堆栈日志，定位对应代码" class="headerlink" title="3. 查看堆栈日志，定位对应代码"></a>3. 查看堆栈日志，定位对应代码</h3><p><strong>工具</strong>：printf、jstack</p>
<p><strong>方法</strong>：</p>
<ul>
<li>执行<code>printf  &#39;%x\n&#39; 1588</code>，将线程PID转换为16进制</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/om_cpu100_online_printf.png" alt="om_cpu100_online_printf"></p>
<p>转换为是因为堆栈日志里线程id是用16进制表示的。</p>
<ul>
<li>执行<code>jstack 1010  |  grep  &#39;634&#39;   -C10   --color</code>，查看进程堆栈，过滤线程id得到线程堆栈</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/om_cpu100_online_jstack.png" alt="om_cpu100_online_jstack"></p>
<p>通过上图可以定位到当前线程正在执行的代码</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/shenjian58/article/details/89850081" target="_blank" rel="noopener">线上服务CPU100%问题快速定位实战</a></li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>HashMap 源码分析</title>
    <url>/2020/04/07/java-core-Java-HashMap/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_underly_structure.png" alt="HashMap底层结构"></p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在 Java 中，HashMap使用了散列（Hashing）技术并且实现了Map接口。用于存储键值对（key-value）。允许空键(null key)和空值(null values)。HashMap中使用一个静态内部类(Node)来表示键值对，结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap底层采用数组和链表（LinkedList）数据结构来存储结点Node。哈希表中存储元素的位置又叫存储桶(buckets)。当出现散列冲突时，结点将转换成链表存储在桶中</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_hashmap.png" alt=""></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//"扰动函数"用来优化散列值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扰动函数：</strong> <strong>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。</strong>而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">源自知乎回答</a></p>
<p>数组下标定位：<code>hash % n</code> HashMap通过取模的方式来定位key对应的数组下标。但实际HashMap采用了一种更高效的方式计算数组下标：<code>(n - 1) &amp; hash</code> 即位与运算，前提条件是Node数组长度必须是2的n次幂，因为只有在长度是2的n次幂时，位与运算与取模运算的计算结果才是相同的，也就是 <code>hash % n</code> == <code>hash &amp; (n-1)</code> ，而位与运算比取模运算效率更高，执行速度更快。这也就是为什么HashMap的容量必须为2的整数次幂的原因。源自 <a href="https://zhuanlan.zhihu.com/p/70220699" target="_blank" rel="noopener">知乎问答</a> 和 <a href="https://juejin.im/post/5ab99afff265da23a2291dee" target="_blank" rel="noopener">掘金</a></p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//存放Node实例的数组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//根据hash值定位数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果当前的bucket里面已经是红黑树的话，执行红黑树的添加操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD = 8，判断如果当前bucket的位置链表长度大于8的话就将此链表变成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//转换成红黑树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);<span class="comment">//LinkedHashMap回调处理</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//LinkedHashMap回调处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入步骤如下：</p>
<ol>
<li>通过hash(key)函数（又称扰动函数）计算出key的hash值</li>
<li>对hash值进行取模操作<code>(n-1) &amp; hash</code>计算出数组下标</li>
<li>判断数组下标中的元素是否为空<code>(p = tab[(n-1)&amp;hash]) == null</code> ，如果为空，则创建一个新结点放到数组中，再；如果不为空，则继续走下面步骤</li>
<li>若数组下标元素不为空<ol>
<li>判断头结点的hash和key值是否与要插入的的hash和key值相等，如果相等，说明该key已存在，如果不相等，则继续</li>
<li>判断头结点是否为红黑树结点，如果是，则进行红黑树处理，如果不是，则继续</li>
<li>从头结点开始遍历链表，如果找到一个结点的hash和key值与要插入的hash和key值相等，说明key已存在，如果没找到，则在遍历到末尾时插入由key和value组成的新结点。另外在插入新结点之前如果链表中已经存在8个结点则本次插入之后会触发链表到红黑树的转换</li>
</ol>
</li>
<li>若第4步中得出该key已存在，则替换value值并返回oldValue</li>
<li>把size + 1与threshold做比较，判断是否达到扩容条件，若满足size + 1 &gt; threshold则扩容</li>
<li>返回null</li>
</ol>
<blockquote>
<p>插入总结：根据key计算hash值并定位到具体的桶，判断桶中元素是空还是红黑树还是链表，如果为空直接插入，如果为红黑树则执行红黑树插入，如果为链表则执行链表插入并且当插入前链表长度大于8时进行红黑树转换</p>
</blockquote>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查找步骤如下：</p>
<ol>
<li>通过hash(key)函数（又称扰动函数）计算出key的hash值</li>
<li>对hash值进行取模操作<code>(n-1) &amp; hash</code>计算出数组下标</li>
<li>如果数组下标中没有元素，则返回null，如果有则继续</li>
<li>判断头结点的hash和key值与要查找的hash和key值是否相等，如果相等则返回头结点，如果不相等则继续</li>
<li>判断头结点是否有后继结点，如果有后继结点，则判断头结点是否是红黑树，如果是则从红黑树中查找，如果不是，则遍历链表查找</li>
<li>如果找到key对应的结点则返回结点的value，如果没找到则返回null</li>
</ol>
<blockquote>
<p>查询总结：根据key计算hash值并定位到具体的桶，桶中存在元素的情况下，先判断头结点是否就是要查找的元素，如果是直接返回，如果不是在判断是否有后继结点，如果有在判断头结点是树结点还是链表结点，如果是树节点则在树中查找元素，如果是链表结点则在链表中查找</p>
</blockquote>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树本质上就是一种使用特殊方式来表示2-3树的二叉查找树。其实就是将2-3树中的3结点转换成了2个2结点和一条红色链接。    </p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>含有红黑链接并满足下列条件的二叉查找树：</p>
<ul>
<li>红链接均为左链接</li>
<li>任何一个结点不能同时和两条红链接相连</li>
<li>必须是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ul>
<h4 id="左旋转、右旋转、颜色变换"><a href="#左旋转、右旋转、颜色变换" class="headerlink" title="左旋转、右旋转、颜色变换"></a>左旋转、右旋转、颜色变换</h4><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_passup.png" alt="红链接向上传递"></p>
<p>上图展示了使用这三种简单操作的时机</p>
<ol>
<li>如果右子结点是红色的而左子结点是黑色的，进行左旋转</li>
<li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转</li>
<li>如果左右子结点均为红色，进行颜色变换</li>
</ol>
<blockquote>
<p>注意点：新结点必须为红色与颜色变换的目的都是为了保证整棵树的黑色平衡性。如果新插入的结点为黑色则破坏了黑色平衡性；如果没有颜色变换，则叶子节点就可能为红色结点，而插入时就只能为黑色结点，同样又破坏了黑色平衡性。</p>
</blockquote>
<p>旋转和颜色变换的所有复杂情况都可以归结为以下三种情况的复合操作</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_insert_single3node.png" alt="algorithm_redblack_insert_single3node"></p>
<h4 id="HashMap中红黑树代码表示"><a href="#HashMap中红黑树代码表示" class="headerlink" title="HashMap中红黑树代码表示"></a>HashMap中红黑树代码表示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构建红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//右旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//插入新元素之后的平衡操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//删除元素之后的平衡操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果数组容量小于64，则进行扩容操作，而不是树化过程</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将链表结点替换成树结点，并将所有结点构造成一个双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将双向链表转换成红黑树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">//获取下一个结点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="comment">//第一次循环进来，root为空，将root指向链表头结点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//x为链表当前结点</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//将当前链表结点ｘ插入到树中，并通过旋转和颜色变换使树保持平衡</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="comment">//dir：directory，比较新插入结点与当前树中访问节点的hash值判断加入项的路径，-1为左子树，+1为右子树。</span></span><br><span class="line">                <span class="comment">//ph：parent hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">				<span class="comment">//xp : x parent</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//根据hash值比较出的方向，一步一步到达树中新插入结点的路径的末尾</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//标记当前树结点为新插入结点的父结点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)<span class="comment">//标记当前树结点的左子结点为新插入结点</span></span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;<span class="comment">//标记当前树结点的右子结点为新插入结点</span></span><br><span class="line">                    <span class="comment">//新结点插入之后的平衡操作</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensures that the given root is the first node of its bin.</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次循环会将链表中的首节点作为红黑树的根，而后的循环会将链表中的的项通过比较hash值然后连接到相应树节点的左边或者右边，插入可能会破坏树的平衡所以接着执行balanceInsertion操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记新结点为红色，目的是为了不破坏树的黑色平衡。</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">   	<span class="comment">// 这些变量名不是作者随便定义的都是有意义的。</span></span><br><span class="line">   	<span class="comment">// xp：x parent，代表x的父节点。</span></span><br><span class="line">   	<span class="comment">// xpp：x parent parent，代表x的祖父节点</span></span><br><span class="line">   	<span class="comment">// xppl：x parent parent left，代表x的祖父的左节点。</span></span><br><span class="line"> 	<span class="comment">// xppr：x parent parent right，代表x的祖父的右节点。</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//ｘ的父结点为null说明只有ｘ一个结点，且ｘ就为根结点，根结点的颜色为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进入else说明不是根节点。</span></span><br><span class="line">       	<span class="comment">// 如果父节点是黑色，那么大吉大利（今晚吃鸡），红色的x节点可以直接添加到黑色节点后面，返回根就行了不需要任何多余的操作。</span></span><br><span class="line">       	<span class="comment">// 如果父节点是红色的，但祖父节点为空的话也可以直接返回根此时父节点就是根节点，因为根必须是黑色的，添加在后面没有任何问题。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一旦我们进入到这里就说明了两件事情</span></span><br><span class="line">       	<span class="comment">// 1.x的父节点xp是红色的，这样就遇到两个红色节点相连的问题，所以必须经过旋转变换。</span></span><br><span class="line">       	<span class="comment">// 2.x的祖父节点xpp不为空。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果父结点是祖父结点的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 父节点xp是祖父的左节点xppl</span></span><br><span class="line">            <span class="comment">// 判断祖父节点的右节点不为空并且是否是红色的</span></span><br><span class="line">            <span class="comment">// 此时xpp的左右节点都是红的，所以直接进行上面所说的第三种变换，将两个子节点变成黑色，将xpp变成红色，然后将红色节点x顺利的添加到了xp的后面。</span></span><br><span class="line">            <span class="comment">// 这里大家有疑问为什么将x = xpp？</span></span><br><span class="line">            <span class="comment">// 这是由于将xpp变成红色以后可能与xpp的父节点发生两个相连红色节点的冲突，这就又构成了第二种旋转变换，所以必须从底向上的进行变换，直到根。</span></span><br><span class="line">            <span class="comment">// 所以令x = xpp，然后进行下下一层循环，接着往上走。</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进入到这个else里面说明。</span></span><br><span class="line">            <span class="comment">// 父节点xp是祖父的左节点xppl，且父结点xp是红色的</span></span><br><span class="line">            <span class="comment">// 祖父节点xpp的右节点xppr是黑色节点或者为空，默认规定空节点也是黑色的。</span></span><br><span class="line">            <span class="comment">// 下面要判断x是xp的左节点还是右节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// x是xp的右节点，此时的结构是：xpp左-&gt;xp右-&gt;x。这明显是第二中变换需要进行两次旋转，这里先进行一次旋转。</span></span><br><span class="line">                <span class="comment">// 下面是第一次旋转。</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 针对本身就是xpp左-&gt;xp左-&gt;x的结构或者由于上面的旋转造成的这种结构进行一次旋转。</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="颜色变换"><a href="#颜色变换" class="headerlink" title="颜色变换"></a>颜色变换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果父结点是祖父结点的左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">// 这是由于将xpp变成红色以后可能与xpp的父节点发生两个相连红色节点的冲突，这就又构成了第二种旋转变换，所以必须从底向上的进行变换，直到根。</span></span><br><span class="line">            	<span class="comment">// 所以令x = xpp，然后进行下下一层循环，接着往上走。</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里是一个典型的一个黑色节点的两个子节点都是红色的所以要进行<strong>颜色变换</strong>，因为插入的都是红色节点，当检测到祖父节点的左右子节点都是红色的时候两个红色就产生了冲突，所以先将节点进行这种颜色变换，将祖父节点变成红色，然后将祖父的两个子节点变成黑色，这样我们插入的红色节点就不会违背红黑树的规则了</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_flipcolor.png" alt="hashmap_redblack_flipcolor"></p>
<p>如果祖父节点是根节点，最终祖父节点也会变成黑色，因为进行下一轮循环的时候会优先检测当前节点是否是根节点，如果是根节点那就将颜色变成黑色，就是下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">     x.red = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左旋转和右旋转"><a href="#左旋转和右旋转" class="headerlink" title="左旋转和右旋转"></a>左旋转和右旋转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果父结点是祖父结点的左孩子</span></span><br><span class="line"><span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">     <span class="comment">//颜色变换</span></span><br><span class="line">     <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">          xppr.red = <span class="keyword">false</span>;</span><br><span class="line">          xp.red = <span class="keyword">false</span>;</span><br><span class="line">          xpp.red = <span class="keyword">true</span>;</span><br><span class="line">          x = xpp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// x是xp的右节点，此时的结构是：xpp左-&gt;xp右-&gt;x。这明显是第二中变换需要进行两次旋转，这里先进行一次旋转。</span></span><br><span class="line">          <span class="comment">// 下面是第一次旋转。</span></span><br><span class="line">          <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">               root = rotateLeft(root, x = xp);</span><br><span class="line">               xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 针对本身就是xpp左-&gt;xp左-&gt;x的结构或者由于上面的旋转造成的这种结构进行一次旋转。</span></span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">               xp.red = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                    root = rotateRight(root, xpp);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当结点ｘ的父结点xp是祖父结点xpp的左孩子，而ｘ是父结点xp的右孩子时，形成如下的结构：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_left_rotate.png" alt="hashmap_redblack_left_rotate"></p>
<ul>
<li>左旋转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//p: parent</span></span><br><span class="line">     <span class="comment">// r：right，右节点</span></span><br><span class="line"> 	<span class="comment">// pp：parent parent，父节点的父节点</span></span><br><span class="line">     <span class="comment">// rl：right left，右节点的左节点</span></span><br><span class="line">     TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">               rl.parent = p;</span><br><span class="line">          <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">               (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">               pp.left = r;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               pp.right = r;</span><br><span class="line">          r.left = p;</span><br><span class="line">          p.parent = r;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>刚进入方法时，状态如下图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_left_rotate_step1.png" alt="step1"></p>
<ol start="2">
<li>执行完第9行和第10行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_left_rotate_step2.png" alt="step2"></p>
<ol start="3">
<li>接下来执行分支语句，结果会选择一个（12|14,当前结构不会执行16）进行执行，然后在执行17和18行</li>
</ol>
<p>执行12行<code>(root=r).red=false</code>时</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_left_rotate_step3.png" alt="step3_1"></p>
<p>执行14行<code>pp.left=r</code>时</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_left_rotate_step3_2.png" alt="step3_2"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">     root = rotateLeft(root, x = xp);</span><br><span class="line">     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外注意，图中的ｐ指针就是传入的ｘ指针，所以此时ｘ是指向没旋转之前的父结点xp的。那么在经过<code>xpp = (xp = x.parent) == null ? null : xp.parent;</code>，x、xp、xpp指针的关系就变为下图所示的关系：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_left_rotate_complete.png" alt="left_rotate_complete"></p>
<ul>
<li>右旋转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">     xp.red = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">          xpp.red = <span class="keyword">true</span>;</span><br><span class="line">          root = rotateRight(root, xpp);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过两次判空操作转换成下图形式(rl结点在右旋转时不在用到，所以省略了)：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_right_rotate_before.png" alt="right_rotate_before"></p>
<p>然后在进行右旋转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//ｌ：p.left 左结点</span></span><br><span class="line">     <span class="comment">//pp：p.parent 父结点的父结点</span></span><br><span class="line">     <span class="comment">//lr：p.left.right左结点的右结点</span></span><br><span class="line">     TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">               lr.parent = p;</span><br><span class="line">          <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">               (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">               pp.right = l;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               pp.left = l;</span><br><span class="line">          l.right = p;</span><br><span class="line">          p.parent = l;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>if判断传入的ｐ结点和ｐ结点的左结点不为空之后执行第8和9行</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_right_rotate_step1.png" alt="step1"></p>
<ol start="2">
<li>同样是执行一个分支语句，再加上16和17行</li>
</ol>
<p>执行11行的结果</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_right_rotate_step2.png" alt="step2"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">     pp.right = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     pp.left = l;</span><br></pre></td></tr></table></figure>

<p>剩下两个分支语句的目的是原封不动把p的位置替换成l，假如ｐ原来是pp的右孩子，那现在就把ｌ作为pp的右孩子，同理如果ｐ原来是pp的左孩子，就把ｌ作为pp的左孩子。下图是p原来是pp右孩子的情况：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_right_rotate_step3.png" alt="step3"></p>
<p>右旋转结束后发现黑色结点下的左右两个子结点均为红色，正好出现了上面将的颜色变换的情况，所以还需在进行一次颜色变换</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hashmap_redblack_right_rotate_flipcolor.png" alt="flipcolor"></p>
<p>上图中的lr结点被我省略掉了，因为旋转和颜色变换都是从叶子结点开始自底向上进行，所以本次右旋转和颜色变换之后下层的结点肯定都符合红黑树性质。而上层不一定满足，因为这次右旋转和颜色变换之后l上浮了一层，并且颜色变为红色，以上面的例子来看，ｌ是以红色结点作为pp的右孩子，也就是出现了红链接为右链接，不满足红黑树性质，需要继续做旋转和颜色变换操作，直到树的根结点来保持整棵树的完美黑色平衡性。</p>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p><a href="http://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a> 这边文章中resize的过程已经将的很清楚，这里自己再结合源码分析下resize在链表和红黑树的情况下的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     threshold = newThr;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">     table = newTab;</span><br><span class="line">     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                         newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                         ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order    意思是保留链表原有的顺序</span></span><br><span class="line">                         Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                         Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                         Node&lt;K,V&gt; next;</span><br><span class="line">                         <span class="keyword">do</span> &#123;</span><br><span class="line">                              next = e.next;</span><br><span class="line">                              <span class="comment">//新增的1bit是0，索引位置不变</span></span><br><span class="line">                              <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                   <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                        loHead = e;</span><br><span class="line">                                   <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = e;</span><br><span class="line">                                   loTail = e;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">else</span> &#123;<span class="comment">//新增的1bit是1，索引位置为[原位置 + oldCap]</span></span><br><span class="line">                                   <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                        hiHead = e;</span><br><span class="line">                                   <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = e;</span><br><span class="line">                                   hiTail = e;</span><br><span class="line">                              &#125;</span><br><span class="line">                         &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                         <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                              newTab[j] = loHead;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                              newTab[j + oldCap] = hiHead;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当桶内存储的是链表时，遍历链表，根据<code>(e.hash &amp; oldCap) == 0</code>判断<code>hash&amp;(n-1)</code>的值是原值还是原值+oldCap，将所有结点拆分成了两个链表，一个是原位置的链表，一个是新位置（原位置+oldCap）的链表。</p>
<p>当桶内存储的是红黑树时，采用的是TreeNode.split方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">         * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">         * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">     TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">     TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">     TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">          next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">          e.next = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;<span class="comment">//构建原位置的双向链表</span></span><br><span class="line">               <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    loHead = e;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    loTail.next = e;</span><br><span class="line">               loTail = e;</span><br><span class="line">               ++lc;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;<span class="comment">//构建[原位置+oldCap]的双向链表</span></span><br><span class="line">               <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                    hiHead = e;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = e;</span><br><span class="line">               hiTail = e;</span><br><span class="line">               ++hc;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">               tab[index] = loHead.untreeify(map);<span class="comment">//如果双向链表长度小于6，将其转成单链表</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">               tab[index] = loHead;</span><br><span class="line">               <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                    loHead.treeify(tab);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">               tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">               tab[index + bit] = hiHead;</span><br><span class="line">               <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                    hiHead.treeify(tab);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红黑树在resize时，是将所有结点拆成了两个双向链表，如果双向链表的长度小于等于6，就将其转成单链表，否则将其转成红黑树（这里有个疑问，看代码应该是只有一个位置能转成树，通过<code>hiHead!=null</code>和<code>loHead!=null</code>的判断，转完红黑树以后hiHead==null了，这个每太搞懂）。</p>
<p>这里要说一下红黑树得出两个双向链表的技巧，其实一个桶里的红黑树不只有树结构，还有一个以根结点为头结点的双向链表结构，因为TreeNode这个类是继承自HashMap.Node类的，那么TreeNode的全部属性应该是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">     TreeNode&lt;K,V&gt; left;</span><br><span class="line">     TreeNode&lt;K,V&gt; right;</span><br><span class="line">     TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion   指向上一个结点</span></span><br><span class="line">     <span class="keyword">boolean</span> red;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//这部分来自于LinkedHashMap.Entry</span></span><br><span class="line">     Entry&lt;K,V&gt; before, after;</span><br><span class="line">     Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这部分来自于HashMap.Node</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     V value;</span><br><span class="line">     Node&lt;K,V&gt; next;<span class="comment">//指向下一个结点</span></span><br><span class="line">     Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.hash = hash;</span><br><span class="line">          <span class="keyword">this</span>.key = key;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过prev和next两个指针分别指向前一个和后一个结点，从而构成双向链表。而且在构建完红黑树之后还做了一个特殊的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">          <span class="comment">//桶中原来的头结点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">          <span class="comment">//当头结点和红黑树的根结点不是一个结点时，需要替换根结点为头结点</span></span><br><span class="line">          <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">               Node&lt;K,V&gt; rn;</span><br><span class="line">               tab[index] = root;<span class="comment">//桶指向根结点</span></span><br><span class="line">               TreeNode&lt;K,V&gt; rp = root.prev;<span class="comment">//根结点的前驱结点</span></span><br><span class="line">               <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)rn).prev = rp;<span class="comment">//将根结点的后继结点的前驱结点设置为根结点的父结点</span></span><br><span class="line">               <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                    rp.next = rn;<span class="comment">//根结点的父结点的后继结点直接指向根结点的后继结点</span></span><br><span class="line">               <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                    first.prev = root;</span><br><span class="line">               root.next = first;<span class="comment">//将根结点的后继结点指向头结点</span></span><br><span class="line">               root.prev = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>moveRootToFront</code>执行之前的链表结构：first&lt;—&gt;n1&lt;—&gt;n2&lt;—&gt;n3&lt;—&gt;root&lt;—&gt;n5&lt;—&gt;n6–&gt;null</p>
<p><code>moveRootToFront</code>执行之后的链表结构：root&lt;—&gt;first&lt;—&gt;n1&lt;—&gt;n2&lt;—&gt;n3&lt;—&gt;n5&lt;—&gt;n6–&gt;null</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>算法第四版</p>
<p><a href="https://www.cnblogs.com/finite/p/8251587.html" target="_blank" rel="noopener">HashMap分析之红黑树树化过程</a></p>
<p><a href="http://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a></p>
<p><a href="https://deepakvadgama.com/blog/java-hashmap-internals/" target="_blank" rel="noopener">Java HashMap internals</a></p>
<p><a href="https://howtodoinjava.com/java/collections/hashmap/how-hashmap-works-in-java/" target="_blank" rel="noopener">How HashMap works in Java</a></p>
<p><a href="https://blog.csdn.net/zhengwangzw/article/details/104889549" target="_blank" rel="noopener">一个HashMap能跟面试官扯上半个小时</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术 - 基础知识卷</title>
    <url>/2020/04/07/java-core-Java-Fundamentals/</url>
    <content><![CDATA[<h2 id="1-Java程序设计概述"><a href="#1-Java程序设计概述" class="headerlink" title="1.Java程序设计概述"></a>1.Java程序设计概述</h2><h3 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h3><ul>
<li>简单性</li>
<li>面向对象</li>
</ul>
<blockquote>
<p>与面向过程的区别：</p>
<p>面向过程：性能高。面向过程语言大多都是编译成机器能直接运行的机器码，而java需要多一步解释执行的过程。首先编译器将Java源代码编译成字节码，字节码再由JVM虚拟机解释成机器码运行。但现在Java性能已经提升了很多并不比一些面向过程的脚本语言差，因为虚拟机支持<strong>即时编译</strong>。</p>
<p>即时编译：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html）" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html）</a></p>
<p>面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</blockquote>
<ul>
<li>可移植（JVM实现平台无关）</li>
<li>安全性</li>
<li>健壮性</li>
<li>多线程</li>
<li>高性能（通过即时编译器实现）</li>
</ul>
<a id="more"></a>

<h2 id="2-Java程序设计环境"><a href="#2-Java程序设计环境" class="headerlink" title="2.Java程序设计环境"></a>2.Java程序设计环境</h2><h3 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM/JDK/JRE"></a>JVM/JDK/JRE</h3><p><strong>JVM</strong>：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>字节码以及采用字节码的好处</strong>：</p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>java程序从源代码到运行一般分三步</strong>：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/corejava_compile_run.png" alt="java_compile_run"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结</strong>：</p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处运行”的关键所在。</p>
<p>JDK：Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p><strong>JRE</strong>：Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<blockquote>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
</blockquote>
<h2 id="3-Java的基本程序设计结构"><a href="#3-Java的基本程序设计结构" class="headerlink" title="3.Java的基本程序设计结构"></a>3.Java的基本程序设计结构</h2><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_primitive_type.png" alt="java_primitive_type"></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 是一种强类型语言。这就意味着必须为每一个变量声明一种类型: 在 Java 中， 一共有 8<br>种基本类型（ primitive type ), 其中有 4 种整型、2 种浮点类型、 1 种用于表示 Unicode 编码的字符<br>单元的字符类型 char 和 1 种用于表示真值的 boolean 类型</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>占据字节大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节</td>
<td>-128～127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-32 768～32 767</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2 147 483 648～2 147 483 647 (正好超过 20 亿)</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-9 223 372 036 854 775 808 ～ 9 223 372 036 854 775 807</td>
</tr>
</tbody></table>
<p>长整型数值有一个后缀 L 或 1 ( 如 4000000000L)。 十六进制数值有一个前缀 0x 或 0X (如0xCAFEL)。八进制有一个前缀 0 , 例如， 010 对应八进制中的 8。很显然， 八进制表示法比较容易混淆， 所以建议最好不要使用八进制常数。</p>
<p>从 Java 7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0b1001就是 9。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用 1_000_000(或0b1111_0100_0010_0100_0000)表示一百万。这些下划线只是为了让人更易读。Java 编译器会去除这些下划线。</p>
<p><em>注意：Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。</em></p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>占据字节大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位）</td>
</tr>
</tbody></table>
<p>float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == Double.NaN)<span class="comment">//不能这样检测一个值是否为非数字,因为所有"非数值"的值都被认为是不相同的</span></span><br><span class="line"><span class="comment">//可以用Double.isNaN()方法判断一个值是否为非数值    </span></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(x))</span><br></pre></td></tr></table></figure>

<p><em>注意：如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类</em></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>两个数进行二元操作时，需要先将两个操作数转换为同一种类型，然后在进行计算。</p>
<ul>
<li>如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。</li>
<li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。</li>
<li>否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。</li>
<li>否则， 两个操作数都将被转换为 int 类型。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_number_convert.png" alt="java_number_convert"></p>
<p>6个实心箭头表示无信息丢失的转换</p>
<p>3个虚线箭头表示可能有精度损失的转换</p>
<h4 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h4><p> 如果运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。 例如，如果 X 是一个 int, 则以下语句<br>x += 3.5;<br>是合法的， 将把 X 设置为（int)(x + 3.5)。</p>
<h4 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h4><p>前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span> * ++m;<span class="comment">//now a is 16,m is 8</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span> * n++;<span class="comment">//now b is 14,n is 8</span></span><br></pre></td></tr></table></figure>

<p>即前++使用++之后的值，后++使用++之前的值。</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符包括&amp; (“and”)、 | (“or”)、 ^ (“xor”)、 ~ (“not”)、左移（&lt;&lt;）、右移（&gt;&gt;）、无符号右移（&gt;&gt;&gt;）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fourthBitFromRight = (n &amp; <span class="number">0b1000</span>) / <span class="number">0b1000</span>;<span class="comment">//如果n的二进制位表示，从有往左数的第四位为1则该表达式结果为1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。<strong>不可变字符串优点：编译器可以让字符串共享</strong></p>
<blockquote>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
</blockquote>
<h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p>可以使用 equals 方法检测两个字符串是否相等。一定不要使用==运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。因此，千万不要使甩== 运算符测试字符串的相等性</p>
<h4 id="空串与Null串"><a href="#空串与Null串" class="headerlink" title="空串与Null串"></a>空串与Null串</h4><p>空串 “” 是长度为 0 的字符串。空串是一个 Java 对象， 有自己的串长度（ 0 ) 和内容（空）。不过， String 变量还可以存放一个特殊的值， 名为 null, 这表示目前没有任何对象与该变量关联。</p>
<h4 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h4><p><strong>StringBuider 和 StringBuffer 的区别</strong></p>
<p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p>String：String 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p>AbstractStringBuilder类 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
<p>StringBuffer：对父类部分方法进行重写加了同步锁（synchronized），所以是线程安全的。</p>
<p>StringBuilder：并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。单线程情况下建议使用StringBuilder。</p>
<p><strong>总结</strong>：</p>
<ol>
<li>操作少量数据：适用String</li>
<li>单线程操作字符串缓冲区下大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下大量数据: 适用 StringBuffer</li>
</ol>
<h4 id="字符常量和字符串常量的区别"><a href="#字符常量和字符串常量的区别" class="headerlink" title="字符常量和字符串常量的区别"></a>字符常量和字符串常量的区别</h4><ol>
<li>形式上：字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li>
<li>含义上：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制台读取输入</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"What is your name?"</span>);</span><br><span class="line">String name = in.nextLine();</span><br><span class="line">String fistName = in.next();</span><br><span class="line"><span class="keyword">int</span> age = in.nextInt();</span><br><span class="line"><span class="keyword">double</span> = in.nextDouble();</span><br><span class="line"><span class="comment">//控制台读取密码</span></span><br><span class="line">Console cons = System.console();</span><br><span class="line">String username = cons.readLine(<span class="string">"User name:"</span>);</span><br><span class="line"><span class="keyword">char</span>[] passwd = cons.readPassword(<span class="string">"Passwrod:"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>Java SE 5.0 沿用了 C语言库函数中的 printf方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以用 8 个字符的宽度和小数点后两个字符的精度打印 x</span></span><br><span class="line">System.out.printf(<span class="string">"%8.2f"</span>,x);<span class="comment">//结果  3333.33</span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"Hello, %s. Next year, you'll be %d"</span>,name,age);</span><br></pre></td></tr></table></figure>

<p>每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_print_symbol.png" alt="java_printf_symbol"></p>
<p>另外，还可以给出控制格式化输出的各种标志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逗号标志增加了分组的分隔符</span></span><br><span class="line">System.out.printf(<span class="string">"%,.2f"</span>,<span class="number">1000.0</span>/<span class="number">3.0</span>)<span class="comment">//结果：3,333,33</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_printf_sign.png" alt="java_printf_sign"></p>
<p>可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String message = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>,name,age);</span><br></pre></td></tr></table></figure>

<p>API(Java 7提供)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = java.nio.file.Paths.get(String pathname);</span><br></pre></td></tr></table></figure>

<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h4 id="多重选择：switch语句"><a href="#多重选择：switch语句" class="headerlink" title="多重选择：switch语句"></a>多重选择：switch语句</h4><p>case标签可以是：</p>
<ul>
<li>类型为char、byte、short或int的常量表达式</li>
<li>枚举常量</li>
<li>Java SE7开始，支持字符串字面量</li>
</ul>
<h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>BigInteger和BigDecimal</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h4><p>foreach 循环语句的循环变量将会遍历数组中的每个元素， 而不需要使用下标值。</p>
<p>在很多场合下， 还是需要使用传统的 for 循环t 例如，如果不希望遍历集合中的每个元素， 或者在循环内部需要使用下标值等。</p>
<blockquote>
<p>有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调用 Arrays.toString(a), 返回一个包含数组元素的字符串，这些元素被放置在括号内， 并用逗号分隔， 例如 “ [2,3,5,7，11，13]”</p>
</blockquote>
<h4 id="数组初始化及匿名数组"><a href="#数组初始化及匿名数组" class="headerlink" title="数组初始化及匿名数组"></a>数组初始化及匿名数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> smallPrimes = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化一个匿名数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="comment">//这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。</span></span><br><span class="line">smallPrimes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p>一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, <span class="number">2</span>* luckyNumbers.length);</span><br></pre></td></tr></table></figure>

<p>第 2 个参数是新数组的长度，这个方法通常用来增加数组的大小。如果数组元素是数值型，那么多余的元素将赋值为 0 ; 如果数组元素是布尔型，则将赋值为 false。相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java Message -g cruel world</span><br></pre></td></tr></table></figure>

<p>Message类的main方法接收String类型的数组，args[0] = “-g”，args[1]=”cruel”，args[2]=”world”</p>
<h4 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] odds =  <span class="keyword">new</span>  <span class="keyword">int</span>[NMAX + <span class="number">1</span>][];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n &lt;= NMAX;n++)&#123;</span><br><span class="line">    odds[n] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;odds.length;n++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;odds[n].length;k++)&#123;</span><br><span class="line">        odds[n][k] = lotteryOdds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-对象与类"><a href="#4-对象与类" class="headerlink" title="4.对象与类"></a>4.对象与类</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final是java中的关键字，用于限制某些功能(restricting some functionalities)。我们可以使用final关键字声明变量，方法和类</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>声明变量为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。对于基本类型，final 使数值不变；对于引用对象，final 使引用不变，也就是不能引用其它对象，但是被引用的对象本身是可以修改的，比如可以从final数组或者final集合里添加元素或者删除元素。</p>
<p>final修饰的变量的初始化方式有三种：</p>
<ol>
<li>声明的时候直接初始化，这种方式最常见</li>
<li>声明的时候没有初始化，我们把这种final变量叫做空final变量(blank final variable)，空final变量可以在实例初始化块或者构造函数内部初始化，如果有多个构造函数那么每个构造函数都要进行初始话，否则编译不通过</li>
<li>空的静态final变量在静态代码块中初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Java program to demonstrate different </span></span><br><span class="line"><span class="comment">// ways of initializing a final variable </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gfg</span>  </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// a final variable </span></span><br><span class="line">    <span class="comment">// direct initialize </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">5</span>; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// a blank final variable </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// another blank final variable </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>  MINIMUM; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// a final static variable PI </span></span><br><span class="line">    <span class="comment">// direct initialize </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// a  blank final static  variable </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EULERCONSTANT; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// instance initializer block for  </span></span><br><span class="line">    <span class="comment">// initializing CAPACITY </span></span><br><span class="line">    &#123; </span><br><span class="line">        CAPACITY = <span class="number">25</span>; </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// static initializer block for  </span></span><br><span class="line">    <span class="comment">// initializing EULERCONSTANT </span></span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        EULERCONSTANT = <span class="number">2.3</span>; </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// constructor for initializing MINIMUM </span></span><br><span class="line">    <span class="comment">// Note that if there are more than one </span></span><br><span class="line">    <span class="comment">// constructor, you must initialize MINIMUM </span></span><br><span class="line">    <span class="comment">// in them also </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GFG</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        MINIMUM = -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，for-each循环里也可以使用final修饰局部变量，因为每次循环迭代，这个局部变量都是被重新声明的，所以可以用final修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// final with for-each statement </span></span><br><span class="line">        <span class="comment">// legal statement </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> i : arr) </span><br><span class="line">            System.out.print(i + <span class="string">" "</span>); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p> final声明的方法不能被重写(overridden)。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类被声明final时有两个用处：1. 禁止继承(prevent  inheritance)，比如包装类Integer，Float等等；2.创建不可变类（immutable class），比如String</p>
<p>另外，如果一个类被声明成final，则默认情况下该类中的所有方法也是final的，但是变量不是final的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java program to illustrate final keyword </span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// by default it is final. </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// by default it is not final. </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">30</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">// See modified contents of variable j. </span></span><br><span class="line">		j = <span class="number">36</span>; </span><br><span class="line">		System.out.println(j); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>36</p>
</blockquote>
<h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><p>final 上面已经介绍过</p>
<p>finally 通常与try/catch块一起使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Java program to demonstrate finally. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Geek</span> </span>&#123; </span><br><span class="line">	<span class="comment">// A method that throws an exception and has finally. </span></span><br><span class="line">	<span class="comment">// This method will be called inside try-catch. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			System.out.println(<span class="string">"inside A"</span>); </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"demo"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123; </span><br><span class="line">			System.out.println(<span class="string">"A's finally"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// This method also calls finally. This method </span></span><br><span class="line">	<span class="comment">// will be called outside try-catch. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			System.out.println(<span class="string">"inside B"</span>); </span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123; </span><br><span class="line">			System.out.println(<span class="string">"B's finally"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			A(); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">			System.out.println(<span class="string">"Exception caught"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		B(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>inside A</p>
<p>A’s finally</p>
<p>Exception caught</p>
<p>inside B</p>
<p>B’s finally</p>
</blockquote>
<p>finally 块中通常用来进行资源的释放，jdk7中提供了try-with-resources 语法来自动关闭资源而不用再写finally块。</p>
<p>finalize 不是一个保留关键字，而final、finally是Java中保留的关键字。finalize是Object类中定义的方法，而Object类又是所有类的基类，所以所有类都可以重写finalize方法。该方法是由垃圾收集器销毁可回收对象之前调用，以进行清理活动。主要清理跟该对象有关联的资源比如数据库连接、网络连接，目的就是取消该对象上的资源分配，该方法执行完之后垃圾收集器立即销毁该对象。</p>
<p>finalize方法相关的几个例子：</p>
<ol>
<li>可回收的对象在被垃圾收集器回收之前，执行该对象的finalize方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		Hello s = <span class="keyword">new</span> Hello(<span class="string">"RR"</span>); </span><br><span class="line">		s = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Main Completes</p>
<p>finalize method overriden</p>
</blockquote>
<ol start="2">
<li>显式调用finalize方法，这时就跟普通方法没有区别，调用之后该对象也不会被销毁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bye</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		Bye m = <span class="keyword">new</span> Bye(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Calling finalize method Explicitly. </span></span><br><span class="line">		m.finalize(); </span><br><span class="line">		m.finalize(); </span><br><span class="line">		m = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>finalize method overriden</p>
<p>finalize method overriden</p>
<p>Main Completes</p>
<p>finalize method overriden</p>
</blockquote>
<ol start="3">
<li><p>当finalize方法抛出unchecked exception异常时，分两种情况处理：</p>
<ol>
<li>程序中显式调用finalize方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		Hi j = <span class="keyword">new</span> Hi(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Calling finalize method Explicitly. </span></span><br><span class="line">		j.finalize(); </span><br><span class="line"></span><br><span class="line">		j = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">		System.out.println(<span class="number">10</span> / <span class="number">0</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>exception in thread “main” java.lang.ArithmeticException:<br>/ by zero followed by stack trace.</p>
</blockquote>
<p>显式调用且没有进行异常捕获时，程序异常退出</p>
<ol start="2">
<li>垃圾收集器调用的finalize方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RR</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		RR q = <span class="keyword">new</span> RR(); </span><br><span class="line">		q = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">		System.out.println(<span class="number">10</span> / <span class="number">0</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>finalize method overriden</p>
<p>Main Completes</p>
</blockquote>
<p>如果是垃圾收集器调用的finalize方法，且抛出unchecked异常时，JVM会忽略该异常并继续执行，因此该程序正常退出</p>
</li>
</ol>
<p><strong>要点总结</strong>：</p>
<ol>
<li>finalize方法的调用时间不固定，只要对象可回收，垃圾收集器在销毁它之前都会调用finalize方法</li>
<li>JVM只忽略<strong><a href="https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java/" target="_blank" rel="noopener">Unchecked exceptions</a></strong>异常，其他异常不会忽略，并且如果有catch block也会执行</li>
<li>System.gc()只是请求JVM去执行垃圾回收，由JVM决定是否进行垃圾回收，通常情况下当堆空间不够或者可用内存较低时JVM才会调用垃圾收集器进行垃圾回收</li>
</ol>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>abstract 是java中的非访问修饰符(non-access modifier)，可以用来修饰类(classes)和方法(methods)，但是不能用来修饰变量(variables). 用于实现抽象</p>
<p><strong>类</strong> ：abstract修饰的类叫抽象类(abstract class)</p>
<p>以下是抽象类的几个重要特点：</p>
<ol>
<li>抽象类不能被实例化，但是可以引用抽象类类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Uncommenting the following line will cause compiler error as the </span></span><br><span class="line">		<span class="comment">// line tries to create an instance of abstract class. </span></span><br><span class="line">		<span class="comment">// Base b = new Base(); </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// We can have references of Base type. </span></span><br><span class="line">		Base b = <span class="keyword">new</span> Derived(); </span><br><span class="line">		b.fun(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Derived fun() called</p>
</blockquote>
<ol start="2">
<li>抽象类中可以含有构造方法，当子类实例化时抽象类的构造方法被调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An abstract class with constructor </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	Base() &#123; System.out.println(<span class="string">"Base Constructor Called"</span>); &#125; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	Derived() &#123; System.out.println(<span class="string">"Derived Constructor Called"</span>); &#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	Derived d = <span class="keyword">new</span> Derived(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Base Constructor Called</p>
<p>Derived Constructor Called</p>
</blockquote>
<ol start="3">
<li>抽象类中可以没有抽象方法，该类不能被实例化只能被继承，所以普通方法可以被继承到子类中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An abstract class without any abstract method </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Base fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">		Derived d = <span class="keyword">new</span> Derived(); </span><br><span class="line">		d.fun(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Base fun() called</p>
</blockquote>
<ol start="4">
<li>抽象类中可以有final方法，final方法不能被重写(overridden)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An abstract class with a final method </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	Base b = <span class="keyword">new</span> Derived(); </span><br><span class="line">	b.fun(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Derived fun() called</p>
</blockquote>
<p><strong>方法</strong> ：当一些方法在父类中只需要声明（declare），子类来提供方法定义（method definition）时，可以将其用abstract修饰，即为抽象方法</p>
<p>表现形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> type method-name(parameter-list);</span><br></pre></td></tr></table></figure>

<p>抽象方法没有方法体，任何继承了抽象类的具体类必须实现所有抽象方法</p>
<p><strong>抽象方法的重要规则</strong> ：</p>
<ul>
<li>任何包含一个或多个抽象方法的类必须声明为抽象类</li>
<li>抽象方法上所有与abstract修饰符冲突的修饰符<ul>
<li>abstract final</li>
<li>abstract native</li>
<li>abstract synchronized</li>
<li>abstract static</li>
<li>abstract private</li>
<li>abstract strictfp</li>
</ul>
</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 是java中的非访问修饰符(non-access modifier)，可以用来修饰块(blocks)、变量(variables)、方法(methods)、嵌套类(nested classes)</p>
<p><strong>静态代码块(static block)</strong> ：用于类的静态初始化</p>
<ol>
<li>静态代码块只会被执行一次，当第一次创建该类的对象或者第一次访问该类的静态成员时执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filename: Main.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line">	<span class="keyword">int</span> j; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// start of static block </span></span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		i = <span class="number">10</span>; </span><br><span class="line">		System.out.println(<span class="string">"static block called "</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// end of static block </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Although we don't have an object of Test, static block is </span></span><br><span class="line">		<span class="comment">// called because i is being accessed in following statement. </span></span><br><span class="line">		System.out.println(Test.i); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output ：</p>
<blockquote>
<p>static block called </p>
<p>10</p>
</blockquote>
<ol start="2">
<li>静态代码块在构造函数之前执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filename: Main.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line">	<span class="keyword">int</span> j; </span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		i = <span class="number">10</span>; </span><br><span class="line">		System.out.println(<span class="string">"static block called "</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	Test()&#123; </span><br><span class="line">		System.out.println(<span class="string">"Constructor called"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Although we have two objects, static block is executed only once. </span></span><br><span class="line">	Test t1 = <span class="keyword">new</span> Test(); </span><br><span class="line">	Test t2 = <span class="keyword">new</span> Test(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>static block called </p>
<p>Constructor called</p>
<p>Constructor called</p>
</blockquote>
<p><strong>静态变量(static variable)</strong> : 静态变量实质上就是全局变量，在该类的所有实例间共享</p>
<ol>
<li>只能在类级别创建静态变量，方法内部创建静态变量编译不通过</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	System.out.println(fun()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x= <span class="number">10</span>; <span class="comment">//Error: Static local variables are not allowed </span></span><br><span class="line">	<span class="keyword">return</span> x--; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>静态代码块和静态变量按照他们在程序中的顺序执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java program to demonstrate execution </span></span><br><span class="line"><span class="comment">// of static blocks and variables </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// static variable </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = m1(); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static block </span></span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		System.out.println(<span class="string">"Inside static block"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"from m1"</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">20</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method(main !!) </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">	System.out.println(<span class="string">"Value of a : "</span>+a); </span><br><span class="line">	System.out.println(<span class="string">"from main"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>from m1</p>
<p>Inside static block</p>
<p>Value of a : 20</p>
<p>“from main</p>
</blockquote>
<p><strong>静态方法(static method)</strong> : 可通过类直接访问</p>
<p>静态方法的一些使用限制：</p>
<ol>
<li>只能直接调用其他的静态方法</li>
<li>只能直接访问静态数据</li>
<li>静态方法里不能引用this和super</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java program to demonstrate(演示) restriction(限制) on static methods </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// static variable </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// instance variable </span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		a = <span class="number">20</span>; </span><br><span class="line">		System.out.println(<span class="string">"from m1"</span>); </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Cannot make a static reference to the non-static field b </span></span><br><span class="line">		b = <span class="number">10</span>; <span class="comment">// compilation error </span></span><br><span class="line">				</span><br><span class="line">		<span class="comment">// Cannot make a static reference to the </span></span><br><span class="line">				<span class="comment">// non-static method m2() from the type Test </span></span><br><span class="line">		m2(); <span class="comment">// compilation error </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Cannot use super in a static context </span></span><br><span class="line">		System.out.println(<span class="keyword">super</span>.a); <span class="comment">// compiler error </span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// instance method </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;	 </span><br><span class="line">		System.out.println(<span class="string">"from m2"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">// main method </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态变量和静态方法的使用</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A java program to demonstrate use of </span></span><br><span class="line"><span class="comment">// static keyword with methods and variables </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student class </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	String name; </span><br><span class="line">	<span class="keyword">int</span> rollNo; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static variable </span></span><br><span class="line">	<span class="keyword">static</span> String cllgName; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static counter to set unique roll no </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.name = name; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.rollNo = setRollNo(); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// getting unique rollNo </span></span><br><span class="line">	<span class="comment">// through static variable(counter) </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setRollNo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		counter++; </span><br><span class="line">		<span class="keyword">return</span> counter; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCllg</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">		cllgName = name ; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// instance method </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getStudentInfo</span><span class="params">()</span></span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"name : "</span> + <span class="keyword">this</span>.name); </span><br><span class="line">		System.out.println(<span class="string">"rollNo : "</span> + <span class="keyword">this</span>.rollNo); </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// accessing static variable </span></span><br><span class="line">		System.out.println(<span class="string">"cllgName : "</span> + cllgName); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//Driver class </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">// calling static method </span></span><br><span class="line">		<span class="comment">// without instantiating Student class </span></span><br><span class="line">		Student.setCllg(<span class="string">"XYZ"</span>); </span><br><span class="line">	</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student(<span class="string">"Alice"</span>); </span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="string">"Bob"</span>); </span><br><span class="line">		</span><br><span class="line">		s1.getStudentInfo(); </span><br><span class="line">		s2.getStudentInfo(); </span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<blockquote>
<p>name : Alice</p>
<p>rollNo : 1</p>
<p>cllgName : XYZ</p>
<p>name : Bob</p>
<p>rollNo : 2</p>
<p>cllgName : XYZ</p>
</blockquote>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/d.jpeg" alt="静态变量内存存储结构"></p>
<p><strong>静态内部类(static inner classes)</strong> ：Java中允许一个类定义在另一个类的内部，称为嵌套类(nested classes)。定义嵌套类的类称为外部类(outer class)。非静态的嵌套类(non-static nested classes)也被称为内部类(inner classes)。内部类也可以是静态的，即为静态内部类(static inner classes)</p>
<p>静态内部类与内部类主要的不同点：</p>
<ol>
<li>静态内部类的实例化不依赖于其外部类的实例</li>
<li>内部类可以访问外部类的静态和非静态成员，而静态内部类只能访问外部类的静态成员</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java program to demonstrate how to </span></span><br><span class="line"><span class="comment">// implement static and non-static </span></span><br><span class="line"><span class="comment">// classes in a Java program. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String msg = <span class="string">"GeeksForGeeks"</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Static nested class </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedStaticClass</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only static members of Outer class </span></span><br><span class="line">		<span class="comment">// is directly accessible in nested </span></span><br><span class="line">		<span class="comment">// static class </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">		</span>&#123; </span><br><span class="line"></span><br><span class="line">			<span class="comment">// Try making 'message' a non-static </span></span><br><span class="line">			<span class="comment">// variable, there will be compiler error </span></span><br><span class="line">			System.out.println( </span><br><span class="line">				<span class="string">"Message from nested static class: "</span></span><br><span class="line">				+ msg); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Non-static nested class - </span></span><br><span class="line">	<span class="comment">// also called Inner class </span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Both static and non-static members </span></span><br><span class="line">		<span class="comment">// of Outer class are accessible in </span></span><br><span class="line">		<span class="comment">// this Inner class </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">		</span>&#123; </span><br><span class="line">			System.out.println( </span><br><span class="line">				<span class="string">"Message from non-static nested class: "</span></span><br><span class="line">				+ msg); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="comment">// How to create instance of static </span></span><br><span class="line">	<span class="comment">// and non static nested class? </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create instance of nested Static class </span></span><br><span class="line">		OuterClass.NestedStaticClass printer </span><br><span class="line">			= <span class="keyword">new</span> OuterClass.NestedStaticClass(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Call non static method of nested </span></span><br><span class="line">		<span class="comment">// static class </span></span><br><span class="line">		printer.printMessage(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// In order to create instance of </span></span><br><span class="line">		<span class="comment">// Inner class we need an Outer class </span></span><br><span class="line">		<span class="comment">// instance. Let us create Outer class </span></span><br><span class="line">		<span class="comment">// instance for creating </span></span><br><span class="line">		<span class="comment">// non-static nested class </span></span><br><span class="line">		OuterClass outer = <span class="keyword">new</span> OuterClass(); </span><br><span class="line">		OuterClass.InnerClass inner </span><br><span class="line">			= outer.<span class="keyword">new</span> InnerClass(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Calling non-static method of Inner class </span></span><br><span class="line">		inner.display(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// We can also combine above steps in one </span></span><br><span class="line">		<span class="comment">// step to create instance of Inner class </span></span><br><span class="line">		OuterClass.InnerClass innerObject </span><br><span class="line">			= <span class="keyword">new</span> OuterClass().<span class="keyword">new</span> InnerClass(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Similarly we can now call Inner class method </span></span><br><span class="line">		innerObject.display(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>按值调用 （call by value) 表示方法接收的是调用者提供的值。而按引用调用 （ call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<p>Java 程序设计语言总是采用按值调用。也就是说， 方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<p>方法参数共有两种类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用（按值传递的）</li>
</ul>
<p>基本数据类型传的是值的拷贝，但是对象引用传的是引用地址的拷贝，也就是参数对象和原对象指向同一个地址，即引用的是同一个对象。</p>
<p>证明对象引用是按值传递的典型例子(交换对象)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x,Employee y)</span></span>&#123;</span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee a = <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>);</span><br><span class="line">Employee b = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line">swap(a,b);</span><br><span class="line"><span class="comment">//方法并没有改变存储在变量 a 和 b 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</span></span><br><span class="line"><span class="comment">//x refers to Alice ,y to Bob</span></span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line"><span class="comment">//now x refers to Bob, y to Alice</span></span><br><span class="line"><span class="comment">//但是方法结束时x和y就被丢弃了，a和b引用并没有变</span></span><br></pre></td></tr></table></figure>

<p>下面总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数</li>
<li>一个方法可以改变一个对象参数的状态（对象引用的拷贝与原对象指向同一个对象，当拷贝改变对象内容时，原对象也会就跟随改变了）</li>
<li>一个方法不能让对象参数引用一个新的对象（不能改变原引用的指向）</li>
</ul>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p><strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p>
<p>Java 允许重载任何方法， 而不只是构造器方法。因此，要完整地描述一个法，需要指出方法名以及参数类型。这叫做<strong>方法的签名（signature)</strong>。例如， String 类有 4 个称为 indexOf 的公有方法。它们的签名是</p>
<ul>
<li>indexOf(int)</li>
<li>indexOf(int,int)</li>
<li>indexOf(String)</li>
<li>indexOf(String,int)</li>
</ul>
<p><strong>返回类型不是方法签名的一部分。也就是说， 不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。</strong></p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>重载与重写的区别</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类中</td>
<td>子类中</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以减少或删除，一定不能抛出新的异常或更广的异常</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>范围大于等于父类</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h4 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h4><p>如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是， 实例域中的数值型数据设置为 0、 布尔型数据设置为 false、 所有对象变量将设置为 null。</p>
<p><strong>如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。</strong></p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>初始化属性的方法：</p>
<ul>
<li>构造器中设置值</li>
<li>声明时赋值</li>
</ul>
<p>初始化块也可以执行初始化，但不常用。<strong>首先运行初始化块在运行构造器。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//object initialization block</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0、false 或 null)</li>
<li>按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static initialization block</span></span><br><span class="line"><span class="comment">//在类第一次加载的时候， 将会进行静态域的初始化。</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">    nextId = generator.nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象析构与finalize方法"><a href="#对象析构与finalize方法" class="headerlink" title="对象析构与finalize方法"></a>对象析构与finalize方法</h4><p>因为Java有自动的垃圾回收机制，所以Java不支持析构器。但是存在某些对象使用了内存之外的其他资源， 例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时， 将其回收和再利用将显得十分重要。</p>
<p>可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个方法什么时候才能够调用。</p>
<p>有个名为<code>System.mnFinalizersOnExit(true)</code>的方法能够确保 finalizer 方法在 Java 关闭前被调用。不过，这个方法并不安全，也不鼓励大家使用。有一种代替的方法是使用方法<code>Runtime.addShutdownHook</code> 添加”关闭钩子”（shutdown hook),</p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><p>类路径所列出的目录和归档文件是搜寻类的起始点。下面看一个类路径示例：<br>/home/user/classdir:.:/home/user/archives/archive.jar</p>
<p>假定虚拟机要搜寻 com.horstmann.corejava.Employee 类文件。它首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找以下文件：</p>
<ul>
<li>/home/user/classdir/com/horstmann/corejava/Employee.class</li>
<li>com/horstmann/corejava/Employee.class 从当前目录开始</li>
<li>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</li>
</ul>
<p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并查询所有的 import 指令，确定其中是否包含了被引用的类。例如， 假定源文件包含指令：</p>
<p>import java.util.<em>;<br>import com.horstmann.corejava.</em>;</p>
<p>并且源代码引用了 Employee 类。 编译器将试图查找 java.lang.Employee (因为java.lang 包被默认导入）、java.util.Employee、 com.horstmann.corejava.Employee 和当前包中的 Employee。</p>
<p>对这个类路径的所有位置中所列出的每一个类进行逐一查看。如果找到了一个以上的类， 就会产生编译错误（因为类必须是唯一的，而 import 语句的次序却无关紧要）。</p>
<h4 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h4><p>最好采用 -classpath (或 -cp) 选项指定类路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -classpath /home/user/classdir:.:/home/user/archives/archives MyProg</span><br></pre></td></tr></table></figure>

<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol>
<li><p>一定要保证数据私有</p>
</li>
<li><p>一定要对数据初始化</p>
</li>
<li><p>不要在类中使用过多的基本类型</p>
</li>
<li><p>不是所有的域都需要独立的域访问器和域更改器</p>
</li>
<li><p>将职责过多的类进行分解</p>
</li>
<li><p>类名和方法名要能够体现它们的职责</p>
</li>
<li><p>优先使用不可变的类</p>
</li>
</ol>
<h2 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h2><h3 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><h4 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name,<span class="keyword">double</span> salary,<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">    bonus=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 super 实现对超类构造器的调用。使用super 调用构造器的语句必须是子类构造器的第一条语句。</p>
<p>如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在 Java 程序设计语言中，对象变量是多态的。 一个 Employee 变量既可以引用一个Employee 类对象， 也可以引用一个 Employee 类的任何一个子类的对象（例如， Manager、Executive、Secretary 等）。</p>
<p>一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为<strong>多态（ polymorphism)</strong>。<br>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定（ dynamic binding）</strong>。</p>
<h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><p>以 <strong>x.f(args)，隐式参数 x 声明为类 C 的一个对象</strong> 为例，分析方法调用如下：</p>
<ol>
<li>编译器査看对象的声明类型和方法名。假设调用 x.f(param)， 且隐式参数 x 声明为 C类的对象。需要注意的是：有可能存在多个名字为 f, 但参数类型不一样的方法。例如，可能存在方法 f(int) 和方法 f(String)。 编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）</li>
<li>接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重栽解析（ overloading resolution)。</li>
<li>如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding )。 与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。在我们列举的示例中， 编译器采用动态绑定的方式生成一条调用 f(String) 的指令。</li>
<li>当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了方法 f(String)， 就直接调用它；否则， 将在 D 类的超类中寻找 f(String)， 以此类推。</li>
</ol>
<p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。在前面的例子中， 虚拟机搜索 D 类的方法表， 以便寻找与调用 f(Sting) 相匹配的方法。这个方法既有可能是 D.f(String), 也有可能是X.f(String), 这里的 X 是 D 的超类。这里需要提醒一点，如果调用 super.f(param), 编译器将对隐式参数超类的方法表进行搜索。</p>
<p>简化后：</p>
<ol>
<li>虚拟机查询出所有x的声明类型及方法名为f的方法（利用方法表）</li>
<li>虚拟机根据x的实际类型以及调用参数确定最终调用的方法（利用运行时动态绑定）</li>
<li>调用方法</li>
</ol>
<h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h4><p>不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。final类中只有其中的方法自动地成为 final,而不包括域。</p>
<p>在早期的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。这是一项很有意义的改进， 这是由于 CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而，如果 getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。<br>幸运的是， 虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、 被频繁调用且没有真正地被覆盖， 那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖， 那么将会发生什么情况呢？ 优化器将取消对覆盖方法的内联。这个过程很慢， 但却很少发生。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>将一个类型强制转换成另外一个类型的过程被称为类型转换。</p>
<p>将一个子类的引用赋给一个超类变量， 编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行类型转换，一个好的设计习惯是在进行类型转换之前，先查看一下是否能够成功地转换（避免抛出ClassCastException异常）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager boss = <span class="keyword">null</span>;</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[]&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager)&#123;</span><br><span class="line">    boss = (Manager)staff[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类不能被实例化。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractPerson</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>如果希望超类中的某些方法允许被子类访问， 或允许子类的方法访问超类的某个域。可以将这些方法或域声明为 protected。protected修饰的属性或方法只允许在本类及子类中访问，在其他类中无法访问。典型示例就是Object 类中的 clone 方法。</p>
<h3 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h3><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>Java 语言规范要求 equals 方法具有下面的特性：</p>
<ol>
<li>自反性：对于任何非空引用 x, x.equals(x) 应该返回 true</li>
<li>对称性：对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true , x.equals(y) 也应该返回 true</li>
<li>传递性：对于任何引用 x、 y 和 z, 如果 x.equals(y) 返回 true， y.equals(z) 返回 true,x.equals(z) 也应该返回 true。</li>
<li>一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果</li>
<li>对于任意非空引用 x, x.equals(null) 应该返回 false,</li>
</ol>
<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>编写一个完美equals方法的建议：</p>
<ol>
<li>显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。</li>
<li>检测 this 与 otherObject 是否引用同一个对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将 otherObject 转换为相应的类类型变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName other = (ClassName)otherObject;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>现在开始对所有需要比较的域进行比较了。使用 =比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1 &amp;&amp; Objects.equals(field1,field2) &amp;&amp; ...;</span><br></pre></td></tr></table></figure>



<p>注意：如果在子类中重新定义 equals, 就要在其中包含调用 super.equals(other)。</p>
<h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><p>如果重新定义 equals方法，就必须重新定义 hashCode 方法。Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值。</p>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>强烈建议为自定义的每一个类增加 toString 方法。</p>
<h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到固定的对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line">a = <span class="number">1000</span>;</span><br><span class="line">b = <span class="number">1000</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：装箱和拆箱是编译器的行为，而不是虚拟机的行为。编译器在生成类的字节码时， 插人必要的方法调用。虚拟机只是执行这些字节码。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size&#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>),MEDIUM(<span class="string">"M"</span>),LARGE(<span class="string">"L"</span>),EXTRA_LARGE(<span class="string">"XL"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String abbr;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbr)</span> </span>&#123; <span class="keyword">this</span>.abbr = abbr;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.abbr;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上， 这个声明定义的类型是一个类， 它刚好有 4 个实例， 在此尽量不要构造新对象。因此， 在比较两个枚举类型的值时， 永远不需要调用 equals, 而直接使用“= =” 就可以了</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序称为<strong>反射（reflective )</strong>。</p>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>获取Class类对象的三种方式（eg：Employee  e）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">Class c = e.getClass();</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.bean.Employee"</span>);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">Class c = Employee<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>虚拟机为每个类型管理一个 Class 对象。 因此，可以利用 == 运算符实现两个类对象比较的操作。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.getClass() == Employee<span class="class">.<span class="keyword">class</span>) ...</span></span><br></pre></td></tr></table></figure>

<p>还有一个很有用的方法 newlnstance( )， 可以用来动态地创建一个类的实例。newlnstance方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常 。</p>
<h4 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h4><p>Class类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的public 域、 方法和构造器数组， 其中包括超类的公有成员。Class 类的 getDeclareFields、getDeclareMethods 和getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。</p>
<p>API如下：</p>
<p><code>java.lang.Class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回本类及父类中所有public属性，如果没有满足条件的将返回长度为0的数组（以下几种情况均适用）</span></span><br><span class="line">Field[] getFields();</span><br><span class="line"><span class="comment">//只返回本类中的全部属性</span></span><br><span class="line">Field[] getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回本类及父类或者父接口中所有public的方法</span></span><br><span class="line">Method[] getMethods();</span><br><span class="line"><span class="comment">//只返回本类中所有的方法</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回本类中所有public的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] getConstructors();</span><br><span class="line"><span class="comment">//返回本类中所有的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Field</code>、<code>java.lang.reflect.Method</code>、<code>java.lang.reflect.Constructor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返冋一个用于描述类中定义的构造器、 方法或域的 Class 对象。</span></span><br><span class="line">Class&lt;?&gt; getDeclaringClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述构造器、 方法或域的修饰符的整型数值。使用 Modifier 类中的方法可以分析这个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返冋一个用于描述构造器、 方法、属性的名字。</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述方法抛出的异常类型的 Class 对象数组（只在Method和Constructor中存在）</span></span><br><span class="line">Class&lt;?&gt;[] getExceptionTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述参数类型的 Class 对象数组（只在Method和Constructor中存在）</span></span><br><span class="line">Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述返H类型的 Class 对象(只在Method中存在)</span></span><br><span class="line">Class&lt;?&gt; getReturnType();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Modifier</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回对应 modifiers 中位设置的修饰符的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测修饰符中是否含有相应的修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPublic</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrivate</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProtected</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFinal</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSynchronized</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="运行时使用反射分析对象"><a href="#运行时使用反射分析对象" class="headerlink" title="运行时使用反射分析对象"></a>运行时使用反射分析对象</h4><p>通过反射获取属性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name属性为private的</span></span><br><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>);</span><br><span class="line"><span class="comment">//1.获取实例对象所属的类</span></span><br><span class="line">Class cl = harry.getClass();</span><br><span class="line"><span class="comment">//2.获取类的name属性信息</span></span><br><span class="line">Field f = cl.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//设置访问权限</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//3.通过unsafe获取对象中该属性的值，如果属性类型是基础类型，反射机制将会自动地将这个域值打包到相应的对象包装器中，比如double =&gt; Double</span></span><br><span class="line">Object v = f.get(harry);</span><br></pre></td></tr></table></figure>

<p>另外，反射机制的默认行为受限于 Java 的访问控制。所以需要通过<code>f.setAccessible(true)</code>将属性、方法或者构造器设置成可访问的。</p>
<h4 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span>(!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType,newLength);</span><br><span class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:这个 CopyOf 方法可以用来扩展任意类型的数组， 而不仅是对象数组。因为基础类型数组比如int[] 可以被转换成Object，而不能被转成Object[]。</p>
<h4 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h4><ol>
<li>先获取Method对象<code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>，比如<code>Math.class.getMethod(&quot;sqrt&quot;,double.class)</code></li>
<li>调用方法<code>Object invoke(Object obj, Object... args)</code>，比如<code>f.invoke(harry,35000)</code>，如果调用的是静态方法，obj参数设置成null即可</li>
</ol>
<h2 id="6-接口、内部类、lambda表达式"><a href="#6-接口、内部类、lambda表达式" class="headerlink" title="6. 接口、内部类、lambda表达式"></a>6. 接口、内部类、lambda表达式</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>在 Java 程序设计语言中， 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<p>接口中的所有方法自动地属于 public。 因此，在接口中声明方法时，不必提供关键字public 。</p>
<p><code>java.util.Arrays</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了Comparable 接口的类， 并且元素之间必须是可比较的。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h4><p>在接口中不能包含实例域或静态方法，但却可以包含常量。</p>
<p>与接口中的方法都自动地被设置为 public—样，接口中的域将被自动设为 public static final。</p>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在 Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">get</span><span class="params">(String first,String... more)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystems.getDefault().getPath(first,more);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个默认实现。 必须用<code>default</code> 修饰符标记这样一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>规则如下：</p>
<ol>
<li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会<br>被忽略。</li>
<li>接口冲突。 如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法， 必须覆盖这个方法来解决冲突。</li>
</ol>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>Java8之后该接口进行了增强（结合lambda表达式）</p>
<p>典型示例：<code>Arrays.sort(T[],Comparator)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>默认的克隆操作是“ 浅拷贝”，并没有克隆对象中引用的其他对象。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类（ inner class) 是定义在另一个类中的类。内部类解决的需求有以下三点：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较<br>便捷。</li>
</ol>
<h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>创建内部类实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outerObject.<span class="keyword">new</span> InnerClass(construction parameters);</span><br></pre></td></tr></table></figure>

<p>在外围类的作用域之外，可以这样引用内部类：<code>OuterClass.InnerClass</code>。内部类中声明的所有静态域都必须是 final。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于构造器的名字必须与类名相同， 而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类（ superclass) 构造器。尤其是在内部类实现接口的时候， 不能有任何构造参数。</p>
<p><strong>双括号初始化</strong>：利用了内部类的语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">friends.add(<span class="string">"Harry"</span>);</span><br><span class="line">friends.add(<span class="string">"Tony"</span>);</span><br><span class="line">invite(friends);</span><br><span class="line"></span><br><span class="line"><span class="comment">//双括号初始化法表示</span></span><br><span class="line"><span class="comment">//注意这里的双括号。外层括号建立了 ArrayList 的一个匿名子类。内层括号则是一个对象构造块</span></span><br><span class="line">invite(<span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123; add(<span class="string">"Harry"</span>); add(<span class="string">"Tony"</span>);&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>获取当前类的类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过this.getClass()方法获取，但对于静态方法不奏效</span></span><br><span class="line">Systen.err.println(<span class="string">"Something awful happened in "</span> + getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法使用</span></span><br><span class="line"><span class="comment">//newObject()&#123;&#125; 会建立 Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类， 也就是包含这个静态方法的类。</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;&#125;.getCIass().getEndosingClass(); <span class="comment">// gets class of static method</span></span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>当内部类不需要引用外部类的对象，只是为了把一个类藏到另一个类的内部，此时可以将内部类声明为<code>static</code>，以便取消产生的引用，该内部类即静态内部类。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>在内部类不需要访问外围类对象的时候， 应该使用静态内部类。</li>
<li>与常规内部类不同，静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类。</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>通过Proxy 类的 newProxylnstance 方法，三个参数：</p>
<ul>
<li>一个类加栽器（class loader）</li>
<li>一个 Class 对象数组， 每个元素都是需要实现的接口</li>
<li>一个调用处理器（invocation  handler）</li>
</ul>
<p>调用处理器是实现了InvocationHandler接口的类对象，这个接口只有一个方法<code>public Object invoke(Object proxy, Method method, Object[] args)</code>，无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用， 并向其传递Method 对象和原始的调用参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            Integer value = i + <span class="number">1</span>;</span><br><span class="line">            InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(<span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;Comparable<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">handler</span>)</span>;</span><br><span class="line">            elements[i] = proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer key = <span class="keyword">new</span> Random().nextInt(elements.length) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分查找通过元素的compareTo方法与key进行比较,int cmp = midVal.compareTo(key);</span></span><br><span class="line">        <span class="keyword">int</span> result = Arrays.binarySearch(elements, key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) System.out.println(elements[result]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TraceHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.print(target);</span><br><span class="line">            System.out.print(<span class="string">"."</span> + method.getName() + <span class="string">"("</span>);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    System.out.print(args[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; args.length - <span class="number">1</span>) System.out.print(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h4><p>所有的代理类都扩展于 Proxy 类。一个代理类只有一个实例域—调用处理器，它定义在 Proxy 类中。</p>
<p>没有定义代理类的名字，Sun 虚拟机中的 Proxy类将生成一个以字符串 $Proxy 开头的类名。对于特定的类加载器和预设的一组接口来说，只能有一个代理类。 也就是说，如果使用同一个类加载器和接口数组调用两次newProxylustance方法的话， 那么只能够得到同一个类的两个对象。</p>
<p><code>API</code></p>
<p><code>java.lang.reflect.InvocationHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了代理对象调用方法时希望执行的动作</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Proxy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回实现指定接口的代理类</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,</span><br><span class="line">                                         Class&lt;?&gt;... interfaces);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造实现指定接口的代理类的一个新实例。</span></span><br><span class="line"><span class="comment">//所有代理对象的方法调用都会调用给定处理器对象的 invoke 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span>;</span><br><span class="line"><span class="comment">//判断类是否是代理类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Github搭建个人博客</title>
    <url>/2020/03/27/hexo-hexo-github/</url>
    <content><![CDATA[<p>Hexo + Github 搭建个人博客填坑记。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ol>
<li><strong>Node.js</strong> （Hexo官网建议版本最好在10.0以上）</li>
</ol>
<p>没装过Node的话直接去 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a> 官网下载安装就可以，由于我本地之前装过，但是版本较低需要升级下，这里介绍升级方法，步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. npm -v 查看npm版本</span><br><span class="line">2. sudo npm i -g npm 执行npm -v之后系统提示的升级npm命令，-g表示全局安装</span><br><span class="line">3. sudo npm install -g n 安装n模块，n模块是专门用来管理nodejs版本的。</span><br><span class="line">4. sudo n stable 升级nodejs到目前最新的稳定版本</span><br><span class="line">5. node -v 查看node版本</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Github账号</strong></li>
</ol>
<p><a href="https://github.com/" target="_blank" rel="noopener">官网</a> 注册即可</p>
<ol start="3">
<li><strong>本地Git环境</strong></li>
</ol>
<ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a></li>
<li>Mac：Homebrew安装简洁方便</li>
<li>Linux（Ubuntu、Debian）：sudo apt-get install git-core</li>
<li>Linux（Fedora、Redhat、CentOS）：sudo yum install git-core</li>
</ul>
<a id="more"></a>

<ol start="4">
<li><strong>Hexo</strong></li>
</ol>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官网地址</a> 官网已经很全面，建议遇到问题多多查询官方文档。</p>
<p>Node.js安装好之后，直接用npm进行安装，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>顺便记录两个问题：</p>
<ul>
<li>Problem 1</li>
</ul>
<p>由于我之前已经安装过hexo，并且已经初始化过目录，中间隔了很久没有写博客（期间保存在MEGA上）当再次进入到该目录下执行hexo命令时报错（<u>注: 只有在之前初始化过的目录执行hexo相关命令才会报错，除了此目录之外的其他目录执行<code>hexo version</code>、<code>hexo init folder</code>等都没问题，也就是hexo本身没问题</u>），错误信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found in xxx</span><br><span class="line">ERROR Try running:&#39;npm install hexo --save&#39;</span><br></pre></td></tr></table></figure>

<p>解决方案<code>rm -rf node_modules/ &amp;&amp; npm install</code> 源自<a href="https://github.com/hexojs/hexo/issues/2076#issuecomment-273472704" target="_blank" rel="noopener">issue</a></p>
<ul>
<li>Problem 2</li>
</ul>
<p>问题一解决之后，进行生成静态网页并启动本地服务器，再次报错如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/hexo_replaceofnull_error.png" alt="hexo_replaceofnull_error"></p>
<p>产生这个问题的大部分原因是由于你的配置文件包括根目录配置、主题配置文件和你的markdown文件不匹配造成的。我的原因是因为我在配置文件里多写了两个插件：统计字数（symbols_count_time）和本地搜索（search）而没有进行安装造成的</p>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init [folder]  	//初始化工作目录</span><br></pre></td></tr></table></figure>

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new  &lt;layout&gt; [--path] "标题名"  //新建</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
<p>post布局用来创建文章，–path选项还可以是其他的选项，如–replace，详细内容参见官网</p>
<ul>
<li>创建默认路径的文章</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "article"</span><br></pre></td></tr></table></figure>

<p>文件路径：<code>source/_posts/article.md</code>,同时<code>article.md</code>的 Front Matter 中的 title 为 <code>article</code></p>
<ul>
<li>创建指定路径的文章</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post --path book/mysql/Chapter-One "第一章"</span><br></pre></td></tr></table></figure>

<p>文件路径：<code>source/_posts/book/mysql/Chapter-One.md</code>，同时<code>Chapter-One.md</code>的Front Matter中的title 为<code>第一章</code>。该方式用来分层管理本地文章很实用。</p>
<p>page布局用来创建分类、归档、关于等类别</p>
<ul>
<li>创建标签</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>执行此命令后，会创建文件<code>source/tags/index.md</code> ，修改index.md文件添加type属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-10-17 14:21:33</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p><em>注意： type冒号后面一定要留出一个空格，这样菜单页标签才生效，分类、归档等都是一样的方式</em></p>
<ul>
<li>创建分类</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>执行此命令后，会创建文件<code>source/categories/index.md</code> ，修改index.md文件添加type属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: 文章分类</span><br><span class="line">date: 2019-10-17 14:22:55</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<ul>
<li>创建归档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page archives</span><br></pre></td></tr></table></figure>

<p>执行此命令后，会创建文件<code>source/archives/index.md</code> ，修改index.md文件添加type属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: 归档</span><br><span class="line">date: 2019-10-17 14:23:15</span><br><span class="line">type: "archives"</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<ul>
<li>创建关于</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>执行此命令后，会创建文件<code>source/about/index.md</code> ，修改index.md文件添加type属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: about</span><br><span class="line">date: 2019-10-17 14:24:24</span><br><span class="line">type: "about"</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;		//发表草稿</span><br></pre></td></tr></table></figure>

<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate		//生成静态文件</span><br></pre></td></tr></table></figure>

<p>简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>生成的静态文件都在<code>public</code>目录下</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server		//启动本地服务器</span><br></pre></td></tr></table></figure>

<p>简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>默认访问网址：<code>http://localhost:4000/</code></p>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy		//部署到github</span><br></pre></td></tr></table></figure>

<p>简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean		//清除缓存文件(db.json)和已生成的静态文件(public)</span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo list &lt;type&gt;		//列出网站资料</span><br></pre></td></tr></table></figure>

<p>type可取值：<code>page</code>、<code>post</code>、<code>route</code>、<code>tag</code>、<code>category</code></p>
<p>比如想查看本地文章列表可执行：<code>hexo list post</code></p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo version		//查看hexo版本</span><br></pre></td></tr></table></figure>

<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo --debug		//调试模式</span><br></pre></td></tr></table></figure>

<h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 		//快速生成静态文件并启动本地服务器</span><br></pre></td></tr></table></figure>

<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数</td>
<td align="left">描述</td>
<td align="left">默认值</td>
</tr>
<tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
<td align="left">文章的文件名</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">建立日期</td>
<td align="left">文件建立日期</td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left">更新日期</td>
<td align="left">文件更新日期</td>
</tr>
<tr>
<td align="left"><code>comments</code></td>
<td align="left">开启文章的评论功能</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">标签（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="left">分类（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">覆盖文章网址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>分类具有顺序性和层次性，标签没有，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary,PlayStation]</span><br><span class="line">- [Diary,Games]</span><br><span class="line">- [Life]</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>

<p>这篇文章包含三个分类和两个标签：</p>
<p><code>PlatStation</code>和<code>Games</code>是子分类，父分类为<code>Diary</code>，<code>Life</code>是没有子分类的分类 </p>
<p><code>PS3</code>和<code>Games</code>是没有顺序和层次性的标签</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Hexo支持非常多的主题，可在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 随意查找</p>
<p>Next主题官网地址：<a href="https://theme-next.org/docs/" target="_blank" rel="noopener">https://theme-next.org/docs/</a></p>
<p>两个配置文件：</p>
<ol>
<li><p><code>hexo init &lt;folder&gt;</code>这个folder是根目录下的_config.yml 就是<strong>根目录配置文件</strong></p>
</li>
<li><p><code>根目录/themes/next/_config.yml</code>是<strong>主题配置文件</strong></p>
</li>
</ol>
<h3 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h3><p>在根目录下执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>然后在根配置文件中搜索<code>theme</code>，将其值修改为 <code>next</code>即可。</p>
<p>主题配置可参考所使用的具体主题的文档。</p>
<h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>Next支持很多评论系统，主题配置文件注释中有写 Available values: changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte，我集成的disqus（需要翻墙），国内可以采用valine，也很不错。</p>
<p>具体配置可参考 <a href="http://www.cylong.com/blog/2017/03/26/hexo-next-disqus/" target="_blank" rel="noopener">Hexo集成Disqus评论</a></p>
<h3 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h3><p>主题配置文件中搜索<code>scroll_to_more</code>，将其设置为<code>true</code>，如果没有搜到，直接将下面的配置拷贝粘贴到主题配置文件中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后在文章插入<code>&lt;!-- more --&gt;</code>，之后的文章内容将被隐藏，并在首页列表显示<code>阅读全文</code></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Hexo支持非常多的插件，插件地址：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a></p>
<h3 id="symbols-count-time"><a href="#symbols-count-time" class="headerlink" title="symbols-count-time"></a>symbols-count-time</h3><p>用于统计文章字数及推荐阅读时长</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>然后在根目录配置文件进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>重启服务生效。详情参考<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">symbols_count_time</a></p>
<h3 id="generator-searchdb"><a href="#generator-searchdb" class="headerlink" title="generator-searchdb"></a>generator-searchdb</h3><p>该插件可以生成一个包含你所有文章的索引文件，可以快速检索你发布过的文章。其实就是个本地搜索引擎。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>然后在根目录配置文件进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>重启服务生效。详情参考<a href="https://github.com/theme-next/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a></p>
<h2 id="Hexo原理"><a href="#Hexo原理" class="headerlink" title="Hexo原理"></a>Hexo原理</h2><p>Hexo 基于模板引擎实现Markdown文件到html网页的转换，根目录下source文件夹下的md文件就是数据，themes目录下的swig文件就是页面布局，然后swig模板引擎进行页面的生成。</p>
<p>原理参考 <a href="http://dinghongkai.com/2017/12/18/Blog-development-3-Know-Hexo/" target="_blank" rel="noopener">深入理解Hexo</a></p>
<p>swig语法参考 <a href="https://www.jianshu.com/p/c5d333e6353c" target="_blank" rel="noopener">swig语法介绍</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解驱动</title>
    <url>/2020/03/27/spring-Spring-Annotation/</url>
    <content><![CDATA[<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>用于标注配置类</p>
<a id="more"></a>

<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>用于组件扫描，常用属性如下：</p>
<ul>
<li><p>String[]  value() default {}:指定要扫描的包，实际上是basePackages的别名</p>
</li>
<li><p>String[]  basePackages() default {}:指定要扫描的包</p>
</li>
<li><p>boolean useDefaultFilters() default true:表示将会自动检测标注@Component、@Repository、@Service、@Controller的类</p>
</li>
<li><p>Filter[] includeFilters() default {}:除了useDefaultFilters指定的之外，满足指定过滤器规则的类也将被扫描</p>
</li>
<li><p>Filter[] excludeFilters() default {}:指定哪些类型不进行扫描</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.zhengguoqiang"</span>,excludeFilters = &#123;</span><br><span class="line">				<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller<span class="class">.<span class="keyword">class</span>,<span class="title">Service</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>类型过滤器的枚举值：</p>
<p>FilterType.ANNOTATION：基于注解</p>
<p>FilterType.ASSIGNABLE_TYPE：基于给定的类型</p>
<p>FilterType.ASPECTJ：基于Aspectj表达式</p>
<p>FilterType.REGEX：基于正则表达式</p>
<p>FilterType.CUSTOM：自定义规则，需要实现org.springframework.core.type.filter.TypeFilter接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(includeFilters = &#123;</span><br><span class="line">				<span class="meta">@ComponentScan</span>.Filter(classes = &#123;Controller<span class="class">.<span class="keyword">class</span>,<span class="title">Service</span>.<span class="title">class</span>&#125;), //<span class="title">type</span>默认<span class="title">FilterType</span>.<span class="title">ANNOTATION</span></span></span><br><span class="line"><span class="class">				@<span class="title">ComponentScan</span>.<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.ASSIGNABLE_TYPE，classes = &#123;BookService<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">    			@<span class="title">ComponentScan</span>.<span class="title">Filter</span>(<span class="title">type</span></span>=FilterType.CUSTOM,classes = &#123;MyTypeFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">&#125;,<span class="title">useDefaultFilters</span> </span>= <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReader 当前目标类的类元数据信息Reader类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReaderFactory 获取指定类的元数据信息Reader类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前目标类的注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//获取当前目标类的类信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        System.out.println(<span class="string">"----&gt; "</span> + className);</span><br><span class="line">        <span class="keyword">if</span> (className.contains(<span class="string">"er"</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Repeatable(ComponentScans.class)：可重复注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScans</span>(value = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>(value = <span class="string">"com.zhengguoqiang"</span>,includeFilters = &#123;</span><br><span class="line">                <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">        &#125;,<span class="title">useDefaultFilters</span> </span>= <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><p>用于设置Bean的作用域</p>
<ul>
<li>singleton：默认值，单实例，容器启动的时候创建bean注入到ioc容器中</li>
<li>prototype：多实例，获取实例时才创建bean，且每次获取都创建一个新的实例</li>
<li>request：同一个请求创建一个实例</li>
<li>session：同一个session创建一个实例</li>
</ul>
<h4 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h4><p>用于设置懒加载，只在singleton作用域下使用，设置为true表示容器启动的时候不创建bean，只有在获取bean时才创建Bean并将其注入到ioc容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"singleton"</span>)</span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Person inited"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"wangwu"</span>,<span class="number">25</span>,<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>当所有的条件满足时，Bean才会注入到ioc容器中；作用在方法或者类上</p>
<ul>
<li>Class&lt;? extends Condition&gt;[] value()：自定义条件需要实现org.springframework.context.annotation.Condition接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conditional</span>(MacCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@Bean("mac")</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">linus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Qiao"</span>,<span class="number">59</span>,<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">        <span class="comment">//2.获取类加载器</span></span><br><span class="line">        ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">        <span class="comment">//3.获取当前应用的环境变量</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">//4.获取bean的注册信息</span></span><br><span class="line">        BeanDefinitionRegistry registry = context.getRegistry();</span><br><span class="line"></span><br><span class="line">        String property = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="keyword">assert</span> property != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> property.contains(<span class="string">"Mac"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>用于快速向容器中注入组件</p>
<p>容器中注入组件的几种方式：</p>
<ol>
<li>包扫描 + 标注组件注解（@Controller、@Service）：适用于自己定义的组件</li>
<li>@Bean：适用于第三方导入的组件</li>
<li>@Import：快速导入组件，直接应用在配置类（@Configuration）<ul>
<li>@Import({A.class,B.class})：快速注入A组件和B组件，id默认组件全类名</li>
<li>@Import({XXImportSelector.class})：需要实现ImportSelector接口，返回需要注册到容器中的组件全类名数组（SpringBoot中常用）</li>
<li>@Import({XXImportBeanDefinitionRegistrar.class})：需要实现ImportBeanDefinitionRegistrar接口，重写registerBeanDefinitions方法，通过BeanDefinitionRegistry.registerBeanDefinition方法将Bean注入到容器中</li>
</ul>
</li>
<li>使用Spring提供的FactoryBean（工厂Bean）<ul>
<li>实现org.springframework.beans.factory.FactoryBean接口，实现getObject和getObjectType方法</li>
<li>默认注册到容器中的是工厂Bean调用getObject方法得到的组件</li>
<li>要想获得工厂Bean本身，需要在id前面加一个&amp;，如<code>applicationContext.getBean(&quot;&amp;colorFactoryBean&quot;)</code></li>
</ul>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>Bean的生命周期</strong>：就是Bean的创建、初始化、销毁的过程。</p>
<p><strong>容器管理Bean的生命周期</strong>：我们可以自定义初始化和销毁方法，容器在Bean进行到当前生命周期时调用自定义的初始化和销毁方法。</p>
<p><strong>构造对象</strong>：</p>
<ul>
<li>单实例：容器启动的时候创建</li>
<li>多实例：每次获取的时候创建</li>
</ul>
<p><strong>初始化</strong>：对象创建完成，并将属性赋值完成后执行初始化方法</p>
<p><strong>销毁</strong>：</p>
<ul>
<li>单实例：容器关闭的时候销毁</li>
<li>多实例：容器不会管理Bean的销毁，需要自己手动销毁</li>
</ul>
<h4 id="实现Bean的初始化和销毁的几种方式："><a href="#实现Bean的初始化和销毁的几种方式：" class="headerlink" title="实现Bean的初始化和销毁的几种方式："></a>实现Bean的初始化和销毁的几种方式：</h4><ol>
<li><p>指定初始化和销毁方法</p>
<p>@Bean注解指定init-method=””,destroy-method=””(与xml配置文件里指定的方式一样)</p>
</li>
<li><p>Bean实现InitializingBean接口定义初始化逻辑，实现DisposableBean接口定义销毁逻辑</p>
<p>InitializingBean接口的afterPropertiesSet方法在Bean创建完成，且属性赋值和BeanFactoryAware、ApplicationContextAware执行完毕后在执行初始化逻辑</p>
</li>
<li><p>JSR250规范（javax.annotation）</p>
<p>@PostConstruct：在Bean创建完成并且属性赋值完毕后执行初始化方法</p>
<p>@PreDestroy：在容器销毁Bean之前通知我们进行清理工作</p>
<blockquote>
<p>注：Java EE在java 9中已经被废弃，在java 11中被移除，所以要想使用需要单独引入javax.annotation依赖</p>
</blockquote>
</li>
<li><p>BeanPostProcessor后置处理器</p>
<p>postProcessBeforeInitialization：在初始化（InitializingBean’s afterPropertiesSet || a custom init-method）之前执行</p>
<p>postProcessAfterInitialization：在初始化（InitializingBean’s afterPropertiesSet || a custom init-method）之后执行</p>
</li>
</ol>
<h4 id="BeanPostProcessor原理"><a href="#BeanPostProcessor原理" class="headerlink" title="BeanPostProcessor原理"></a>BeanPostProcessor原理</h4><ol>
<li>AbstractAutowireCapableBeanFactory.doCreateBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory.doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)方法创建非懒加载的单例Bean</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   populateBean(beanName, mbd, instanceWrapper);<span class="comment">//给Bean的属性赋值</span></span><br><span class="line">   exposedObject = initializeBean(beanName, exposedObject, mbd);<span class="comment">//执行Bean的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>initializeBean方法</li>
</ol>
<p>该方法分成三个部分：Aware接口回调、Aware的BeanPostProcessor实现、BeanPostProcessor前置初始化/InitMethod初始化/BeanPostProcessor后置初始化</p>
<ul>
<li>Aware接口回调 (BeanNameAware、BeanClassLoaderAware、BeanFactoryAware)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给Bean注入Spring底层组件，这里只包含BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">			((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">			ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">			<span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Aware的BeanPostProcessor实现</li>
</ul>
<p>典型实现：ApplicationContextAwareProcessor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory的applyBeanPostProcessorsBeforeInitialization方法</span></span><br><span class="line"><span class="comment">//与第三部分的applyBeanPostProcessorsBeforeInitialization是同一块代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">    <span class="comment">//getBeanPostProcessors里会返回ApplicationContextAwareProcessor和自定义BeanPostProcessor</span></span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ApplicationContextAwareProcessor的postProcessBeforeInitialization方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">			bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">			bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware))&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			invokeAwareInterfaces(bean);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;, acc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		invokeAwareInterfaces(bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ApplicationContextAwareProcessor的invokeAwareInterfaces方法</span></span><br><span class="line"><span class="comment">//回调Bean中重写的方法将Spring底层组件注入到Bean中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">		((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">		((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">		((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">		((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">		((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">		((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getBeanPostProcessors方法包含的BeanPostProcessor如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/spring-getbeanpostprocessor-method.png" alt="getBeanPostProcessors"></p>
<ul>
<li>BeanPostProcessor前置初始化/InitMethod初始化/BeanPostProcessor后置初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">//遍历容器中所有的BeanPostProcessor，逐个执行postProcessBeforeInitialization方法，如果该方法返回null则不在执行后面BeanPostProcessor的postProcessBeforeInitialization</span></span><br><span class="line">    <span class="comment">//注意：这里的BeanPostProcessor包含ApplicationContextAwareProcessor和自定义的BeanPostProcessor</span></span><br><span class="line">	wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	invokeInitMethods(beanName, wrappedBean, mbd);<span class="comment">//调用自定义初始化方法</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable ex)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">	<span class="comment">//与postProcessBeforeInitialization同理</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Spring底层对BeanPostProcessor的使用"><a href="#Spring底层对BeanPostProcessor的使用" class="headerlink" title="Spring底层对BeanPostProcessor的使用"></a>Spring底层对BeanPostProcessor的使用</h4><ul>
<li>ApplicationContextAwareProcessor：实现给Bean的属性赋值ApplicationContext容器</li>
<li>AutowiredAnnotationBeanPostProcessor：实现@Autowired注解</li>
</ul>
<h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><ol>
<li>基本数值，如张三、李四、18</li>
<li>SpEL表达式#{}，如#{20-2}</li>
<li>${}读取外部配置文件或者环境变量中的值，如${person.name}</li>
</ol>
<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>读取外部配置文件中的k/v保存到运行的环境变量中，在使用${}读取配置文件的内容，实际上就从环境变量Environment中读取配置。如environment.getProperty(“person.name”);</p>
<ul>
<li><p>String[] value()：表示要加载的属性文件的位置，如value={“classpath:/com/myco/app.properties”,”file:/path/to/file.xml”}</p>
</li>
<li><p>@Repeatable(PropertySources.class)：可重复注解</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySources</span>(value = &#123;</span><br><span class="line">        <span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:/person.properties"</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>Spring利用依赖注入（DI）完成对IOC容器中各个组件的依赖关系赋值</p>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ol>
<li>默认优先按照类型去容器中查找组件<code>applicationContext.getBean(BookDao.class)</code></li>
<li>如果找到多个相同类型的组件时，在将属性名作为组件id进行查找<code>applicationContext.getBean(&quot;bookDao&quot;)</code></li>
<li>使用@Qualifier指定需要装配的组件id<code>@Qualifier(&quot;bookDao&quot;)</code></li>
<li>@Primary表示首选的Bean，优先级低于@Qualifier</li>
<li>@Autowired(required=false)避免容器启动时的强制装配</li>
</ol>
<p>作用位置：属性、构造器、参数、方法，无论哪种都是从容器中获取参数组件然后进行装配</p>
<ul>
<li>标注在方法上</li>
<li>标注在构造器上：如果组件当且仅有一个有参构造器，这个有参构造器的@Autowired可以省略。当无参和有参构造器同时存在而又没有其他注入方式时，@Autowired一定要放在有参构造器的方法上才能注入，放到有参构造的参数上是无效的。</li>
<li>标注在参数上：@Bean + 方法参数，参数上@Autowired可以省略</li>
</ul>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>Java规范的注解，来源JSR250</p>
<p>可以和@Autowired一样实现自动装配功能，默认按照组件名称（属性名或者自定义名称）装配</p>
<p>不支持@Primary、@Qualifier注解也不支持@Autowired的required=false的功能</p>
<h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><p>Java规范的注解，来源JSR330</p>
<p>需要导入javax.inject包，和@Autowired功能完全一样，除了不支持required=false的功能</p>
<h4 id="自定义组件引入Spring容器底层组件"><a href="#自定义组件引入Spring容器底层组件" class="headerlink" title="自定义组件引入Spring容器底层组件"></a>自定义组件引入Spring容器底层组件</h4><p>自定义组件想要使用ApplicationContext、BeanFactory、BeanName、Environment、StringValueResolver等Spring底层组件，只需要实现其对应的xxxAware接口，Aware接口通过回调的方式将Spring底层的组件传递给（或者说通知到）Bean</p>
<p>xxxAware的原理就是前面提到的xxxProcessor，比如</p>
<p>ApplicationContextAware=&gt;ApplicationContextAwareProcessor</p>
<h4 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h4><p>指定组件在哪个环境下才能注册到容器中，如果不指定，所有Bean都能注册到容器</p>
<ul>
<li>加了环境标识的Bean，只有在指定环境下才能注册到容器中。默认default环境</li>
<li>作用于类上表示在指定的环境下整个配置类中的Bean全部注入到容器中</li>
<li>没有指定环境标识的Bean，无论在哪个环境都能注册</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>面向切面编程（Aspect-Oriented Programming）</strong>,作为面向对象编程模式的一种补充，使得横切关注点可以在程序运行期间动态的应用到主业务逻辑中去，实现横切关注点与业务逻辑对象之间的解耦。而DI实现的应用对象之间的解耦。</p>
<p><strong>横切关注点（cross-cutting concern）</strong>就是散布于应用中多处的功能，比如日志、声明式事务、安全以及缓存等等。其可以被模块化为特殊的类，而这些类被成为<strong>切面（aspect）</strong>。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Aspect（切面）</strong>：模块化的横切关注点</p>
<p><strong>Advice（通知）</strong>：就是在特定的连接点处切面要采取的操作。通知与切入点表达式相关联，并在与切入点表达式匹配的连接点处运行。通知定义了切面要做什么以及何时（前后、返回、异常、环绕）做。</p>
<ul>
<li>Before（前置通知）：在连接点之前执行通知</li>
<li>After（finally）（后置通知）：在连接点退出（无论正常返回还是抛出异常）之后执行通知</li>
<li>After returning（返回通知）：在连接点正常完成之后执行通知</li>
<li>After throwing（异常通知）：方法执行抛出异常时执行通知</li>
<li>Around（环绕通知）：在方法调用的前后执行通知</li>
</ul>
<p><strong>Join point（连接点）</strong>：程序执行过程中的一个点，比如方法调用或者异常处理。Spring AOP只支持方法调用。</p>
<p><strong>Pointcut（切入点）</strong>：匹配连接点的谓词或表达式。告诉切面在”何处”执行通知,而通知告诉切面做什么以及”何时”做。</p>
<p>Weaving（织入）：把切面应用到目标对象并创建新的代理对象的过程。织入时机分三种：</p>
<ul>
<li>编译期（compile time）</li>
<li>类加载期（load time）</li>
<li>运行期（runtime）：Spring AOP就是以这种方式织入切面的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/SpringAOP.png" alt="Spring AOP"></p>
<h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><p>以MathCalculator类运行的过程中打印日志为例：</p>
<ol>
<li>导入Spring AOP依赖spring-aspects</li>
<li>定义一个业务逻辑类MathCalculator</li>
<li>定义一个日志切面类LogAspect，并创建通知方法及切入点<ol>
<li>前置通知@Before：在目标方法之前执行</li>
<li>后置通知@After：在目标方法之后执行</li>
<li>返回通知@AfterReturning：在目标方法正常返回之后执行</li>
<li>异常通知@AfterThrowing：在目标方法出现异常之后执行</li>
<li>环绕通知@Around：动态代理，手动推进目标方法执行（joinPoint.procced()）</li>
</ol>
</li>
<li>给切面类的目标方法标注何时何地运行，也就是加上3中提到的通知注解和切入点注解</li>
<li>将切面类和业务逻辑类注册到容器中</li>
<li>告诉Spring哪个是切面类，即在切面类上加@Aspect注解</li>
<li>配置类中加@EnableAspectJAutoProxy注解，启动基于注解的AOP模式</li>
</ol>
<p>简化一下：</p>
<ol>
<li>定义切面类和业务逻辑类，并用@Aspect注解标注哪个是切面类</li>
<li>切面类的方法上标注通知注解@Before及切入点注解@Pointcut，告诉Spring何时何地执行通知方法</li>
<li>开启基于注解的AOP模式，配置类加@EnableAspectJAutoProxy</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>@EnableAspectJAutoProxy：启动AOP注解模式</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/Spring-EnableAspectJAutoProxy.png" alt="Spring-EnableAspectJAutoProxy"></p>
<p>@Import(AspectJAutoProxyRegistrar.class)：通过实现ImportBeanDefinitionRegistrar接口向容器中导入组件。</p>
<p>AspectJAutoProxyRegistrar类实现ImportBeanDefinitionRegistrar接口向容器中注册AnnotationAwareAspectJAutoProxyCreator组件，BeanName为org.springframework.aop.config.internalAutoProxyCreator</p>
<p>主要研究AnnotationAwareAspectJAutoProxyCreator类，去掉与调试无关接口及相关类，得到如下类图</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/AnnotationAwareAspectJAutoProxyCreator.png" alt="AnnotationAwareAspectJAutoProxyCreator"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主要关注setBeanFactory、postProcessBeforeInitialization、postProcessAfterInitialization、postProcessBeforeInstantiation、postProcessAfterInstantiation这几个方法的实现及重写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractAutoProxyCreator抽象类实现setBeanFactory、postProcessBeforeInstantiation、postProcessAfterInitialization</span></span><br><span class="line">AbstractAutoProxyCreator.setBeanFactory(BeanFactory)</span><br><span class="line">AbstractAutoProxyCreator.postProcessBeforeInstantiation(Class, String)</span><br><span class="line">AbstractAutoProxyCreator.postProcessAfterInitialization(Object, String)</span><br><span class="line"><span class="comment">//AbstractAdvisorAutoProxyCreator重写了setBeanFactory方法</span></span><br><span class="line">AbstractAdvisorAutoProxyCreator.setBeanFactory(BeanFactory)</span><br><span class="line">AbstractAdvisorAutoProxyCreator.initBeanFactory(BeanFactory)</span><br><span class="line"><span class="comment">//AnnotationAwareAspectJAutoProxyCreator重写了initBeanFactory方法</span></span><br><span class="line">AnnotationAwareAspectJAutoProxyCreator.initBeanFactory(BeanFactory)</span><br></pre></td></tr></table></figure>

<h4 id="Bean创建过程"><a href="#Bean创建过程" class="headerlink" title="Bean创建过程"></a>Bean创建过程</h4><ol>
<li>AbstractBeanFactory.getBean </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>AbstractBeanFactory.doGetBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);<span class="comment">//优先从单实例缓存中获取，如果有则直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);<span class="comment">//上面缓存中没有，才会进行创建</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>AbstractAutowireCapableBeanFactory.createBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment">* BeanPostProcessor与InstantiationAwareBeanPostProcessor的区别：</span></span><br><span class="line"><span class="comment">* BeanPostProcessor是在Bean创建完成属性赋值完成之后的初始化前后调用的；</span></span><br><span class="line"><span class="comment">* InstantiationAwareBeanPostProcessor是在Bean创建之前尝试返回Bean实例的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.InstantiationAwareBeanPostProcessor子类尝试创建目标类的代理类</span></span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//resolveBeforeInstantiation方法实现</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<span class="comment">//Bean实例化之前执行</span></span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* AnnotationAwareAspectJAutoProxyCreator就是InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment">* 当开启AOP功能时，AnnotationAwareAspectJAutoProxyCreator就会在Bean创建之前进行拦截</span></span><br><span class="line"><span class="comment">* 作用就是判断当前Bean是否需要增强</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 如果前面没有创建出来对象，才会执行doCreateBean</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>AbstractAutowireCapableBeanFactory.doCreateBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);<span class="comment">//创建Bean实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);<span class="comment">//Bean属性赋值</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);<span class="comment">//Bean初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>AbstractAutowireCapableBeanFactory.initializeBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.回调Aware方法，这里的Aware只限BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.执行BeanPostProcessor的postProcessBeforeInitialization方法，初始化前逻辑处理，比如ApplicationContextAwareProcessor向业务bean中注入ApplicationContext容器</span></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.自定义初始化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.执行BeanPostProcessor的postProcessAfterInitialization方法，初始化后逻辑处理</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.返回创建好的Bean</span></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br></pre></td></tr></table></figure>

<p>简化后：</p>
<ol>
<li>getBean获取实例，调用doGetBean</li>
<li>判断单实例缓存中是否存在，如果不存在，进行createBean</li>
<li>判断BeanPostProcessor是否能创建出目标对象的代理对象，如果不能，进行doCreateBean</li>
<li>createBeanInstance创建Bean实例</li>
<li>populateBean(beanName, mbd, instanceWrapper)：Bean属性赋值</li>
<li>initializeBean(beanName, exposedObject, mbd)：Bean初始化<ol>
<li>invokeAwareMethods(beanName, bean)：处理Aware接口的方法回调</li>
<li>applyBeanPostProcessorsBeforeInitialization：初始化前逻辑处理</li>
<li>invokeInitMethods执行自定义初始化</li>
<li>applyBeanPostProcessorsAfterInitialization初始化后逻辑处理</li>
<li>Bean创建成功并返回</li>
</ol>
</li>
<li>返回Bean实例</li>
</ol>
<h4 id="容器启动过程-AOP相关"><a href="#容器启动过程-AOP相关" class="headerlink" title="容器启动过程(AOP相关)"></a>容器启动过程(AOP相关)</h4><ol>
<li>传入配置类，创建IOC容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext =</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfigAOP<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注册配置类，刷新容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">register(componentClasses);</span><br><span class="line">refresh();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>注册BeanPostProcessor后置处理器用来拦截Bean的创建</p>
<ol>
<li>获取IOC容器中已经定义好的，且类型为BeanPostProcessor的BeanName</li>
<li>遍历BeanName，并按照PriorityOrdered，Ordered，the rest分组</li>
<li>优先注册实现PriorityOrdered接口的BeanPostProcessor</li>
<li>再注册实现Ordered接口的BeanPostProcessor，AnnotationAwareAspectJAutoProxyCreator就是实现此接口的后置处理器</li>
<li>最后注册其余的BeanPostProcessor</li>
<li>注册BeanPostProcessor，根据BeanName得到RootBeanDefinition信息，生成BeanPostProcessor实例，生成实例的过程跟<strong>Bean的创建流程</strong>一样</li>
<li>将BeanPostProcessor注册到容器中</li>
</ol>
</li>
<li><p>实例化剩余的非懒加载的单实例Bean</p>
<ol>
<li>获取容器中所有的beanDefinitionNames并遍历，如果不是工厂Bean，则通过getBean(beanName)创建单实例Bean，创建流程与上面<strong>Bean的创建流程</strong>一样</li>
<li>当开启AOP功能时，AnnotationAwareAspectJAutoProxyCreator就会在Bean创建之前进行拦截，作用是判断当前Bean是否需要增强，具体步骤如下：<ol>
<li>判断当前Bean是否在advisedBeans中，如果在则返回null，进入下一个BeanPostProcessor</li>
<li>判断当前Bean是否是基础类型的Advice,Pointcut,Advisor,AopInfrastructureBean或者是否是@Aspect注解标注过的切面(如果是存入advisedBeans中,但value是false表示不需要增强：切面不需要增强,业务逻辑类才需要增强)</li>
<li>shouldSkip(beanClass, beanName)是否需要跳过(如果是就表示该Bean不需要增强)；<ol>
<li>获取容器里所有的候选增强器List<Advisor> candidateAdvisors，并遍历，判断增强器里是否有AspectJPointcutAdvisor类型的，如果有则返回true（就是不需要增强）。通常我们在SpringAOP里声明的增强器都是InstantiationModelAwarePointcutAdvisor类型</li>
</ol>
</li>
</ol>
</li>
<li>当开启AOP功能时，Bean完成自定义初始化后会执行AbstractAutoProxyCreator（AnnotationAwareAspectJAutoProxyCreator的父类）的postProcessAfterInitialization方法来为需要增强的Bean创建代理对象，实现在<code>wrapIfNecessary(bean, beanName, cacheKey)</code>中<ol>
<li>获取当前Bean的所有增强器<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code><ol>
<li>找到所有候选的增强器</li>
<li>获取能在当前Bean使用的增强器（反射获取Bean的方法并与通知方法上定义的切入点进行匹配，如果匹配就返回）</li>
<li>给增强器排序</li>
</ol>
</li>
<li>如果当前Bean需要增强（specificInterceptors不为空），则将其保存到advisedBeans（value=true）中，并创建代理对象<ol>
<li>创建代理工厂ProxyFactory，并填入相应信息advisor,targetsource等等</li>
<li>创建代理对象，Spring判断目标类（targetClass）是否是接口,如果是则创建JdkDynamicAopProxy动态代理否则创建ObjenesisCglibAopProxy动态代理</li>
</ol>
</li>
<li>如果Bean需要增强就返回2中创建的代理对象，如果不需要就返回普通的Bean</li>
<li>当从容器中获取目标对象时获取到的是其代理对象，执行目标方法的时候，代理对象就会执行通知方法</li>
</ol>
</li>
</ol>
</li>
<li><p>finishRefresh() 完成响应事件</p>
</li>
</ol>
<h4 id="目标方法执行过程"><a href="#目标方法执行过程" class="headerlink" title="目标方法执行过程"></a>目标方法执行过程</h4><p>容器中保存了组件的代理对象（jdk或者cglib增强后的对象），这个对象保存了详细信息（如增强器、目标对象等等）</p>
<ol>
<li>CglibAopProxy.intercept()拦截目标方法的执行</li>
<li>根据ProxyFactory对象获取目标方法的拦截器链<code>List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code><ol>
<li>获取增强器<code>Advisor[] advisors = config.getAdvisors();</code></li>
<li>判断增强器类型是否属于PointcutAdvisor,IntroductionAdvisor还是其他,最终都将其转换成MethodInterceptor </li>
<li><code>MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</code>如果advisor是MethodInterceptor,则直接添加到List<MethodInterceptor>集合中，如果不是MethodInterceptor,需要通过AdvisorAdapter适配器将其转成MethodInterceptor,然后在加到集合中</li>
<li>返回拦截器链集合List<MethodInterceptor></li>
</ol>
</li>
<li>如果chain是空的，则直接通过反射调用目标方法</li>
<li>如果chain不是空的，需要用增强后的代理对象、原对象、目标方法、方法参数、类信息、拦截器链、MethodProxy等信息创建一个CglibMethodInvocation对象,并执行proceed()方法即<code>retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</code></li>
<li>拦截器链的触发过程<ol>
<li>如果没有拦截器,或者当前拦截器索引currentInterceptorIndex等于拦截器数组大小-1,则直接执行目标方法</li>
<li>链式获取每一个拦截器并执行invoke方法,每一个拦截器等待下一个拦截器完成返回以后再执行.拦截器链的机制保证通知方法和目标方法的执行顺序</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/spring_methodintercept.png" alt="spring_methodinterceptor"></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2>]]></content>
  </entry>
  <entry>
    <title>MySQL技术内幕 - 体系结构</title>
    <url>/2020/03/27/mysql-inside-mysql-Chapter-One/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Head First - 策略模式</title>
    <url>/2020/03/27/design-pattern-head-first-Strategy/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>算法(一) —— 递归</title>
    <url>/2020/03/23/algorithm-recursive/</url>
    <content><![CDATA[<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是一种非常高效、简洁的编码技巧。递归求解问题就是将问题拆分成求解思路一样的子问题，子问题在拆分成子子问题，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。</p>
<a id="more"></a>

<h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h3><ol>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>问题与分解后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ol>
<p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。总结为：<strong>写出递推公式，找到终止条件</strong> </p>
<h3 id="递归要警惕的问题"><a href="#递归要警惕的问题" class="headerlink" title="递归要警惕的问题"></a>递归要警惕的问题</h3><ul>
<li>堆栈溢出</li>
</ul>
<p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出站。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p>避免堆栈溢出的方法：通过限制递归调用的最大深度来解决。通过计数器记录调用的深度，当深度到达某个值之后就不在继续往下递归，直接返回报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量，表示递归的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ++depth;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"递归深度范围过大"</span>);</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重复计算</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_recursion_repeat.png" alt="递归调用重复计算"></p>
<p>图中的f(3)被重复计算了多次。</p>
<p>解决重复计算的方法：采用一个数据结构（比如散列表）来存储求解过的f(k)，当递归调用到f(k)时，判断是否求解过f(k)，如果求解过直接返回即可。</p>
<ul>
<li>时间复杂度和空间复杂度增加</li>
</ul>
<p>时间复杂度：递归实现里多了很多函数调用，当函数调用的数量较大时，就会积聚成一个可观的时间成本。</p>
<p>空间复杂度：每递归调用一次，内存栈都需要保存一次现场数据，这也需要额外的空间开销。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>递归代码的时间复杂度分析通常有两种方式：递推公式和递归树</p>
<ul>
<li>递推公式</li>
</ul>
<p>以归并排序为例，归并排序每次会将数组拆分成两半在合并，所以它的递归公式可以表示为<code>T(n) = 2T(n/2) + n</code></p>
<p>推到过程如下：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n</span><br><span class="line">     = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>) + n/<span class="number">2</span>) + n = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n</span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n</span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n</span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>

<p>得到T(n) = $2^k$  * T(n/$2^k$) + k * n ，当T(n/$2^k$) = T(1)时终止，即 n/$2^k$ = 1,k = $\log_2{n}$  , T(n) = Cn + n*$\log_2n$ ,采用大O标记法表示 T(n) = O(nlogn)，所以归并排序的时间复杂度为O(nlogn).</p>
<p>快速排序分区等分时与归并排序的递推公式是一样的，但是快排的分区并不是每次都能一分为二，假设分区比例是1：k，当k=9时递归公式表示为<code>T(n) = T(n/10) + T(9n/10) + n</code> ，这个公式推到起来就比较复杂，这时引用递归树可以很好的解决</p>
<ul>
<li>递归树</li>
</ul>
<p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作<strong>递归树</strong>。</p>
<ol>
<li>快排分析</li>
</ol>
<p>当k=9时的快速排序的递归树如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_recursive_tree.png" alt="快排递归树"></p>
<p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是n。我们现在只要求出递归树的高度h，这个快排过程遍历的数据个数就是h∗n，也就是说，时间复杂度就是O(h∗n)。</p>
<p>递归树中的最短路径每次都乘以1/10，最长路径每次都乘以9/10，也就是从n -&gt; 1的过程最短路径以1/10的速度分裂，最长路径以9/10的速度分裂，过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_recursive_tree_1.png" alt="快排路径计算"></p>
<p>所以，遍历数据的个数总和就介于nlog10n和nlog10/9n之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成logn，所以，当分区大小比例是1:9时，快速排序的时间复杂度仍然是O(nlogn)。</p>
<ol start="2">
<li>斐波那些数列分析</li>
</ol>
<p>斐波那些数列的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述递归代码画成递归树如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_recursive_tree_2.png" alt="斐波那些数列"></p>
<p>这颗递归树的最长路径就是每次数据规模减1的那条路径，即最长路径长度=n，最短路径就是每次数据规模减2的那条路径，最短路径长度=n/2</p>
<p>每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作11。所以，从上往下，第一层的总时间消耗是1，第二层的总时间消耗是2，第三层的总时间消耗就是4。依次类推，第k层的时间消耗就是$2^(k-1)$，那整个算法的总的时间消耗就是每一层时间消耗之和。</p>
<p>最长路径长度=n时总的时间消耗为$2^ n-1$</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_recursive_tree_2_1.png" alt="斐波那些数列最长路径计算"></p>
<p>最短路径长度=n/2时总的时间消耗为$2 ^ (n/2-1)$</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_recursive_tree_2_2.png" alt="斐波那些数列最短路径计算"></p>
<p>所以，这个算法的时间复杂度就介于O($2^n$)和O($2 ^ n/2$))之间，也就是该算法的时间复杂度是指数级增长的</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,递归</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(八) —— 红黑树</title>
    <url>/2020/03/10/algorithm-red-black-tree/</url>
    <content><![CDATA[<p>二叉查找树中查找一个元素所需要的运行时间取决于树的高度，而树的高度又取决于树的形状，而树的形状又取决于元素被插入的顺序，最好的情况下，一棵含有N个结点的二叉树是完全平衡的，树的高度是logN。最坏情况下，这N个结点构造出来的二叉树极不平衡，排成一排，树的高度是N。由于树的形状不固定造成二叉查找树运行时间的不稳定，所以我们需要一个稳定的平衡的二叉查找树：红黑树</p>
<a id="more"></a>

<h3 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h3><p>平衡查找树即平衡二叉查找树。</p>
<p>平衡二叉树严格的定义是指：二叉树中任意一个结点的左右子树的高度差不能超过1.满二叉树、完全二叉树都是平衡二叉树。</p>
<p>平衡查找树就是结合平衡二叉树和二叉查找树的特点，即任意结点的左右子树的高度差不能超过1同时任意结点的左子结点的键值小于该结点的键值，右子结点的键值大于该结点的键值。最早发明的平衡查找树就是AVL树，它严格符合平衡二叉查找树的定义，是一种高度平衡的二叉查找树。</p>
<p>发明平衡二叉查找树的目的是为了解决二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。但是像AVL树这种高度平衡的二叉查找树，虽然查询效率很高，但是为了维护这种高度的平衡，需要付出很多的代价，每次插入、删除都要做调整，比较复杂、耗时。红黑二叉查找树(简称红黑树)只是做到了近似平衡，并不是严格的平衡，即高度差可以超过1，所以维护成本比AVL树要低。</p>
<p>了解红黑树之前，先来了解下2-3查找树，因为红黑树是由2-3查找树演进而来的。</p>
<h4 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h4><p>一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两个链接)，那么3-结点就含两个键和三条链接</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一棵2-3查找树或为一棵空树，或由以下结点组成：</p>
<ul>
<li>2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点</li>
<li>3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_definition.png" alt="2-3查找树定义"></p>
<p>一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_search.png" alt="2-3树查找过程"></p>
<h5 id="2-结点中插入新键"><a href="#2-结点中插入新键" class="headerlink" title="2-结点中插入新键"></a>2-结点中插入新键</h5><p>需要先进行一次未命中的查找，然后将空链接所对应的2-结点转换为一个包含新键的3-结点</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_2node_insert.png" alt="2-结点插入过程"></p>
<h5 id="只含有一个3-结点的树中插入新键"><a href="#只含有一个3-结点的树中插入新键" class="headerlink" title="只含有一个3-结点的树中插入新键"></a>只含有一个3-结点的树中插入新键</h5><p>需要创建一个临时的4-结点，即含有3个键和4条链接的结点。然后再将其转换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_single3node_insert.png" alt="单个3-结点插入过程"></p>
<h5 id="父结点为2-结点的3-结点插入新键"><a href="#父结点为2-结点的3-结点插入新键" class="headerlink" title="父结点为2-结点的3-结点插入新键"></a>父结点为2-结点的3-结点插入新键</h5><p>将新键插入到3-结点使其成为临时4-结点，在将其分解，中间的键提到父结点，将2-结点的父结点转换为3-结点</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_23node_insert.png" alt="父结点为2-结点的3结点插入过程"></p>
<h5 id="父结点为3-结点的3-结点插入新键"><a href="#父结点为3-结点的3-结点插入新键" class="headerlink" title="父结点为3-结点的3-结点插入新键"></a>父结点为3-结点的3-结点插入新键</h5><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_33node_insert.png" alt="父结点为3-结点的3结点插入过程"></p>
<h5 id="分解根结点"><a href="#分解根结点" class="headerlink" title="分解根结点"></a>分解根结点</h5><p>如果从插入结点到根结点的路径上全是3-结点时，最终根结点会变成一个临时的4-结点。将其分解成3个2-结点，树高加1。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_splitroot.png" alt="根结点分解"></p>
<h5 id="局部变换"><a href="#局部变换" class="headerlink" title="局部变换"></a>局部变换</h5><p>将一个4-结点分解为一棵2-3树可能有6中情况，如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_split4node.png" alt="4结点分解情况汇总"></p>
<p>每个变换都会将4-结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p>
<h5 id="全局性质"><a href="#全局性质" class="headerlink" title="全局性质"></a>全局性质</h5><p>局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。</p>
<p><strong>在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_propositionF.png" alt="2-3树高度计算"></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>前面提到的2-3树，树高不超过logN，非常稳定高效，但是它也有缺点，就是不容易实现，它的代码实现非常复杂，既要表示2-结点又要表示3-结点，还要考虑各种变换情况，实现这些需要大量的代码，所以我们急需一种统一的方式来完成2-3树中的这些变换，红黑树由此而生。</p>
<p>红黑树的基本思想是用标准的二叉查找树（完全由2-结点）和一些额外的信息（红黑链接加2-结点替换3-结点）来表示2-3树。红黑树分两种链接类型：一条左斜的<strong>红链接</strong>将两个2-结点连接起来表示一个3-结点，<strong>黑链接</strong>就是2-3树中的普通链接。通过这种方式表示2-3树的二叉查找树就是红黑树。</p>
<p>红黑树与2-3树的一一对应关系如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_correspondence.png" alt="红黑树与2-3树对应关系"></p>
<p>红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：</p>
<ol>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ol>
<p>当新插入一个元素后，如果打破了这三个条件，就需要通过旋转和颜色转换使其重新满足这三个条件，从而使红黑树再次达到完美黑色平衡</p>
<h4 id="旋转和颜色变换"><a href="#旋转和颜色变换" class="headerlink" title="旋转和颜色变换"></a>旋转和颜色变换</h4><p>结点的颜色，指的就是指向该结点的链接的颜色，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_node_represent.png" alt="红色结点表示"></p>
<ul>
<li>左旋转</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_rotate_left.png" alt="左旋转"></p>
<ul>
<li>右旋转</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_rotate_right.png" alt="右旋转"></p>
<p>通过上图的旋转操作，可以看出来在旋转的过程中依然保持着红黑树的有序性和完美平衡性。</p>
<ul>
<li>颜色变换</li>
</ul>
<p>当一个结点的左右子结点的颜色都为红色时，需要将子结点的颜色由红变黑，同时还要将结点的颜色由黑变红。颜色变换操作和旋转操作一样是局部变换，不影响整棵树的黑色平衡性。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_flipcolor.png" alt="颜色变换"></p>
<p>旋转和颜色变换都可以总结为以下这三种情况：</p>
<ol>
<li>如果右子结点是红色的而左子结点是黑色的，进行左旋转</li>
<li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转</li>
<li>如果左右子结点都是红色的，进行颜色变换</li>
</ol>
<p>无论插入还是删除操作，通过以上三个基本操作都可以使红黑树重新达到平衡状态。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_passup.png" alt="旋转和颜色变换三种基本操作"></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       Key key;</span><br><span class="line">       Value value;</span><br><span class="line">       Node left,right;</span><br><span class="line">       <span class="keyword">int</span> N;</span><br><span class="line">       <span class="keyword">boolean</span> color; <span class="comment">//父结点指向本结点的链接的颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, <span class="keyword">int</span> n, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            N = n;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> x.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">        Node x = h.right;</span><br><span class="line">        h.right = x.left;</span><br><span class="line">        x.left = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        x.N = h.N;</span><br><span class="line">        h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">        Node x = h.left;</span><br><span class="line">        h.left = x.right;</span><br><span class="line">        x.right = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        x.N = h.N;</span><br><span class="line">        h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        h.left.color = BLACK;</span><br><span class="line">        h.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node h,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>,RED);<span class="comment">//新结点与父结点用红链接相连</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) h.left = put(h.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> h.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);<span class="comment">//红链接为右链接，进行左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);<span class="comment">//一个结点与两条红链接相连，进行右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);<span class="comment">//左右链接均为红链接，进行颜色变换</span></span><br><span class="line"></span><br><span class="line">        h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_construction_traces.png" alt="红黑树插入过程"></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>无论键的插入顺序如何，红黑树都几乎是完美平衡的。<strong>一个大小为N的红黑树的高度不会超过2logN.</strong> </p>
<p>分析过程：</p>
<ol>
<li>去除红结点</li>
</ol>
<p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_redblack_complexity_analysis_1.png" alt="性能分析-去除红结点"></p>
<p>我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。而完全二叉树的高度近似 log2n，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 log2n。</p>
<ol start="2">
<li>加回红结点</li>
</ol>
<p>在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。</p>
<p><strong>事实上，一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为～1.00logN.</strong>(实验和实际应用已经印证)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构,红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(七) —— 二叉树</title>
    <url>/2020/02/18/algorithm-binary-tree/</url>
    <content><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树相关的概念：<strong>高度</strong>（Height）、<strong>深度</strong>（Depth）、<strong>层</strong>（Level）</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarytree_tree_define.png" alt="树相关概念"></p>
<a id="more"></a>

<p>下图中更直观的展示了这几个概念</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarytree_tree_graph.png" alt="树概念图化"></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>  定义为一个空链接或者是一个具有两个链接的结点，每个链接都指向一棵独立的子二叉树。不过，二叉树并不要求每个结点都有两个子结点，有的结点只有左子结点，有的结点只有右子结点。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarytree_define.png" alt="二叉树"></p>
<p>图中编号 2 的二叉树中，叶子结点全都在最底层，除了叶子结点之外，每个结点都有左右两个子结点，这种二叉树就叫作<strong>满二叉树</strong>。</p>
<p>编号 3 的二叉树中，叶子结点都在最底下两层，最后一层的叶子结点都靠左排列，并且除了最后一层，其他层的结点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<ul>
<li>链式存储</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarytree_linkedlist_storage.png" alt="链式存储"></p>
<p>这种存储方式比较常用，这种方式内存利用率更高，但是因为除了存储数据以外还要额外存储两个指针，所以会多消耗一些内存空间。</p>
<ul>
<li>顺序存储</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarytree_array_storage.png" alt="顺序存储"></p>
<p>图中把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。根据这个规律我们可以判断任意一个节点的左右子节点的位置以及其父节点的位置，假如该节点在数组中的下标为i，则其左子节点的下标为2i，右子节点的下标为(2i+ 1)，父节点的下标为i/2.</p>
<p>顺序存储通常用来存储完全二叉树，因为完全二叉树只是浪费了下标为0的空间，但是如果是非完全二叉树则会浪费比较多的数组存储空间。</p>
<p>堆其实就是一种完全二叉树，而且堆也是采用数组存储元素的。</p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p>
<ul>
<li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li>
<li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li>
<li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarytree_iterator.png" alt="二叉树的遍历"></p>
<p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p>
<p>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure>

<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printByBefore</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">" -&gt; "</span>);</span><br><span class="line">        printByBefore(root.left);</span><br><span class="line">        printByBefore(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按层遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printByLevel</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node last = root,nlast = <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(last);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">"Level "</span> + (++level) + <span class="string">" : "</span>);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            Node head = queue.poll();</span><br><span class="line">            System.out.print(head.val + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.left);</span><br><span class="line">                nlast = head.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.right);</span><br><span class="line">                nlast = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head == last &amp;&amp; !queue.isEmpty())&#123;</span><br><span class="line">                System.out.print(<span class="string">"\nLevel "</span> + (++level) + <span class="string">" : "</span>);</span><br><span class="line">                last = nlast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树深度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = deep(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = deep(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断二叉树是否为平衡二叉树</span></span><br><span class="line"><span class="comment">     * 平衡二叉树的特点：左右子树的高度相差不超过1</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 判断每个结点的左右子结点的高度差是否小于1，这种方法每个结点都会被重复访问多次，所以效率比较低</span></span><br><span class="line"><span class="comment">        if (root == null) return true;</span></span><br><span class="line"><span class="comment">        int left = deep(root.left);</span></span><br><span class="line"><span class="comment">        int right = deep(root.right);</span></span><br><span class="line"><span class="comment">        int diff = left - right;</span></span><br><span class="line"><span class="comment">        if (diff &gt; 1 || diff &lt; -1) return false;</span></span><br><span class="line"><span class="comment">        return isBalance(root.left) &amp;&amp; isBalance(root.right);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//高效的方式是采用后序遍历，先求出该结点的左右子树的高度，在判断该结点是否是平衡的，这种方式是自下而上的判断，所以结点不会被重复访问</span></span><br><span class="line">        <span class="keyword">return</span> calculateHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateHeight</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = calculateHeight(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = calculateHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  Math.abs(left-right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h3><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。</p>
<p><strong>二叉查找树（BST）</strong> 是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中任意结点的键而小于其右子树中任意结点的键。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarysearchtree.png" alt="二叉查找树图示"></p>
<p>如果将一棵二叉查找树的所有键投影到一条直线上，保证一个结点的左子树中的键出现在它的左边，右子树中的键出现在它的右边，那么一定可以得到一条有序的键列，这条键列刚好可以存到数组中。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_mapping_line.png" alt="两棵表示同一组键列的二叉查找树"></p>
<h4 id="二叉查找树的插入和查找"><a href="#二叉查找树的插入和查找" class="headerlink" title="二叉查找树的插入和查找"></a>二叉查找树的插入和查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">private</span> Node left,right;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//以该结点为根的树中的结点总数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            N = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果key存在于以x为根结点的子树中则更新它的值</span></span><br><span class="line">        <span class="comment">//否则将以key和value为键值对的新结点插入到该子树中</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = put(x.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> x.value = value;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当查找一个不存在于树中的结点并结束于一条空链接时，需要做的就是将链接指向一个含有被查找的键的新结点。查找和插入都采用递归实现，可以将递归调用前的代码想象成<strong>沿着树向下走</strong>：它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。递归调用后的代码想象成<strong>沿着数向上爬</strong>：对于get()方法，对应着一系列的返回指令（return），对于put()方法，插入新结点后需要重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中计数器的值。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_put.png" alt="二叉查找树插入"></p>
<h4 id="有序性相关的操作"><a href="#有序性相关的操作" class="headerlink" title="有序性相关的操作"></a>有序性相关的操作</h4><h5 id="最大键和最小键"><a href="#最大键和最小键" class="headerlink" title="最大键和最小键"></a>最大键和最小键</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="向上取整和向下取整"><a href="#向上取整和向下取整" class="headerlink" title="向上取整和向下取整"></a>向上取整和向下取整</h5><p>如果给定的键小于根结点的键，那么小于等于key的最大键floor(key)一定在左子树中；如果给定的键大于根结点的键，那么只有当右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中，否则根结点就是小于等于key的最大键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node x = floor(root,key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left,key);</span><br><span class="line">        <span class="comment">//右子树中可能存在比key小的最大键，也可能不存在，当不存在时直接返回根结点</span></span><br><span class="line">        Node t = floor(x.right,key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_floor.png" alt="二叉查找树的floor函数"></p>
<h5 id="选择和排名"><a href="#选择和排名" class="headerlink" title="选择和排名"></a>选择和排名</h5><p>选择select：查找排名为k的键（即树中正好有k个小于它的键）。如果左子树中的结点数t大于k，那么递归的在左子树中查找排名为k的键；如果t等于k，就返回根结点的键；如果t小于k，就递归的在右子树中查找排名为（k-t-1）的键。</p>
<p>排名rank：返回给定键的排名。如果给定的键和根结点的键相等，则返回左子树中的结点总数t；如果给定的键小于根结点，则递归的计算左子树中的排名；如果给定的键大于根结点，则返回t+1（根结点）加上右子树中的排名（递归计算）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,k).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回排名为k的结点</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> t = size(x.left);</span><br><span class="line">        <span class="keyword">if</span> (t &gt; k) <span class="keyword">return</span> select(x.left,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) <span class="keyword">return</span> select(x.right,k-t-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回以x为根结点的子树中小于key的键的数量</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> rank(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(x.right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> size(x.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_select.png" alt="二叉查找树select函数"></p>
<h5 id="删除最大键和删除最小键"><a href="#删除最大键和删除最小键" class="headerlink" title="删除最大键和删除最小键"></a>删除最大键和删除最小键</h5><p>deleteMin:不断的深入根结点的左子树中直到遇见一个空链接，然后将指向该结点的链接指向该结点的右子树。deleteMax实现类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">      root = deleteMin(root);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">      x.left = deleteMin(x.left);</span><br><span class="line">      x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>思路是采用该结点的后继结点填补它的位置。后继结点就是其右子树中的最小结点，这样的替换仍然能够保证树的有序性，因为x.key和它的后继结点的键之间不存在其他的键。实现这个过程需要4步：</p>
<ol>
<li>将指向即将被删除的结点的链接保存为t</li>
<li>将x指向它的后继结点min(r.right)</li>
<li>将x的右链接（原本指向一棵所有结点都大于x.key的二叉查找树）指向deleteMin(t.right)，也就是在删除后所有结点仍然大于x.key的子二叉查找树</li>
<li>将x的左链接设置为t.left(其下所有的键都小于被删除的结点和它的后继结点)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_delete.png" alt="二叉查找树delete函数"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left =  delete(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = delete(x.right,key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left;</span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">            Node t = x;</span><br><span class="line">            x = min(t.right);</span><br><span class="line">            x.right = deleteMin(t.right);</span><br><span class="line">            x.left = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h5><p>类似于中序遍历（先遍历左子树，根结点，再遍历右子树）</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_keys.png" alt="二叉查找树keys函数"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Key&gt;(<span class="number">16</span>);</span><br><span class="line">        keys(root, queue, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> cmplo = lo.compareTo(x.key);</span><br><span class="line">        <span class="keyword">int</span> cmphi = hi.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt; <span class="number">0</span>) keys(x.left, queue, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt;= <span class="number">0</span> &amp;&amp; cmphi &gt;= <span class="number">0</span>) queue.add(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmphi &gt; <span class="number">0</span>) keys(x.right, queue, lo, hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>二叉查找树中，所有操作的运行时间都和树的高度成正比。树的高度取决于树的形状，而树的形状又取决于键被插入的先后顺序。最好情况下，树是完全平衡的，每条空链接和根结点的距离都是lgN，也就是树的高度为lgN。最坏情况下，树的高度为N。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_analyze.png" alt="二叉查找树的可能形状"></p>
<p>在由N个随机键构造的二叉查找树中，查找命中，查找未命中和插入操作平均所需的比较次数为2lnN（约为1.39lgN）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构,二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(六) —— 跳表</title>
    <url>/2020/02/13/algorithm-skiplist/</url>
    <content><![CDATA[<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_skiplist.png" alt="跳表"></p>
<p>这种链表加多级索引的结构就是跳表</p>
<a id="more"></a>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，*<em>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/ $2 ^ k$ *</em>。</p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/ $2^h$ =2，从而求得 h = $log_2 n$ - 1。如果包含原始链表这一层，整个跳表的高度就是 $log_2 n$  。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>
<p>m的取值取决于构建每层索引时间隔的结点数，假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_skiplist_time.png" alt="跳表时间复杂度"></p>
<p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。跳表之所以查询效率这么高，是因为我们花费了空间为其建立很多级索引，典型的空间换时间的设计思想。</p>
<p>跳表插入、删除操作的时间复杂度也是O(logn)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表的空间复杂度分析并不难，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_skiplist_space.png" alt="跳表空间复杂度"></p>
<p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。</p>
<p>如果构建索引时采用每3个结点抽一个到上级索引，那么索引的结点总和就是n/3 + n/9 + n/27 + …. + 9 + 3 + 1 =  n/2 尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p>
<p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p>
<h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_skiplist_insert.png" alt="跳表动态插入"></p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_skiplist_degenerate.png" alt="跳表退化"></p>
<p>跳表是通过随机函数来维护索引与原始链表大小之间的平衡。也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_skiplist_dynamic.png" alt="跳表动态索引更新"></p>
<p>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(五) —— 散列表</title>
    <url>/2020/02/07/algorithm-hashtable/</url>
    <content><![CDATA[<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><img src="https://github.com/zhengguoqiang927/Figure-bed/blob/master/img/algorithm_hashtable_hash_function.png?raw=true" alt="散列表"></p>
<p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数也叫哈希函数，不管是哪个，英文都对应为hash，只是翻译的不同而已。散列表里的散列函数就是将元素的值映射为散列码的过程。</p>
<p>散列函数的设计需要两点：</p>
<ol>
<li>散列函数的设计不能过于复杂，因为散列函数属于高频操作，如果过于复杂势必会消耗过多的计算时间</li>
<li>散列函数生成的散列值尽可能随机且分布均匀</li>
</ol>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>散列函数是哈希算法的一种应用场景。<strong>哈希算法</strong>就是将任意长度的二进制值串映射成固定长度的二进制值串的规则 ，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。业界比较著名的哈希算法有MD5、SHA、CRC等</p>
<p>哈希算法需要满足的几点要求：</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值</li>
</ul>
<p>哈希算法的应用都是基于以上这几个规则，只是侧重点有所不同。</p>
<h4 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h4><ul>
<li>安全加密</li>
</ul>
<p>最常用于加密的哈希算法是<strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和<strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。除了这两个之外，当然还有很多其他加密算法，比如<strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p>
<p>我们开发经常需要关心的用户敏感信息，比如密码这种，存储到库中一定要经过加密处理，不然一旦脱库数据很容易泄漏。比较常见的加密方案是在用户密码的基础上加盐(salt)在进行哈希算法加密存储到数据库中，进一步增加破解的难度。其实安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。</p>
<ul>
<li><p>唯一标识</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>散列函数</p>
</li>
<li><p>负载均衡</p>
</li>
</ul>
<p><strong>可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</strong>这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<ul>
<li><p>数据分片</p>
</li>
<li><p>分布式存储</p>
</li>
</ul>
<p>应用场景：一致性哈希算法</p>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>在数组有限的存储空间内，要想找一个散列函数使不同的key散列出不同的哈希码，几乎是不可能的，像上面那些著名的哈希算法也无法避免散列冲突，只能通过其他途径来解决散列冲突，而不用过度的依赖于散列函数。</p>
<p>常用的散列冲突解决方案：开放寻址法（open addressing）和链表法（chaining）</p>
<ol>
<li>开放寻址法</li>
</ol>
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。典型的比如线性探测（Linear Probing）</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_hashtable_linear_probing.png" alt="开放寻址"></p>
<p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_hashtable_linear_query.png" alt="线性探测查找"></p>
<p>对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。解决这个问题的方法就是将删除的元素标记为deleted，这样当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_hashtable_linear_delete.png" alt="线性探测删除"></p>
<p>线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）。</p>
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p>
<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<ul>
<li>优点</li>
</ul>
<p>散列表中的数据都存储在数组中，而数组是一组连续的内存空间，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单</p>
<ul>
<li>缺点</li>
</ul>
<p>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>
<p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因</strong>。</p>
<ol start="2">
<li>链表法</li>
</ol>
<p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_hashtable_chain.png" alt="链表法"></p>
<p>采用链表法解决散列冲突的散列表，插入和查找元素的时间复杂度与链表的长度k成正比，也就是O(k)。k=n/m，n就是元素的个数，m就是散列表中槽的个数。</p>
<ul>
<li>优点</li>
</ul>
<ol>
<li>链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li>
<li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li>
<li>灵活性更高。可以将链表转换为其他高效的动态数据结构，比如跳表、红黑树。对于散列到一个桶内数据的查找时间复杂度就从O(n)降低到O(logn)。Java中的HashMap就是链表转红黑树的实现。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<p>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。但是如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p>
<p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p>
<h3 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h3><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。当装载因子过大时，我们就需要对散列表进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。</p>
<p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p>
<p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_hashtable_resize.png" alt="散列表扩容"></p>
<p>对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p>
<h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><ol>
<li>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</li>
</ol>
<p>思路：遍历一遍URL，存入散列表中，key为url，value为访问次数，并记录下最大的访问次数k，如果访问次数k比较小，则采用桶排序，即在遍历一遍URL，将访问次数等于桶下标的url放入到对应的桶内，然后按顺序从桶中取出url就是有序的了；如果访问次数k比较大，则采用快排，快排的思路是第一遍遍历统计出访问次数以后，在遍历一遍url做两件事情，取出value访问次数放到数组中，并建立访问次数和url的映射关系即Map&lt;int,List<String>&gt;这种关系，然后将访问次数数组采用快速排序，时间复杂度O(nlogn)，遍历排序后的数组并从Map&lt;int,List<String>&gt;中取出url即可。</p>
<ol start="2">
<li>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</li>
<li>设计工业级散列表的思路？</li>
</ol>
<p>工业级散列表应该具有的特性如下：</p>
<ul>
<li>支持快速的查询、插入、删除操作</li>
<li>内存占用合理，不能浪费过多的内存空间</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况</li>
</ul>
<p>为了实现这些特性，设计散列表时需要考虑的点有以下三个：</p>
<ul>
<li>设计一个合适的散列函数</li>
<li>定义装载因子阈值，并且设计动态扩容策略</li>
<li>选择合适的散列冲突解决方案</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(四) —— 队列</title>
    <url>/2020/02/05/algorithm-queue/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列也是一种特殊的线性表数据结构，其特点是先进先出。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_definition.png" alt="队列结构"></p>
<a id="more"></a>

<p>两个基本操作：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。</p>
<p>作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p>
<p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
<ul>
<li>顺序队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;<span class="comment">//存放元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;<span class="comment">//队头下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;<span class="comment">//队尾下标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = (Item[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == items.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[tail++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> items[head++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_array.png" alt="顺序队列"></p>
<p>伴随着入队、出队操作，head和tail不停的向后移动，当tail移动到数组末尾时，就无法在往队列里添加元素了，但是这个时候其实数组还有空闲空间，所以我们需要做一次数据搬移，将数组中剩下的元素移动到数组头部，这样就可以继续往队列里添加元素。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_array_copy.png" alt="顺序队列数据移动"></p>
<p>注意：出队无需改变（其实出队操作也可以进行数据搬移，只是效率很低，因为每次出队都要搬移数据，使出队时间复杂度从O(1)提升到O(n)）,所以只需改造入队操作，当tail到达队尾时集中触发一次数据搬移即可，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tail == items.length) &#123;</span><br><span class="line">    <span class="comment">//当head = 0时，表示数组是真的满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//数据拷贝</span></span><br><span class="line">    <span class="comment">//if (tail - head &gt;= 0) System.arraycopy(items, head, items, 0, tail - head);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head;i&lt; tail;i++)&#123;</span><br><span class="line">      items[i-head] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tail  = tail - head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  items[tail++] = item;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链式队列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_linkedlist.png" alt="链式队列结构"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用链表实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//队列头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//队列尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//队列中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        tail = <span class="keyword">new</span> Node(item);</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//队列是空的</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = tail;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            oldTail.next = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Item item = head.item;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">//删除头结点后队列为空的判断</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) tail = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_cyclic.png" alt="循环队列"></p>
<p>循环队列避免非循环队列中的数据移动操作，也就是入队时直接将元素放入下标为tail的位置，然后tail在环中向后移动一位。</p>
<p>循环队列的关键是确定好队空和队满的判断条件：</p>
<p>队空判定条件：head==tail；队满判定条件：(tail + 1)%n == head。</p>
<p>另外当队列满时，tail所指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。效果图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_cyclic_full.png" alt="循环队列队满结构"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Item[] items;<span class="comment">//存放元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;<span class="comment">//队头下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;<span class="comment">//队尾下标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = (Item[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % items.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        <span class="comment">//注意当tail到达(数组长度 - 1)时要形成环</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % items.length;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//队空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Item item = items[head];</span><br><span class="line">        <span class="comment">//注意当head到达(数组长度 - 1)时要形成环</span></span><br><span class="line">        head = (head + <span class="number">1</span>) % items.length;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_blocked.png" alt="阻塞队列"></p>
<p>基于阻塞队列可以很容易实现一个生产者-消费者模型，通过阻塞队列可以有效的协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如消费过慢时，可以通过增加消费者的数量来提高消费速率</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_queue_multi_consumer.png" alt="多消费者模式"></p>
<p><strong>并发队列</strong> 就是线程安全的队列。基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(三) —— 栈</title>
    <url>/2020/02/03/algorithm-stack/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈也是一种特殊的线性表，其特性为先进后出、后进先出 ，<strong>后进先出</strong>是栈最大的特点。很多应用场景都是基于栈的后进先出特性。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_definition.png" alt="栈结构"></p>
<a id="more"></a>

<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</strong>。</p>
<p>用数组实现的栈，叫作<strong>顺序栈</strong>，用链表实现的栈，叫作<strong>链式栈</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序栈实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;<span class="comment">//存放元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = (Item[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == items.length) <span class="keyword">return</span>;</span><br><span class="line">        items[count++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> items[--count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node top;<span class="comment">//栈顶结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        Node oldTop = top;</span><br><span class="line">        top = <span class="keyword">new</span> Node(item);</span><br><span class="line">        top.next = oldTop;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Item item = top.item;</span><br><span class="line">        top = top.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是顺序栈还是链式栈，入栈和出站的时间和空间复杂度都为O(1)</p>
<h3 id="动态扩容的顺序栈"><a href="#动态扩容的顺序栈" class="headerlink" title="动态扩容的顺序栈"></a>动态扩容的顺序栈</h3><p>底层采用支持动态扩容的数组实现即可</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_dynamic.png" alt="动态扩容的顺序栈"></p>
<p>时间复杂度分析：出栈时间复杂度O(1)。入栈时间复杂度需要分情况，当入栈时恰好有空间，时间复杂度也为O(1)；当入栈时空间已满则需要重新申请内存并进行数据复制，这时时间复杂度为O(n)。</p>
<p>也就是说，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。平均情况下的时间复杂度可以采用摊还分析法来分析</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_dynamic_time.png" alt="动态扩容的顺序栈时间复杂度分析"></p>
<p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 简单入栈操作（不包含数据拷贝）。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个简单入栈操作。入栈操作的均摊时间复杂度就为 O(1)。正好印证了<strong>均摊时间复杂度一般都等于最好情况时间复杂度</strong>。</p>
<p>大体思路就是：在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持扩容的顺序栈实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;<span class="comment">//存放元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = (Item[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == items.length) resize(<span class="number">2</span>*items.length);</span><br><span class="line">        items[count++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Item item = items[--count];</span><br><span class="line">        <span class="comment">//避免游离</span></span><br><span class="line">        items[count] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//缩容</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count == items.length/<span class="number">4</span>) resize(items.length/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        Item[] tmp = (Item[]) <span class="keyword">new</span> Object[max];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            tmp[i] = items[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if (count &gt;= 0) System.arraycopy(items, 0, tmp, 0, count);</span></span><br><span class="line">        items = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(<span class="string">"%d"</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_function_call.png" alt="函数调用栈"></p>
<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_operation.png" alt="表达式求值"></p>
<h4 id="浏览器的页面前进-后退功能"><a href="#浏览器的页面前进-后退功能" class="headerlink" title="浏览器的页面前进/后退功能"></a>浏览器的页面前进/后退功能</h4><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_browser1.png" alt="browser1"></p>
<p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_browser2.png" alt="browser2"></p>
<p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_browser3.png" alt="browser3"></p>
<p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_stack_browser4.png" alt="browser4"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(二) —— 链表</title>
    <url>/2020/02/01/algorithm-linkedlist/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>链表也是一种线性表数据结构，不像数组那样需要一块连续的内存空间，链表通过”指针“将一组零散的内存块串联起来</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_define.png" alt="链表"></p>
<a id="more"></a>

<h3 id="常见的链表"><a href="#常见的链表" class="headerlink" title="常见的链表"></a>常见的链表</h3><p>常见的链表结构：单链表、双向链表、循环链表</p>
<p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。指针分为<strong>前驱指针</strong> 和 <strong>后继指针</strong> ，前驱指针prev用来记录上一个结点的地址，后继指针next用来记录下一个结点的地址。并且把链表的第一个结点叫头结点，最后一个结点叫尾结点。头结点用来记录链表的基地址，尾结点的后继指针指向一个<strong>空地址NULL</strong> </p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_single.png" alt="单链表"></p>
<p>针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。但是链表不支持随机访问，无法像数组那样通过首地址和下标，通过寻址公式直接计算内存地址，链表要想随机访问第k个元素只能进行遍历</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_insert_delete.png" alt="链表插入删除"></p>
<p><strong>循环链表是一种特殊的单链表</strong> ，它跟单链表唯一的区别就在尾结点，循环链表的尾结点指针是指向链表的头结点</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_cycle.png" alt="循环链表"></p>
<p>和单链表相比，<strong>循环链表</strong>的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/约瑟夫斯问题" target="_blank" rel="noopener">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<p><strong>双向链表</strong>，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_double.png" alt="双向链表"></p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间</p>
<p>双向链表的典型应用：Java中的LinkedHashMap，双向链表采用空间换时间的设计思想，缓存也是采用了该设计思想。</p>
<p>双向循环链表就是双向链表和循环链表的结合</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_double_cycle.png" alt="双向循环链表"></p>
<h3 id="链表-vs-数组"><a href="#链表-vs-数组" class="headerlink" title="链表 vs 数组"></a>链表 vs 数组</h3><p>插入、删除、随机访问操作的时间复杂度对比如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_performance.png" alt="链表数组性能对比"></p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<p>数组动态扩容时，需要进行大量的复制操作，比较耗时；链表天然支持动态扩容。</p>
<p>如果对内存的要求比较严格，则数组更适合，因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍</p>
<h3 id="LRU（Least-Recently-Used）缓存淘汰策略链表简单实现"><a href="#LRU（Least-Recently-Used）缓存淘汰策略链表简单实现" class="headerlink" title="LRU（Least Recently Used）缓存淘汰策略链表简单实现"></a>LRU（Least Recently Used）缓存淘汰策略链表简单实现</h3><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部</li>
</ol>
</li>
</ol>
<p>这种方式缓存访问的时间复杂度为O(n)，因为需要遍历链表，可以采用散列表（Hash Table）保存结点的位置，使时间复杂度降为O(1).</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_hashtable_lru.png" alt="双向链表+散列表实现LRU"></p>
<p>上图通过散列表+双向链表实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型。双向链表从头到尾依次存储访问时间由近及远的数据，散列表中存放双向链表中的数据，方便查找。</p>
<p>当一个新数据被访问时，先通过散列表进行查找：</p>
<ol>
<li>如果散列表中存在该数据，则将其从双向链表中删除，并插入到双向链表的头部，其中hnext指针不变，只需要改变prev和next指针的指向。该元素在散列表中的顺序不变，改变的只是双向链表中的顺序</li>
<li>如果散列表中不存在该数据，同样分两种情况：<ol>
<li>缓存未满，则将该数据存到散列表中，并将该数据结点设置成双向链表的头结点</li>
<li>缓存已满，则先找到双向链表尾结点，将其中散列表中删除，再将其中双向链表中删除，然后将新数据结点存放到散列表中，并将其设置成双向链表的头结点</li>
</ol>
</li>
</ol>
<p><strong>LinkedHashMap 也是通过双向链表和散列表这两种数据结构组合实现的。</strong></p>
<h3 id="如何写出优雅链表代码的技巧"><a href="#如何写出优雅链表代码的技巧" class="headerlink" title="如何写出优雅链表代码的技巧"></a>如何写出优雅链表代码的技巧</h3><h4 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h4><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p -&gt; next = q;<span class="comment">//p结点中的next指针存储了q结点的内存地址</span></span><br><span class="line">p -&gt; next = p-&gt;next-&gt;next;<span class="comment">//p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址</span></span><br></pre></td></tr></table></figure>

<h4 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h4><ol>
<li><strong>插入结点时，一定要注意操作的顺序</strong></li>
<li><strong>删除链表结点时，也一定要记得手动释放内存空间</strong></li>
</ol>
<h4 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h4><p>哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，比如针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_sentinel.png" alt="带哨兵的链表"></p>
<p><strong>带头链表</strong>就是带有哨兵节点的链表，<strong>不带头链表</strong>就是不带哨兵节点的链表</p>
<h4 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h4><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p>
<p>检查链表代码是否正确的边界条件有这样几个：</p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
<p>实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮。</p>
<h4 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h4><p>对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，<strong>举例法</strong>和<strong>画图法</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_linkedlist_drawing.png" alt="举例画图"></p>
<p>通过举例画图理清链表操作的思路。</p>
<h4 id="多写多练，没有捷径"><a href="#多写多练，没有捷径" class="headerlink" title="多写多练，没有捷径"></a>多写多练，没有捷径</h4><ul>
<li>单链表反转(LeetCode:206)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案一 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">  <span class="comment">//递归终止条件：碰到尾结点</span></span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  Node p = reverse(head.next);<span class="comment">//递归</span></span><br><span class="line">  head.next.next = head;<span class="comment">//反转</span></span><br><span class="line">  head.next = <span class="keyword">null</span>;<span class="comment">//反转到头结点时，将头结点的next置为null</span></span><br><span class="line">  <span class="keyword">return</span> p;<span class="comment">//反转后的头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案二 非递归实现，双指针：一个指针记录前一个结点，一个指针记录正在处理的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseNormal</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">  Node cur = head;</span><br><span class="line">  Node prev = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">    Node temp = cur.next;</span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="comment">//步进</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    cur = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当处理到尾结点时cur==null，prev正好指向反转后的头结点</span></span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表中环的检测(LeetCode:141)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案一 哈希表</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n),空间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solutionOne</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  Set&lt;ListNode&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeSet.contains(head))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      nodeSet.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案二 快慢指针</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n),空间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solutionTwo</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode slow = head,fast = head;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//没有环时，快指针先到尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;<span class="keyword">while</span> (slow != fast);</span><br><span class="line">  <span class="comment">//能运行到这说明快慢指针相遇了，就表示存在环</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个有序的链表合并(LeetCode:21)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoLists</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：遍历比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode p1,ListNode p2)</span></span>&#123;</span><br><span class="line">        ListNode shard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode first = shard;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val &lt; p2.val)&#123;</span><br><span class="line">                first.next = p1;</span><br><span class="line">                first = first.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first.next = p2;</span><br><span class="line">                first = first.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        first.next = p1 == <span class="keyword">null</span> ? p2 : p1;</span><br><span class="line">        <span class="keyword">return</span> shard.next;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//方法二：递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeByRecursive</span><span class="params">(ListNode p1,ListNode p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val)&#123;</span><br><span class="line">            p1.next = mergeByRecursive(p1.next,p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p2.next = mergeByRecursive(p1,p2.next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除链表倒数第n个结点(LeetCode:19)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteN</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：两次遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteByTwice</span><span class="params">(Node head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Node first = head;</span><br><span class="line">        <span class="comment">//1.遍历得到链表的长度</span></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算删除结点的正向位置，正常应该是(L - n + 1)，不加1是因为正好找到其前驱结点</span></span><br><span class="line">        length -= n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哨兵结点，有两个好处：1.简化删除头结点的判断逻辑；2.简化判断前驱结点位置的逻辑</span></span><br><span class="line">        Node shard = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        shard.next = head;</span><br><span class="line"></span><br><span class="line">        first = shard;</span><br><span class="line">        <span class="comment">//2.遍历找到要删除结点的前驱结点</span></span><br><span class="line">        <span class="keyword">while</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            length--;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.删除结点</span></span><br><span class="line">        first.next = first.next.next;</span><br><span class="line">        <span class="keyword">return</span> shard.next;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//方法二：一次遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteByOne</span><span class="params">(Node head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哨兵结点</span></span><br><span class="line">        Node shard = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        shard.next = head;</span><br><span class="line">        <span class="comment">//两个指针，他俩之间的距离为n，所以当第一个指针到达链表末尾时，第二个指针正好指向要删除的结点</span></span><br><span class="line">        Node first = shard, second = shard;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//控制第二个指针与第一个指针的距离为n</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> shard.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>求链表的中间结点(LeetCode:876)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//快慢指针，时间复杂度O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">middleNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Node slow=head,fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单链表存储的回文字符串判断(LeetCode:234)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.快慢指针定位中间结点</span></span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.逆序后半部分结点</span></span><br><span class="line">        slow = reverse(slow.next);</span><br><span class="line">        <span class="comment">//3.对称比较值是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != slow.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归反转</span></span><br><span class="line">        ListNode p = reverse(head.next);</span><br><span class="line">        <span class="comment">//让下一个结点的后继指针指向自己，实现反转</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n),空间复杂度为O(1)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(一) —— 数组</title>
    <url>/2020/01/29/algorithm-array/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<a id="more"></a>

<p>定义中的几个关键词：</p>
<ol>
<li><strong>线性表（Linear List）</strong></li>
</ol>
<p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_array_linear_list.png" alt="线性表"></p>
<p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_array_non_linear_list.png" alt="非线性表"></p>
<ol start="2">
<li><strong>连续的内存空间和相同类型的数据</strong></li>
</ol>
<p>因为其连续的内存空间，所以支持根据下标随机访问，但同时使插入和删除操作变得低效，因为需要大量的移动元素。</p>
<p>当内存中没有连续的、足够大的创建数组所需要的存储空间时，会申请失败。</p>
<h3 id="高效的随机访问"><a href="#高效的随机访问" class="headerlink" title="高效的随机访问"></a>高效的随机访问</h3><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_array_memory.png" alt="数组内存结构"></p>
<p>该图是int[] a = new int[10] 数组的内存空间分配图，因为int类型占用4个字节，所以该数组占用一块40个字节的连续内存空间，内存块的首地址为 base_address = 1000。计算机通过地址访问内存中数据，随机访问数组中某个元素的寻址公式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size;<span class="comment">//data_type_size在这里为4个字节</span></span><br></pre></td></tr></table></figure>

<p>数组和链表的区别：</p>
<p>链表适合做插入、删除操作，时间复杂度为O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。当在一个有序的数组中进行查找的时候，可以采用二分查找，时间复杂度为O(logn).</p>
<h3 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h3><p>将一个数据插入到一个长度为n的数组中的第k个位置时，需要将k~n的元素向后移动一位，为该元素腾出第k个位置。最好情况时间复杂度(即k=n，从数组末尾插入)：O(1)；最坏情况时间复杂度(即k=0，从数组开头插入)：O(n)；平均情况时间复杂度(即k在各个位置出现的概率相等，为1/n)：(1+2+…+ n)/n = O(n).</p>
<p>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_array_insert_simple.png" alt="免移动的数组插入方式"></p>
<p>这种情况下的时间复杂度降为O(1).</p>
<p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)</p>
<p>举个例子，数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_array_delete_eg.png" alt="数组删除"></p>
<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。这正是<strong>JVM 标记清除垃圾回收算法的核心思想</strong>。</p>
<h3 id="容器和数组"><a href="#容器和数组" class="headerlink" title="容器和数组"></a>容器和数组</h3><p>容器最大的优势就是将很多数组操作的细节进行了封装，并且支持动态扩容。比如插入、删除操作时的移动数据，容器已经封装好，程序员可以直接使用。</p>
<p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。不过，这里需要注意一点，因为<strong>扩容操作涉及内存申请和数据搬移，是比较耗时的</strong>。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建 ArrayList 的时候事先指定数据大小</strong>。</p>
<p>适合使用数组的场景：</p>
<ol>
<li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li>
<li>当表示多维数组时，Object[][] array更为直观；而用容器的话需要这样定义：ArrayList<ArrayList> array</li>
</ol>
<h3 id="数组要从-0-开始编号，而不是从-1-开始"><a href="#数组要从-0-开始编号，而不是从-1-开始" class="headerlink" title="数组要从 0 开始编号，而不是从 1 开始"></a>数组要从 0 开始编号，而不是从 1 开始</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure>

<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[k]_address = base_address + (k-<span class="number">1</span>)*type_size</span><br></pre></td></tr></table></figure>

<p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法,数组</tag>
      </tags>
  </entry>
</search>
