<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Georgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文简单介绍并发编程的基础内容">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="http://yoursite.com/2020/04/30/java-concurrency-Concurrency-Programming/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="本文简单介绍并发编程的基础内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_unsafesequence.png">
<meta property="article:published_time" content="2020-04-30T15:47:21.000Z">
<meta property="article:modified_time" content="2020-06-17T05:54:41.646Z">
<meta property="article:author" content="ZGQ">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_unsafesequence.png">

<link rel="canonical" href="http://yoursite.com/2020/04/30/java-concurrency-Concurrency-Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发编程 | Z's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/java-concurrency-Concurrency-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ZGQ">
      <meta itemprop="description" content="Java">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 23:47:21" itemprop="dateCreated datePublished" datetime="2020-04-30T23:47:21+08:00">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-17 13:54:41" itemprop="dateModified" datetime="2020-06-17T13:54:41+08:00">2020-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/04/30/java-concurrency-Concurrency-Programming/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/30/java-concurrency-Concurrency-Programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文简单介绍并发编程的基础内容</p>
<a id="more"></a>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><h4 id="线程带来的好处"><a href="#线程带来的好处" class="headerlink" title="线程带来的好处"></a>线程带来的好处</h4><ol>
<li>提升资源利用率，比如多核处理器、IO操作</li>
<li>简化建模</li>
<li>简化异步事件处理</li>
<li>提升GUI响应速度</li>
</ol>
<h4 id="线程带来的问题"><a href="#线程带来的问题" class="headerlink" title="线程带来的问题"></a>线程带来的问题</h4><ol>
<li>安全性问题：多线程情况下，无法保证程序执行的正确性。正确性的含义就是类的行为与其规范完全一致。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_concurrency_unsafesequence.png" alt="UnsafeSequence错误执行情况"></p>
<p>不安全的原因：value++不是一个原子操作，而是一个复合操作：读取value、将value加1、value回写到内存</p>
<blockquote>
<p>线程安全性定义：当多个线程访问某个类时，在没有额外的协同或者同步的情况下，这个类始终都能表现出正确的行为，就称这个类是线程安全的。</p>
</blockquote>
<p><strong>无状态对象一定是线程安全的</strong></p>
<ol start="2">
<li>活跃性问题：正确的事情最终会发生。典型问题比如死锁、饥饿、活锁</li>
<li>性能问题：比如频繁的线程上下文切换（多线程程序中，线程调度器临时挂起活跃线程转而执行另一个线程时，就需要执行线程上下文的切换，当频繁的进行线程切换时，将会带来极大的开销：保存/恢复上下文，CPU将更多的时间花费在线程调度而不是线程运行）以及共享数据采用同步机制时会抑制某些编译器优化，使内存缓冲区中的数据无效，从而增加内存总线的同步流量。</li>
</ol>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>原子操作定义：有A、B两个操作，从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么不执行，同理B看A也是如此，那么就成AB之间是原子的。原子操作是指，对于访问同一个状态的所有操作，都是以原子方式执行的。比如AtomicXXX类中的方法都是原子的</p>
</blockquote>
<h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><blockquote>
<p>当一个线程修改了对象状态后，其他线程能够看到修改之后的状态变化</p>
</blockquote>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile变量是一种比synchronized关键字更轻量级的同步机制，用来确保将变量的更新操作通知到其他线程。volatile变量不会被缓存在寄存器或者其他处理器看不见的地方，因此在读取volatile变量都会从内存拉取最新的值。</p>
<p>volatile另外一个作用是<strong>禁止指令重排序</strong></p>
<p><strong>注意</strong> ：加锁机制既可以确保可见性又可以确保原子性，而volatile只能保证可见性，无法保证原子性</p>
<p>使用volatile需要满足的条件：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者确保只在单个线程中更新变量（一个线程写，其他线程读）</li>
<li>访问变量不需要加锁</li>
<li>不与其他变量一起纳入不变性条件中</li>
</ul>
<h4 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h4><p><strong>发布</strong> 是指使一个对象能够在当前作用域之外的代码中使用。 <strong>逸出</strong>：某个不应该发布的对象被发布。</p>
<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>当访问共享的可变数据时，通常需要使用同步。要想不使用同步，要么不共享，要么不可变。</p>
<p>线程封闭就是不共享数据，将其封闭在单线程内，即便数据是可变的，那对其他线程也没有影响，同时也不需要同步处理，是实现线程安全性的最简单方式之一。 </p>
<h5 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h5><p>Ad-hoc线程封闭是指，维护线程封闭性的 职责完全由程序实现来承担。Ad-hoc线程封闭是脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。所以在可能的情况下尽量少使用它，转而使用封闭性更强的线程封闭技术（比如 栈封闭和ThreadLocal）</p>
<p>线程封闭典型的例子：volatile变量封闭，即确保只有一个线程对共享的volatile变量执行写入操作，其他线程只进行读取操作。实际上是通过避免在多线程同时修改共享的volatile变量产生的竞态条件，同时volatile的可见性保证其他线程能够即时感知到变量状态的变化，从实现线程安全性。</p>
<h5 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h5><p>栈封闭实际上就是通过局部变量访问对象。也就是在本线程内创建对象，该对象只有本线程的局部变量可以访问，局部变量（对象引用）是存储在栈上的，而栈是线程私有的数据结构，因此局部变量只能在各个线程内部访问，线程间是不共享的，所以是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123; </span><br><span class="line"> 	SortedSet&lt;Animal&gt; animals; </span><br><span class="line">    <span class="comment">//基础类型的局部变量始终封闭在线程内，因为基础类型、对象引用、返回地址存储于栈中</span></span><br><span class="line"> 	<span class="keyword">int</span> numPairs = <span class="number">0</span>; </span><br><span class="line"> 	Animal candidate = <span class="keyword">null</span>; </span><br><span class="line"> 	<span class="comment">// animals对象在线程内部创建，只要确保其不逸出就能保证线程安全</span></span><br><span class="line"> 	animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator()); </span><br><span class="line"> 	animals.addAll(candidates); </span><br><span class="line"> 	<span class="keyword">for</span> (Animal a : animals) &#123; </span><br><span class="line"> 		<span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a)) </span><br><span class="line"> 			candidate = a; </span><br><span class="line"> 		<span class="keyword">else</span> &#123; </span><br><span class="line"> 			ark.load(<span class="keyword">new</span> AnimalPair(candidate, a)); </span><br><span class="line"> 			++numPairs; </span><br><span class="line"> 			candidate = <span class="keyword">null</span>; </span><br><span class="line"> 		&#125; </span><br><span class="line"> 	&#125;	 </span><br><span class="line"> 	<span class="keyword">return</span> numPairs; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>如果某个对象在创建完之后其状态就不可在修改，那么这个对象就是<strong>不可变对象</strong> 。</p>
<blockquote>
<p>不可变对象一定是线程安全的</p>
</blockquote>
<p><strong>注意</strong> ：不可变性不等于将对象的所有域都声明为final类型，即时将所有域都声明为final类型，该对象也仍然有可能是可变的，因为final类型的域可以保存可变对象的引用。比如final 修饰的集合类</p>
<p>不可变对象需要满足的条件：</p>
<ul>
<li>对象创建之后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的（对象创建期间，this引用没有逸出）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;(); </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		stooges.add(<span class="string">"Moe"</span>); </span><br><span class="line"> 		stooges.add(<span class="string">"Larry"</span>); </span><br><span class="line"> 		stooges.add(<span class="string">"Curly"</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> stooges.contains(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreeStooges对象是线程安全的，尽管final修饰的stooges变量可以保存可变对象，但是在ThreeStooges构造完成之后stooges就不在可变了，所以是线程安全的。</p>
<h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><p>得到一个线程安全的容器有以下三种情况：</p>
<ol>
<li>使用早期的Vector和Hashtable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </li>
<li>Collections.synchronizedXxx方法</li>
<li>Java 5.0提供的ConcurrentXXX类</li>
</ol>
<p>1和2存在的问题：</p>
<ul>
<li>复合操作（迭代、跳转、条件运算）需要在客户端额外的加锁 </li>
<li>性能低</li>
<li>迭代（包含显式迭代和隐氏迭代，比如toString方法就属于隐氏迭代）过程中并发修改会”及时失败（fail-fast）”，立刻抛出ConcurrentModificationException异常。实现机制就是通过判断计数器是否修改</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap vs HashTable</p>
<ol>
<li>HashTable是线程安全的(方法都有synchronized修饰)，HashMap是线程不安全的</li>
<li>HashTable不允许null 键和null值，HashMap允许一个null键和任意个null值</li>
</ol>
<p>由于HashMap是线程不安全的，所以在并发环境下执行put操作可能会引起死循环，导致CPU利用率达到100%.</p>
<p>原因是因为多线程导致HashMap的Entry链表形成环形数据结构</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap通过<strong>分段锁</strong>机制（一种粒度更细的加锁机制）来提供更高的并发性与伸缩性。同时提供的迭代器不会抛出ConcurrentModificationException异常，而是返回具有弱一致性（Weakly Consistent）的迭代器。</p>
<p>size方法返回一个近似值而不是一个精确值。</p>
<p><strong>注意</strong>：只有当应用程序需要加锁Map以进行独占访问时，才使用1和2方式，否则最好采用ConcurrentHashMap</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>juc中提供了以下几种常用实现：</p>
<ul>
<li>LinkedBlockingQueue</li>
<li>ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>Java 6增加了两个容器：Deque和BlockingDeque。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和删除。具体实现包括ArrayDeque和LinkedBlockingDeque。双端队列的一个典型应用场景：工作窃取（Work Stealing），而工作窃取的典型实现案例：Fork/Join框架</p>
<h4 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h4><ul>
<li>CountDownLatch</li>
<li>Semaphore </li>
<li>CyclicBarrier</li>
<li>Exchanger</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程可以有如下 6 种状态(线程状态在java.lang.Thread.State枚举中定义)：</p>
<ul>
<li>New（新创建）</li>
<li>Runnable（可运行）</li>
<li>Blocked（被阻塞）</li>
<li>Waiting（等待）</li>
<li>Timed waiting（计时等待）</li>
<li>Terminated（被终止）</li>
</ul>
<h4 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h4><p>当用 new 操作符创建一个新线程时，如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。</p>
<h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线程可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。</p>
<h4 id="阻塞线程和等待线程"><a href="#阻塞线程和等待线程" class="headerlink" title="阻塞线程和等待线程"></a>阻塞线程和等待线程</h4><h4 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h4><p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>run方法正常退出而自然终止</li>
<li>因为一个没有捕获的异常终止的run方法而意外终止</li>
</ul>
<p><code>java.lang.Thread 1.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待终止指定的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待指定的线程终止或者经过指定的毫秒数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程状态 NEW/RUNNABLE/BLOCKED/WAITING/TIMED_WAITING/TERMINATED</span></span><br><span class="line">Thread.<span class="function">State <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导致当前执行线程处于让步状态。 如果有其他的可运行线程具有至少与此线程同样高的优先级， 那么这些线程接下来会被调度。 注意，这是一个静态方法。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>包括线程优先级、守护线程、线程组以及处理未捕获异常的处理器</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在 Java 程序设计语言中，每一个线程有一个优先级。默认情况下， 一个线程继承它的父线程的优先级。可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5。</p>
<p>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。 但是， 线程 优先级是<strong>高度依赖于系统的</strong>。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多， 也许更少。</p>
<p>线程优先级是高度依赖于系统的。例如，Windows 有 7 个优先级别。一些 Java 优先级将映射到相同的操作系统优先级。在Oracle 为 Linux 提供的 Java 虚拟机中，线程的优先级被忽略，即所有线程具有相同的优先级</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>通过调用<code>t.setDaemon(true)</code>将线程转换为守护线程（daemon thread)。守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时， 虚拟机就退出了。守护线程应该永远不去访问固有资源， 如文件、 数据库， 因为它会在任何时候甚至在一个操作的中间发生中断。</p>
<h4 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h4><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>用ReentrantLock保护代码块的基本结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myLock.lock();<span class="comment">//a ReentrantLock object</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    myLock.unlock();<span class="comment">//make sure the lock is unlocked even if an exception is thrown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一结构确保任何时刻只有一个线程进入临界区。</p>
<p><strong>注意</strong>：把解锁操作括在 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则， 其他线程将永远阻塞</p>
<p>锁是可重入的， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（ hold count) 来跟踪对 lock 方法的嵌套调用。线程在每一次调用 lock 都要调用 unlock 来释放锁。由于这一特性， 被一个锁保护的代码可以调用另一个使用相同的锁的方法。</p>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常， 线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。</p>
<p>一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sufficientFunds = bankLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    bankLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">            sufficientFunds.await();<span class="comment">//余额不足时，阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//transfer funds</span></span><br><span class="line">        ...</span><br><span class="line">        sufficientFunds.signalAll();<span class="comment">//唤起所有在该条件上等待的线程</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        bankLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意调用 signalAll 不会立即激活一个等待线程。它仅仅解除等待线程的阻塞， 以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。</p>
<p>另一个方法 signal, 则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行， 那么它再次被阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了。</p>
<p><code>java.util.concurrent.locks.Lock 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个与该锁相关的条件对象</span></span><br><span class="line"><span class="function">Condition new <span class="title">Condition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.locks.Condition 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将该线程放到条件的等待集中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒在该条件上阻塞的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒在该条件上阻塞的某一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>内部锁和条件存在一些局限。包括：</p>
<ul>
<li>不能中断一个正在试图获取锁的线程</li>
<li>试图获得锁时不能设定超时</li>
<li>每个锁仅有单一的条件，可能是不够的</li>
</ul>
<p>关于ReentrantLock和Synchronized的一些使用建议：</p>
<ul>
<li>最好既不使用 Lock/Condition 也不使用 synchronized 关键字。 在许多情况下你可以使用java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。</li>
<li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它， 这样可以减少编写的代 码数量， 减少出错的几率。</li>
<li>如果特别需要 Lock/Condition 结构提供的独有特性时， 才使用 Lock/Condition。</li>
</ul>
<p><code>java.lang.Object 1.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除那些在该对象上调用 wait 方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。 如果当前线程不是对象锁的持有者， 该方法拋出一个 IllegalMonitorStateException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//随机选择一个在该对象上调用 wait 方法的线程， 解除其阻塞状态。 该方法只能在一 个同步方法或同步块中调用。 如果当前线程不是对象锁的持有者， 该方法抛出一个 IllegalMonitorStateException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//导致线程进入等待状态直到它被通知。该方法只能在一个同步方法中调用。 如果当前线程不是对象锁的持有者， 该方法拋出一个 IllegalMonitorStateException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//导致线程进入等待状态直到它被通知或者经过指定的时间。 这些方法只能在一个同步方法中调用。如果当前线程不是对象锁的持有者该方法拋出一个 IllegalMonitorStateException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><h4 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h4><p>volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p>
<p><strong>Volatile 变量不能提供原子性。</strong></p>
<h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h4><p>使用final声明一个共享变量时，多个线程可以安全的访问该共享变量，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他线程会在构造函数完成构造之后才看到这个 accounts 变量,如果不使用 final 就不能保证其他线程看到的是 accounts 更新后的值， 它们可能都只是看到null, 而不是新构造的HashMap。</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;String,Double&gt; account = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//final只是使account这个引用不允许改变</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：对这个映射表的操作并不是线程安全的。 如果多个线程在读写这个映射表， 仍然需要进行同步。</p>
<h4 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h4><p>java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性。 例如， Atomiclnteger 类提供了方法 incrementAndGet 和decrementAndGet, 它们分别以原子方式将一个整数自增或自减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong nextNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//In some thread</span></span><br><span class="line"><span class="comment">//incrementAndGet 方法以原子方式将 AtomicLong 自增， 并返回自增后的值。 也就是说， 获得值、 增 1 并设置然后生成新值的操作不会中断。</span></span><br><span class="line"><span class="keyword">long</span> id = nextNumber.incrementAndGet();</span><br></pre></td></tr></table></figure>

<p>但是，如果希望完成更复杂的更新， 就必须使用 compareAndSet 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong largest = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//In some thread</span></span><br><span class="line">largest.set(Math.max(largest.get(),observed))<span class="comment">//线程不安全</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  oldValue = largest.get();</span><br><span class="line">  newValue = Math.max(oldValue,observed);</span><br><span class="line">&#125;<span class="keyword">while</span>(!largest.compareAndSet(oldValue,newValue))<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure>

<p>如果另一个线程也在更新 largest 就可能阻止这个线程更新。compareAndSet 会返回false, 而不会设置新值。在这种情况下，循环会再次尝试，读取更新后的值，并尝试 修改。 最终， 它会成功地用新值替换原来的值。 compareAndSet 方法会映射到一个处理器操作， 比使用锁速度更快。</p>
<p>Java8 就不用再写这样的样板式代码，可以使用Lambda表达式替代，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">largest.updateAndGet(x -&gt; Math.max(x,observed));</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">largest.accumulateAndGet(observed,Math::max);<span class="comment">//accumulateAndGet 方法利用一个二元操作符来合并原子值和所提供的参数。</span></span><br></pre></td></tr></table></figure>

<p>如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重 试。Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。 LongAdder 包括多 个变量(加数)， 其总和为当前值。可以有多个线程更新不同的加数， 线程个数增加时会自动 提供新的加数。 通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况， 这种方法会很高效。 性能会有显著的提升。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>要避免共享变量， 使用ThreadLocal 辅助类为各个线程提供各自的实例。 例如SimpleDateFormat 类不是线程安全的。假设有一个静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="comment">//线程不安全</span></span><br><span class="line">String dateStamp = dateFormat.format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>可以通过为每个线程构造一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = </span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line"><span class="comment">//在一个给定线程中首次调用 get 时， 会调用 initialValue 方法。在此之后， get 方法会返回属于当前线程的那个实例</span></span><br><span class="line">String dateStamp = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>在多个线程中生成随机数也存在类似的问题。java.util.Random 类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器， 这会很低效。</p>
<p>可以使用 ThreadLocal 辅助类为各个线程提供一个单独的生成器， 不过 Java SE 7 还另外提供了一个便利类。只需要做以下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalRandom.current() 调用会返回特定于当前线程的 Random 类实例。</span></span><br><span class="line"><span class="keyword">int</span> random = ThreadLocalRandom.current().nextInt(upperBound);</span><br></pre></td></tr></table></figure>

<p><code>java.lang.ThreadLocal&lt;T&gt; 1.2</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到这个线程的当前值。如果是首次调用 get, 会调用 initialize 来得到这个值</span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//应覆盖这个方法来提供一个初始值。默认情况下，这个方法返回 mill。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置新值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="comment">//删除对应线程的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//创建一个线程局部变量， 其初始值通过调用给定的 supplier 生成。</span></span><br><span class="line"><span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt;  <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h4><p>线程在调用 lock 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。应该更加谨慎地申请锁。tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则， 立即返回false, 而且线程可以立即离开去做其他事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(myLock.tryLock())&#123;</span><br><span class="line">    <span class="comment">//now the thread owns the lock</span></span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;myLock.unlock();&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.locks.Lock 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试获得锁而没有发生阻塞；如果成功返回真。这个方法会抢夺可用的锁， 即使该锁有公平加锁策略， 即便其他线程已经等待很久也是如此。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//尝试获得锁，阻塞时间不会超过给定的值；如果成功返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//获得锁， 但是会不确定地发生阻塞。如果线程被中断， 抛出一个 InterruptedException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.locks.Condition 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进人该条件的等待集， 直到线程从等待集中移出或等待了指定的时间之后才解除阻塞。如果因为等待时间到了而返回就返回 false , 否 则 返 回 true。如果等待的线程被中断， await 方法将抛出一个 InterruptedException 异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//进人该条件的等待集， 直到线程从等待集移出才解除阻塞。如果线程被中断， 该方法不会抛出 InterruptedException 异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读/写锁"></a>读/写锁</h4><p>如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，ReentrantReadWriteLock非常适合这类场景。</p>
<p>使用读/写锁的必要步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 构造一个ReentrantReadWriteLock对象</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//2. 抽取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock readLock = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock writeLock = rwl.writeLock();</span><br><span class="line"><span class="comment">//3. 对所有的获取方法加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;readLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. 对所有的修改方法加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;writeLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.concurrent.locks.ReentrantReadWriteLock 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到一个可以被多个读操作共用的读锁， 但会排斥所有写操作。</span></span><br><span class="line"><span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//得到一个写锁， 排斥所有其他的读操作和写操作。</span></span><br><span class="line"><span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生 产者线程向队列插入元素， 消费者线程则取出它们。 使用队列， 可以安全地从一个线程向另 一个线程传递数据。 当试图向队列添加元素而队列已满， 或是想从队列移出元素而队列为空的时候， 阻塞队 列(blocking queue ) 导致线程阻塞。 在协调多个线程之间的合作时， 阻塞队列是一个有用的 工具。 </p>
<p>阻塞队列方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动作</th>
<th>特殊情况下的动作</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加一个元素</td>
<td>如果队列满，则抛出IllegalStateException异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列的头元素</td>
<td>如果队列空，则抛出NoSuchElementException异常</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回头元素</td>
<td>如果队列空，则抛出NoSuchElementException异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列满，则返回false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列的头元素</td>
<td>如果队列空，则返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移出并返回头元素</td>
<td>如果队列空，则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满，则阻塞</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回头元素</td>
<td>如果队列空，则阻塞</td>
</tr>
</tbody></table>
<p>大体分为3类：抛出异常、返回null、阻塞</p>
<p>java.util.concurrent 包提供了阻塞队列的几个变种：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>LinkedBlockingDeque</li>
</ul>
<p>JavaSE 7 增加了一个 TransferQueue 接口， 允许生产者线程等待， 直到消费者准备就绪 可以接收一个元素。 如果生产者调用<code>q.transfer(item)</code>，这个调用会阻塞，直到另一个线程将元素（item）删除。LinkedTransferQueue实现了该接口。</p>
<p><code>java.util.concurrent.ArrayBlockingQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个带有指定的容量和公平性设置的阻塞队列。 该队列用循环数组实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.LinkedBlockingQueue&lt;E&gt; 5.0</code></p>
<p><code>java.util.concurrent.LinkedBlockingDeque&lt;E&gt; 6.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个无上限的阻塞队列或双向队列， 用链表实现。实际上有容量上限，容量上限为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定容量构建一个有限的阻塞队列或双向队列， 用链表实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.DelayQueue&lt;E extends Delayed&gt;  5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个包含 Delayed 元素的无界的阻塞时间有限的阻塞队列。 只有那些延迟已经超 过时间的元素可以从队列中移出。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.Delayed 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到该对象的延迟， 用给定的时间单位进行度量。</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.PriorityBlockingQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span>;</span><br><span class="line"><span class="comment">//构造一个无边界阻塞优先队列， 用堆实现。</span></span><br><span class="line"><span class="comment">//参数: initialCapacity 优先队列的初始容量。 默认值是 11。</span></span><br><span class="line"><span class="comment">//		 comparator 用来对元素进行比较的比较器， 如果没有指定， 则元素必须 实现 Comparable 接口。</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.BlockingQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个元素，如果队列已满则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回头元素，如果队列为空则阻塞</span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//添加一个元素，如果队列已满则最多等待指定（timeout）时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回头元素，如果队列为空，则最多等待超时时间为timeout，单位为TimeUnit</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.BlockingDeque&lt;E&gt; extends BlockingQueue&lt;E&gt;,Deque&lt;E&gt; 6</code> 接口支持多继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向队列头尾添加元素，如果队列已满则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回队列头尾元素，如果队列为空则阻塞</span></span><br><span class="line"><span class="function">E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function">E <span class="title">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列头尾添加元素，如果队列已满则等待指定的超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//移除并返回头尾元素，如果队列为空则等待指定的超时时间</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.TransferQueue&lt;E&gt; extends BlockingQueue&lt;E&gt;  7</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//传输元素给消费者，如果此时正好有一个消费者在接收它（take）或者正好在等待时间内（poll(long,TimeUnit)）则立刻传输，否则阻塞等待直到消费者接收，或者等待时间超时（timeout）则返回false</span></span><br></pre></td></tr></table></figure>

<h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><h4 id="高效的映射、集合和队列"><a href="#高效的映射、集合和队列" class="headerlink" title="高效的映射、集合和队列"></a>高效的映射、集合和队列</h4><p>java.util.concurrent 包提供了映射、 有序集和队列的高效实现: ConcurrentHashMap、 ConcurrentSkipListMap、ConcurrentSkipListSet 和 ConcurrentLinkedQueue。</p>
<p>这些集合使用复杂的算法， 通过允许并发地访问数据结构的不同部分来使竞争极小化。与大多数集合不同， size 方法不必在常量时间内操作。 确定这样的集合当前的大小通常 需要遍历。</p>
<p><strong>注意</strong>：散列映射将有相同散列码的所有条目放在同一个“ 桶” 中。有些应用使用的散列函 数不当， 以至于所有条目最后都放在很少的桶中， 这会严重降低性能。 即使是一般意义上 还算合理的散列函数，如String类的散列函数，也可能存在问题。例如，攻击者可能会制 造大量有相同散列值的字符串， 让程序速度减慢。 在 JavaSE 8 中， 并发散列映射将桶组织 为树， 而不是列表， 键类型实现了 Comparable, 从而可以保证性能为 O(log(8))。</p>
<p><code>java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt; 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个可以被多线程安全访问的无边界非阻塞的队列。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.ConcurrentSkipListSet&lt;E&gt; 6</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span>;</span><br><span class="line"><span class="comment">//构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现 Comparable 接口。</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.concurrent.ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;  5.0</code></p>
<p><code>java.util.concurrent.ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentNavigableMap&lt;K,V&gt; 6</code></p>
<h4 id="写数组拷贝"><a href="#写数组拷贝" class="headerlink" title="写数组拷贝"></a>写数组拷贝</h4><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//阻塞等待获取结果 如果运行该计算的线程被中断， 拋出IntermptedException</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">  <span class="comment">//阻塞等待获取结果，如果等待超时抛出TimeoutException，如果运行该计算的线程被中断， 拋出IntermptedException</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">  <span class="comment">// 如果任务已经完成、任务已经取消、任务因为其他原因不能取消则返回false；如果计算还没有开始， 它被取消且不再开始。 如果任务已经开始，则mayInterruptIfRunning参数确定在尝试停止任务时是否应中断执行此任务的线程。</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">  <span class="comment">//如果任务在完成之前被取消了则返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//如果任务完成则返回true，任务正常终止、异常返回或者取消都算是任务完成</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask 包装器是一种非常便利的机制， 可将 Callable 转换成 Future 和 Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; compute = ...;</span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask(compute);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(task);<span class="comment">//it's a Runnable</span></span><br><span class="line">thread.start();</span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p> Executors 类有许多静态工厂方法用来构建线程池</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td>该池包含固定数量的线程; 空闲线程会一直被保留</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程; 空闲线程会被保留 60 秒</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池， 替代 java.util.Timer</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的 “ 池”， 该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建的单线程 “ 池”</td>
</tr>
</tbody></table>
<p>以上方法内部都是通过ThreadPoolExecutor创建线程池，该类实现ExecutorService接口，该接口提供了三个方法进行任务的执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>当用完一个线程池的时候， 调用 shutdown。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后， 线程池中的线程死亡。另一种方法是调用 shutdownNow。该池取消尚未开始的所有任务并试图中断正在运行的线程.</p>
<p>newScheduledThreadPool和newSingleThreadScheduledExecutor返回实现ScheduledExecutorService接口的线程池，该接口具有延迟执行和定期执行的能力。</p>
<p><code>java.util.concurrent.ScheduledExecutorService 5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定的延迟时间之后执行一次</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,<span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预定在初始的延迟结束后， 周期性地运行给定的任务， 周期长度是 period。第一次执行时间为initialDelay，第二次为initialDelay + period，第三次为initialDelay + 2*period，以此类推。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"><span class="comment">//预定在初始的延迟结束后周期性地运行给定的任务， 在一次调用完成和下一次调用开始之间有长度为 delay 的延迟。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><h3 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/21/java-core-Java-Fundamentals-Two/" rel="prev" title="Java核心技术 - 基础知识卷2">
      <i class="fa fa-chevron-left"></i> Java核心技术 - 基础知识卷2
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/19/java-concurrency-visibility-atomicity-orderly/" rel="next" title="Java并发编程基础理论(一)——可见性、原子性、有序性">
      Java并发编程基础理论(一)——可见性、原子性、有序性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程概念"><span class="nav-number">1.1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程带来的好处"><span class="nav-number">1.2.</span> <span class="nav-text">线程带来的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程带来的问题"><span class="nav-number">1.3.</span> <span class="nav-text">线程带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性"><span class="nav-number">1.4.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存可见性"><span class="nav-number">1.5.</span> <span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile"><span class="nav-number">1.6.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布和逸出"><span class="nav-number">1.7.</span> <span class="nav-text">发布和逸出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程封闭"><span class="nav-number">1.8.</span> <span class="nav-text">线程封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ad-hoc线程封闭"><span class="nav-number">1.8.1.</span> <span class="nav-text">Ad-hoc线程封闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈封闭"><span class="nav-number">1.8.2.</span> <span class="nav-text">栈封闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">1.8.3.</span> <span class="nav-text">ThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不变性"><span class="nav-number">1.9.</span> <span class="nav-text">不变性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步容器"><span class="nav-number">2.</span> <span class="nav-text">同步容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">2.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">2.2.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">2.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">2.4.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步工具类"><span class="nav-number">2.5.</span> <span class="nav-text">同步工具类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程状态"><span class="nav-number">3.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新创建线程"><span class="nav-number">3.1.</span> <span class="nav-text">新创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可运行线程"><span class="nav-number">3.2.</span> <span class="nav-text">可运行线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞线程和等待线程"><span class="nav-number">3.3.</span> <span class="nav-text">阻塞线程和等待线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#被终止的线程"><span class="nav-number">3.4.</span> <span class="nav-text">被终止的线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程属性"><span class="nav-number">4.</span> <span class="nav-text">线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程优先级"><span class="nav-number">4.1.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#守护线程"><span class="nav-number">4.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#未捕获异常处理器"><span class="nav-number">4.3.</span> <span class="nav-text">未捕获异常处理器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步"><span class="nav-number">5.</span> <span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#锁对象"><span class="nav-number">5.1.</span> <span class="nav-text">锁对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件对象"><span class="nav-number">5.2.</span> <span class="nav-text">条件对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">5.3.</span> <span class="nav-text">synchronized关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监视器"><span class="nav-number">5.4.</span> <span class="nav-text">监视器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Volatile域"><span class="nav-number">5.5.</span> <span class="nav-text">Volatile域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final变量"><span class="nav-number">5.6.</span> <span class="nav-text">final变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性-1"><span class="nav-number">5.7.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">5.8.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程局部变量"><span class="nav-number">5.9.</span> <span class="nav-text">线程局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁测试与超时"><span class="nav-number">5.10.</span> <span class="nav-text">锁测试与超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读-写锁"><span class="nav-number">5.11.</span> <span class="nav-text">读&#x2F;写锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列"><span class="nav-number">6.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的集合"><span class="nav-number">7.</span> <span class="nav-text">线程安全的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高效的映射、集合和队列"><span class="nav-number">7.1.</span> <span class="nav-text">高效的映射、集合和队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写数组拷贝"><span class="nav-number">7.2.</span> <span class="nav-text">写数组拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">8.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">9.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join"><span class="nav-number">10.</span> <span class="nav-text">Fork-Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">11.</span> <span class="nav-text">CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步器"><span class="nav-number">12.</span> <span class="nav-text">同步器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">12.1.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">12.2.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">12.3.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exchanger"><span class="nav-number">12.4.</span> <span class="nav-text">Exchanger</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZGQ"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZGQ</p>
  <div class="site-description" itemprop="description">Java</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengguoqiang927" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengguoqiang927" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengguoqiang927@gmail.com" title="E-Mail → mailto:zhengguoqiang927@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">左耳朵耗子</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;" rel="noopener" target="_blank">廖雪峰</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZGQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">201k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:03</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://johnson-5.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/04/30/java-concurrency-Concurrency-Programming/";
    this.page.identifier = "2020/04/30/java-concurrency-Concurrency-Programming/";
    this.page.title = "Java并发编程";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://johnson-5.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
