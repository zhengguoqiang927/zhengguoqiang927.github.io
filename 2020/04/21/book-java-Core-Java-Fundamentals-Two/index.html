<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Georgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="异常、断言和日志 官方文档地址：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;essential&#x2F;exceptions&#x2F;definition.html">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术 - 基础知识卷2">
<meta property="og:url" content="http://yoursite.com/2020/04/21/book-java-Core-Java-Fundamentals-Two/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="异常、断言和日志 官方文档地址：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;essential&#x2F;exceptions&#x2F;definition.html">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_exception_architype.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_interface.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_implements.png">
<meta property="article:published_time" content="2020-04-21T15:35:49.000Z">
<meta property="article:modified_time" content="2020-06-12T02:29:24.709Z">
<meta property="article:author" content="ZGQ">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_exception_architype.png">

<link rel="canonical" href="http://yoursite.com/2020/04/21/book-java-Core-Java-Fundamentals-Two/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java核心技术 - 基础知识卷2 | Z's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/book-java-Core-Java-Fundamentals-Two/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ZGQ">
      <meta itemprop="description" content="Java">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java核心技术 - 基础知识卷2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 23:35:49" itemprop="dateCreated datePublished" datetime="2020-04-21T23:35:49+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-12 10:29:24" itemprop="dateModified" datetime="2020-06-12T10:29:24+08:00">2020-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/04/21/book-java-Core-Java-Fundamentals-Two/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/21/book-java-Core-Java-Fundamentals-Two/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><blockquote>
<p>官方文档地址：<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html</a></p>
</blockquote>
<a id="more"></a>

<h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_exception_architype.png" alt="Java异常层次结构"></p>
<p>所有异常类都继承Throwable类，两大子类分别是Error和Exception。Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。Exception又分为RuntimeException和checked异常，划分两个分支的规则是：由程序错误导致的异常属于 RuntimeException，运行时异常属于unchecked异常; 而程序本身没有问题， 但程序中的一些代码会主动抛出checked异常，如果不处理这些异常则编译不通过。</p>
<p><strong>unchecked异常</strong>：是指编译时期不检测的异常</p>
<p><strong>checked异常</strong>：是指编译时期进行检测的异常，这种异常必须进行处理（try-catch）或者用throws关键字抛出异常</p>
<p>Java 语 言 规 范 将 派 生 于 Error 类 或 RuntimeException 类的所有异常称为非受查( unchecked ) 异常，所有其他的异常称为受查（ checked) 异常。</p>
<p>RuntimeException异常包括：</p>
<ul>
<li>错误的类型转换</li>
<li>数组下标越界</li>
<li>空指针异常</li>
</ul>
<h4 id="JVM异常处理过程"><a href="#JVM异常处理过程" class="headerlink" title="JVM异常处理过程"></a>JVM异常处理过程</h4><h5 id="默认异常处理"><a href="#默认异常处理" class="headerlink" title="默认异常处理"></a>默认异常处理</h5><p>当方法内出现异常时，该方法会创建一个异常对象，并将其传递给JVM。异常对象包含名字、异常描述和发生异常时当前程序的状态。创建异常对象并把它移交给JVM的过程叫做 <strong>抛出异常</strong> 。这里有一个被调用方法的方法列表，用来查找异常发生的方法。这个方法列表就是  <strong>调用堆栈（Call Stack）</strong> 。执行过程如下：</p>
<ul>
<li>JVM去调用堆栈里查找相应的方法，该方法含有处理当前发生的异常的代码块。这个代码块就是 <strong>异常处理器（Exception Handler）</strong></li>
<li>JVM从异常发生的方法开始在调用堆栈里倒序搜索</li>
<li>如果找到了合适的异常处理器，就把异常传给他。合适的处理器意味着它能处理的异常类型正好匹配抛出异常的类型</li>
<li>如果JVM检索了调用堆栈里的所有方法，都没有找到合适的处理器，JVM就会把异常对象传递给<strong>默认异常处理器（default exception handler）</strong> ，该处理器属于JVM自身的一部分。该处理器打印异常信息并且异常终止程序。打印的异常信息格式如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"xxx"</span> Name of Exception : Description</span><br><span class="line">... ...... ..  <span class="comment">// Call Stack</span></span><br></pre></td></tr></table></figure>

<p>JVM在调用堆栈上检索包含合适的异常处理器的方法流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to demonstrate exception is thrown </span></span><br><span class="line"><span class="comment">// how the runTime system searches th call stack </span></span><br><span class="line"><span class="comment">// to find appropriate exception handler. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThrown</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// It throws the Exception(ArithmeticException). </span></span><br><span class="line">	<span class="comment">// Appropriate Exception handler is not found within this method. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideByZero</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// this statement will cause ArithmeticException(/ by zero) </span></span><br><span class="line">		<span class="keyword">int</span> i = a/b; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> i; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The runTime System searches the appropriate Exception handler </span></span><br><span class="line">	<span class="comment">// in this method also but couldn't have found. So looking forward </span></span><br><span class="line">	<span class="comment">// on the call stack. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeDivision</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> res =<span class="number">0</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123; </span><br><span class="line">		res = divideByZero(a,b); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// doesn't matches with ArithmeticException </span></span><br><span class="line">		<span class="keyword">catch</span>(NumberFormatException ex) </span><br><span class="line">		&#123; </span><br><span class="line">		System.out.println(<span class="string">"NumberFormatException is occured"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> res; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// In this method found appropriate Exception handler. </span></span><br><span class="line">	<span class="comment">// i.e. matching catch block. </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">int</span> i = computeDivision(a,b); </span><br><span class="line">		</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// matching ArithmeticException </span></span><br><span class="line">		<span class="keyword">catch</span>(ArithmeticException ex) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// getMessage will print description of exception(here / by zero) </span></span><br><span class="line">			System.out.println(ex.getMessage()); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h5><p>自定义异常处理可以通过5个关键字：try、catch、throw、throws和finally。</p>
<p>try对能够引发异常的代码进行包裹；catch对抛出的异常进行捕获处理；手动抛出异常使用throw关键字；通过throws语句指定从方法抛出的异常；抛出异常后还有一些必须要执行的代码（比如释放数据库连接）则放在finally代码块中。</p>
<h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>编写方法时不必将所有可能抛出的异常都进行声明，遇到下面 4 种情况时应该抛出异常：</p>
<ol>
<li>调用一个抛出受査异常的方法， 例如， FilelnputStream 构造器</li>
<li>程序运行过程中发现错误， 并且利用 throw语句抛出一个受查异常</li>
<li>程序出现错误， 例如，a[-l]=0 会抛出一个 ArraylndexOutOffloundsException 这样的非受查异常</li>
<li>Java 虚拟机和运行时库出现的内部错误</li>
</ol>
<p>如果没有处理器捕获这个异常，当前执行的线程就会结束。</p>
<p>一个方法必须声明所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生（ RuntimeException)。如果方法没有声明所有可能发生的受查异常， 编译器就会发出一个错误消息。</p>
<h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">EOFException e = <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<p>注意：一旦方法抛出了异常， 这个方法就不可能返回到调用者。也就是说， 不必为返回的默认值或错误代码担忧</p>
<h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>自定义异常类：定义一个派生于Exception 的类，或者派生于 Exception 子类的类。定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器（超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="keyword">extends</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Throwable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个Throwable对象</span></span><br><span class="line">Throwable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个带异常详细描述信息的Throwable对象</span></span><br><span class="line">Throwable(String message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得Throwable对象的详细描述信息</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>捕获异常的规则：</p>
<ol>
<li>应该捕获那些知道如何处理的异常， 而将那些不知道怎样处理的异常继续进行传递。</li>
<li>所有异常都进行捕获处理有时也是不合理的，有时需要将异常传递给调用者，让调用者知道发生了什么异常并且进行处理</li>
</ol>
<h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><p>catch子句中也可以抛出异常，这样可以改变异常的类型。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//access the database</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"database error:"</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种更好的处理方式，可以让调用者知道原始异常产生的原因，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//access the database</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当捕获到异常时，可以使用该语句获取到原始异常</span></span><br><span class="line">Throwable e = se.getCause();</span><br></pre></td></tr></table></figure>

<p>如果在一个方法中发生了一个受查异常， 而不允许抛出它， 那么包装技术就十分有用。我们可以捕获这个受查异常，并将它包装成一个运行时异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//access the database</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    logger.log(level,message,e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h4><p>通常用于释放资源，如关闭数据库连接等等，不管是否有异常被捕获，finally 子句中的代码都被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    show error message;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，有下列 3 种情况会执行 finally 子句:</p>
<ol>
<li>代码没有抛出异常。在这种情况下， 程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码t 随后， 继续执行 try 语句块之后的第一条语句。也就是说，执行标注的 1、 2、 5、 6 处</li>
<li>抛出一个在 catch 子句中捕获的异常。<ol>
<li>如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。</li>
<li>如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注1、 3、 5 处的语句。</li>
</ol>
</li>
<li>代码抛出了一个异常， 但这个异常不是由 catch 子句捕获的。在这种情况下，程序将<br>执行 try 语句块中的所有语句，直到有异常被抛出为止。此时， 将跳过 try 语句块中的剩余代码， 然后执行 finally 子句中的语句， 并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。</li>
</ol>
<p>try 语句可以只有 finally 子句，而没有 catch 子句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种做法无论try块中是否有异常，finally都会执行。当遇到异常时会将异常抛出给调用者</span></span><br><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//code that might throw exceptions</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 当finally子句中有return语句时，返回值将会覆盖原始的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值 4。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的try语句</h4><p>假设资源属于一个实现了 AutoCloseable 接口的类，AutoCloseable 接口有一个方法：<code>void close() throws Exception</code>，Java SE 7之后可以用带资源的 try 语句（try-with-resources) 自动调用close方法来关闭资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try块退出时，会自动调用 res.doseO。</span></span><br><span class="line"><span class="keyword">try</span>(Resource res=...)&#123;</span><br><span class="line">    <span class="comment">//work with res</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个块正常退出时， 或者存在一个异常时， 都会调用 in.close() 方法。类似于finally子句的效果</span></span><br><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"/usr/share/dict/words"</span>),<span class="string">"UTF-8"</span>))&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">        System.out.println(in.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带资源的 try 语句会将原来的异常重新抛出，而 close方法抛出的异常会”被抑制”， 这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法，它会得到从 close 方法抛出并被抑制的异常列表</p>
<p>带资源的 try 语句自身也可以有 catch 子句和一个 finally 子句。这些子句会在资源关闭后执行。但通常为了避免繁琐不会再加这么多子句。</p>
<h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹（ stack trace ) 是一个方法调用过程的列表， 它包含了程序执行过程中方法调用的特定位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Throw t = <span class="keyword">new</span> Throwable();</span><br><span class="line"><span class="comment">//printStackTrace 方法访问堆栈轨迹的文本描述信息</span></span><br><span class="line">t.printStackTrace();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更灵活的方法是使用 getStackTrace 方法</span></span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="comment">//StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法， 还含有能够获得类名和方法名的方法</span></span><br><span class="line"><span class="keyword">for</span>(StackTraceElement frame :frames)&#123;</span><br><span class="line">    <span class="comment">//analyze frame</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有线程的堆栈轨迹</span></span><br><span class="line">Map&lt;Thread,StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line"><span class="keyword">for</span>(Thread t : map.keySet())&#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    <span class="comment">//analyze frames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Throwable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用给定的异常原因构造一个Throwable对象</span></span><br><span class="line">Throwable(Throwable cause);</span><br><span class="line">Throwable(String message,Throwable cause);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置异常原因，如果已经设置过，则抛出一个异常</span></span><br><span class="line"><span class="function">Throwable <span class="title">initCause</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取异常原因，如果没设置则返回null</span></span><br><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得构造这个对象时调用堆栈的跟踪，获取当前执行点的堆栈轨迹</span></span><br><span class="line">StackTraceElement[] getStackTrace();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为这个异常增加一个“ 抑制” 异常。这出现在带资源的 try语句中， 其中 t 是 close 方法抛出的一个异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSuppressed</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line"><span class="comment">//得到这个异常的所有“ 抑制” 异常。一般来说，这些是带资源的 try语句中 close 方法拋出的异常。</span></span><br><span class="line">Throwable[] getSuppressed();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.Exception</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用给定的“ 原因” 构造一个异常对象</span></span><br><span class="line">Exception(Throwable cause);</span><br><span class="line">Exception(String messge,Throwable cause);</span><br></pre></td></tr></table></figure>

<h4 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h4><ol>
<li>异常处理不能代替简单的测试，只在异常情况下使用异常机制</li>
<li>不要过分地细化异常</li>
<li>利用异常层次结构</li>
<li>不要压制异常</li>
<li>在检测错误时，“ 苛刻 ” 要比放任更好（早抛出）</li>
<li>不要羞于传递异常（晚捕获）</li>
</ol>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。</p>
<p>Java 语言引人了关键字 assert。这个关键字有两种形式：</p>
<ul>
<li>assert 条件；</li>
<li>assert 条件：表达式；</li>
</ul>
<p>这两种形式都会对条件进行检测， 如果结果为 false, 则抛出一个 AssertionError 异常。在第二种形式中，表达式将被传入 AssertionError 的构造器， 并转换成一个消息字符串。</p>
<h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>在默认情况下， 断言被禁用。可以在运行程序时用 -enableassertions 或 -ea 选项启用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -enableassertions MyApp</span><br></pre></td></tr></table></figure>

<p>需要注意的是， 在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器( class loader) 的功能。当断言被禁用时， 类加载器将跳过断言代码， 因此，不会降低程序运行的速度。</p>
<p>可以用选项 -disableassertions 或 -da 禁用某个特定类和包的断言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -disableassertions MyApp</span><br></pre></td></tr></table></figure>

<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h3><p>类型参数（ type parameters)的魅力在于：使得程序具有更好的可读性和安全性。</p>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p>一个泛型类（ generic class) 就是具有一个或多个类型变量的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T seconde;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;first = <span class="keyword">null</span>;second=<span class="keyword">null</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;<span class="keyword">this</span>.first = first;<span class="keyword">this</span>.second = second&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pair 类引人了一个类型变量 T，用尖括号 ( &lt; &gt;) 括起来，并放在类名的后面。泛型类可以有多个类型变量。像这样</p>
<p><code>public class Pair&lt;T,U&gt;{......}</code></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</span><br><span class="line">    <span class="comment">//类型变量放在修饰符（这里是 public static) 的后面，返回类型的前面。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length /<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String middle  = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></table></figure>

<p>实际使用时可以省略<code>&lt;String&gt;</code> ,编译器会通过参数类型进行类型推导出泛型类型T是String类型。</p>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T smallest = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决这个问题的方案是将 T 限制为实现了 Comparable 接口（只含一个方法 compareTo 的标准接口）的类。可以通过对类型变量 T 设置限定（bound) 实现这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>T extends  BoundingType</code>表示 T 应该是绑定类型的子类型 （subtype)。T 和绑定类型可以是类， 也可以是接口。一个类型变量或通配符可以有多个限定， 例如：</p>
<p><code>T extends Comparable &amp; Serializable</code>限定类型用“ &amp;” 分隔，而逗号用来分隔类型变量。在 Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个</p>
<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机没有泛型类型对象—— 所有对象都属于普通类。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型 （ raw type )。原始类型的名字就是删去类型参数后的泛型类型名。擦除（ erased) 类型变量, 并替换为限定类型（无限定的变量用 Object)。</p>
<p>Pair<T>的原始类型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用 Object 替换。例如，类 Pair<T> 中的类型变量没有显式的限定， 因此， 原始类型用 Object 替换 T。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>〉<span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span> <span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; lower = second; upper = first; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型Interval如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable first,Comparable second)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调换了Comparable &amp; Serializable的顺序 ，原始类型用 Serializable 替换 T, 而编译器在必要时要向Comparable 插入强制类型转换。为了提高效率，应该将标签（tagging) 接口（即没有方法的接口）放在边界列表的末尾。</p>
<h4 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h4><p>当程序调用泛型方法时，如果擦除返回类型， 编译器插入强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure>

<p>擦除 getFirst 的返回类型后将返回 Object 类型。编译器自动插人 Employee 的强制类型转换。</p>
<p>也就是说，编译器把这个方法调用翻译为两条虚拟机指令：</p>
<ul>
<li>对原始方法Pair.getFirst的调用</li>
<li>将返回的Object类型强制转换成Employee类型</li>
</ul>
<h4 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h4><p>通过插入桥方法（bridge method）来保持多态性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;setSecond((Date)second);&#125;</span><br></pre></td></tr></table></figure>

<p>有关Java泛型转换的要点：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法（类型擦除）</li>
<li>所有的类型参数都用他们的限定类型替换</li>
<li>桥方法被合成来保持多态</li>
<li>为保持类型安全性，必要时插入强制类型转换</li>
</ul>
<h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>使用 Java 泛型时需要考虑的一些限制。大多数限制都是由类型擦除引起的</p>
<h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>不能用类型参数代替基本类型。因此， 没有 Pair<double>, 只 有 Pair<Double>。 当然,其原因是类型擦除。擦除之后， Pair 类含有 Object 类型的域， 而 Object 不能存储 double 值。</p>
<h4 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h4><p>所有的类型查询只产生原始类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;); <span class="comment">//Error</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;);<span class="comment">//Error</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;)a;<span class="comment">//Warning -- can only test that a is a Pair</span></span><br></pre></td></tr></table></figure>

<p>试图查询一个对象是否属于某个泛型类型时，倘若使用 instanceof 会得到一个编译器错误， 如果使用强制类型转换会得到一个警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = . .</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ..;</span><br><span class="line"><span class="comment">//两次调用 getClass 都将返回 Pair.class。</span></span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == employeePair.getClas()) <span class="comment">// they are equal</span></span><br></pre></td></tr></table></figure>

<h4 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];<span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p>擦除之后， table 的类型是 Pair[]， 可以把它转换为 Object[]:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] objarray = table;</span><br><span class="line"><span class="comment">//数组会记住它的元素类型， 如果试图存储其他类型的元素， 就会抛出一个 ArrayStoreException 异常:</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="comment">//对于泛型类型， 擦除会使这种机制无效。能够通过数组存储检査， 不过仍会导致一个类型错误。</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a>Varargs警告</h4><h4 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h4><p>不能使用像 new T(…)， new T[…] 或 T.class 这样的表达式中的类型变量。例如， 下面的Pair<T> 构造器就是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> T();<span class="comment">//Error</span></span><br><span class="line">    second = <span class="keyword">new</span> T();<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除将 T 改变成 Object, 而且， 本意肯定不希望调用 new Object()。 在 Java SE 8 之后，最好的解决办法是让调用者提供一个构造器表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//makePair 方法接收一个 Supplier&lt;T&gt;，这是一个函数式接口，表示一个无参数而且返回类型为 T 的函数：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.ge())；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态域或方法中引用类型变量。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> T singlelnstance; <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T getSinglelnstanceO <span class="comment">// Error</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) construct <span class="keyword">new</span> instance of T</span><br><span class="line">    <span class="keyword">return</span> singlelnstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下定义就不能正常编译：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;<span class="comment">/*....*/</span>&#125;<span class="comment">//Error can't extend Throwable</span></span><br></pre></td></tr></table></figure>

<p>catch 子句中不能使用类型变量。以下方法将不能编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (T e) <span class="comment">// Error can 't catch type variable</span></span><br><span class="line">    &#123;</span><br><span class="line">    Logger,global.info(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在异常规范中使用类型变量是允许的。以下方法是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e) </span><br><span class="line">    &#123;</span><br><span class="line">        t.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h4><p>通过使用泛型类、 擦除和 @SuppressWamings 注解， 就能消除 Java 类型系统的部分基本<br>限制。</p>
<h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><p>通配符类型中， 允许类型参数变化。 例如， 通配符类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h4><p>通配符限定与类型变量限定十分类似，但是，还有一个附加的能力，即可以指定一个超类型限定 （supertypebound), <code>? super Manager</code></p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>例如：Pair&lt;?&gt;</p>
<h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>Class 类是泛型的。例如， String.class 实际上是一个<code>Class&lt;String&gt;</code> 类的对象（事实上，是唯一的对象。)</p>
<h4 id="使用Class参数进行类型匹配"><a href="#使用Class参数进行类型匹配" class="headerlink" title="使用Class参数进行类型匹配"></a>使用Class<T>参数进行类型匹配</h4><h4 id="虚拟机中的泛型类型信息"><a href="#虚拟机中的泛型类型信息" class="headerlink" title="虚拟机中的泛型类型信息"></a>虚拟机中的泛型类型信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该泛型方法类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果需要构造原始泛型方法，需要使用反射API来确定：</p>
<ul>
<li>这个泛型方法有一个叫做 T 的类型参数</li>
<li>这个类型参数有一个子类型限定， 其自身又是一个泛型类型</li>
<li>这个限定类型有一个通配符参数</li>
<li>这个通配符参数有一个超类型限定</li>
<li>这个泛型方法有一个泛型数组参数。</li>
</ul>
<p>为了表达泛型类型声明，使用java.lang.reflect 包中提供的接口 Type。这个接口包含下列子类型：</p>
<ul>
<li>Class类，描述具体类型</li>
<li>TypeVariable接口，描述类型变量（如T extends Comparable&lt;? super T&gt;）</li>
<li>WildcardType 接口， 描述通配符 （如？super T)</li>
<li>ParameterizedType 接口， 描述泛型类或接口类型（如 Comparable&lt;? super T&gt;)</li>
<li>GenericArrayType 接口，描述泛型数组（如 T[ ])</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Comsumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java SE 8中，甚至不用写循环。可以调用 forEachRemaining 方法并提供一个 lambda表达式（它会处理一个元素）。 将对迭代器的每一个元素调用这个 lambda 表达式，直到再没有元素为止。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element );</span><br></pre></td></tr></table></figure>

<p>应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p>Iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。如果调用 remove 之前没有调用 next 将是不合法的。如果这样做， 将会抛出一个 IllegalStateException 异常。</p>
<p>下面是如何删除字符串集合中第一个元素的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">it.next();<span class="comment">//skip over the first element</span></span><br><span class="line">it.remove();<span class="comment">//now remove it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连续删除两个元素</span></span><br><span class="line">it.remove();</span><br><span class="line">it.remove();<span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型使用方法"><a href="#泛型使用方法" class="headerlink" title="泛型使用方法"></a>泛型使用方法</h4><p><code>java.util.Collection&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个用于访问集合中每个元素的迭代器</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回当前存储在集合中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果集合中没有元素， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果集合中包含了一个与 obj 相等的对象， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">//如果这个集合包含 other 集合中的所有元素， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line"><span class="comment">//将 other 集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extend E&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除等于 obj 的对象。如果有匹配的对象被删除， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合删除 filter 返回 true 的所有元素。如果由于这个调用改变了集合， 则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除所有的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; other)</span></span>;</span><br><span class="line"><span class="comment">//返回这个集合的对象数组</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//返回这个集合的对象数组。如果 arrayToFill 足够大， 就将集合中的元素填入这个数组中。剩余空间填补 null ; 否则， 分配一个新数组， 其成员类型与 arrayToFill 的成员类型相同， 其长度等于集合的大小， 并填充集合元素</span></span><br><span class="line">&lt;T&gt; T[] toArray(T[] arrayToFill);</span><br></pre></td></tr></table></figure>

<p><code>java.util.Iterator&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果存在可访问的元素， 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回将要访问的下一个对象。如果已经到达了集合的尾部， 将拋出一个 NoSuchElementException</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化， 这个方法将抛出一个 IllegalStateException</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h4><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_interface.png" alt="集合框架接口"></p>
<p>集合有两个基本接口：Collection 和 Map。</p>
<p>Listlterator 接口是 Iterator 的一个子接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//返回前一个对象。如果已经到达了列表的头部， 就抛出一个NoSuchElementException 异常</span></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//当反向迭代列表时， 还有可供访问的元素， 返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回下一次调用 next 方法时返回元素的整数索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回下一次调用 previous 方法时返回元素的整数索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。如果在 next 或 previous 上次调用之后列表结构被修改了， 将拋出一个 IllegalStateException 异常</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line">	<span class="comment">//在迭代器当前位置前面增加一个元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_collection_implements.png" alt="集合实现类"></p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>在 Java 程序设计语言中，所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用。</p>
<p>如果链表有 n 个元素，有 n+1 个位置可以添加新元素。这些位置与迭代器的 n+1 个可能的位置相对应。例如， 如果链表包含 3 个元素，A、 B、 C，就有 4 个位置（标有丨）可以插入新元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|ABC</span><br><span class="line">A|BC</span><br><span class="line">AB|C</span><br><span class="line">ABC|</span><br></pre></td></tr></table></figure>

<p>检测并发修改的方法：每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致， 抛出一个 ConcurrentModificationException 异常。</p>
<p>注意：对于并发修改列表的检测肴一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、 删除元素。set 方法不被视为结构性修改。</p>
<h4 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h4><p>实现了<code>RandomAccess</code>接口可以对集合进行随机访问。</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列(Hashing)就是将对象转化成整数值的过程，这个整数值也叫作散列码（hashcode）。默认情况下，该整数值主要来自于堆中对象的内存地址（并不是强制的，可以自己重写该方法），从而为所有不同的对象生成不同的散列码（我理解是在内存地址之上加一层算法，并不能完全保证不同的对象产生不同的散列码，也就是可能会产生相同的散列码，也就是散列冲突）。</p>
<p>散列函数必须遵循的规则：两个相等（通过equals比较相等）的对象必须产生相同的散列码</p>
<p>Java中的所有对象都继承Object类中定义的hashCode()函数的默认实现。</p>
<p><code>java.lang.Object</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回这个对象的散列码。散列码可以是任何整数， 包括正数或负数。equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCode() 必须等于 y.hashCod()。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树集(TreeSet)是一个有序集合( sorted collection) 。 可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;String&gt; sorter = <span class="keyword">new</span> TreeSet&lt;&gt;();<span class="comment">//TreeSet implements SortedSet</span></span><br><span class="line">sorter.add(<span class="string">"Bob"</span>);</span><br><span class="line">sorter.add(<span class="string">"Amy"</span>);</span><br><span class="line">sorter.add(<span class="string">"Carl"</span>);</span><br><span class="line"><span class="keyword">for</span>(String s: sorter) System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：要使用树集， 必须能够比较元素。这些元素必须实现 Comparable 接口。或者构造集时必须提供一个 Comparator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeSetTest 代码</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.TreeSet&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet();</span><br><span class="line">TreeSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个树集， 并增加一个集合或有序集中的所有元素（对于后一种情况， 要使用同样的顺序。)</span></span><br><span class="line">TreeSet(Collection&lt;? extends E&gt; elements);</span><br><span class="line">TreeSet(SortedSet&lt;E&gt; s);</span><br></pre></td></tr></table></figure>

<p><code>java.util.SortedSet&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回用于对元素进行排序的比较器。</span></span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> E&gt; comparator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回有序集中的最小元素或最大元素。</span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.NavigableSet&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E value)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回大于等于 vaiue 的最小元素或小于等于 value 的最大元素， 如果没有这样的元素则返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E value)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除并返回这个集中的最大元素或最小元素， 这个集为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个按照递减顺序遍历集中元素的迭代器</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>队列：在尾部添加元素，在头部删除元素（FIFO）</p>
<p>双端队列：头部尾部都支持添加和删除元素</p>
<p>在 Java SE 6中引人了 Deque 接口，并由 ArrayDeque 和LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</p>
<p><code>java.util.Queue&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果队列没有满，将给定的元素添加到这个队列的尾部并返回 true。如果队列满了，第一个方法将拋出一个IllegalStateException, 而第二个方法返回 false。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出NoSuchElementException, 而第二个方法返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列不空，返回这个队列头部的元素， 但不删除。如果队列空，第一个方法将拋出一个 NoSuchElementException, 而第二个方法返回 null</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.Deque&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将给定的对象添加到双端队列的头部或尾部。如果队列满了，前面两个方法将拋出一个 IllegalStateException，而后面两个方法返回 false。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列不空，删除并返回队列头部或尾部的元素。如果队列为空，前面两个方法将拋出一个 NoSuchElementException, 而后面两个方法返回 null</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列非空，返回队列头部或尾部的元素， 但不删除。如果队列空，前面两个方法将拋出一个 NoSuchElementException, 而后面两个方法返回 null。</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.ArrayDeque&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用初始容量 16 或给定的初始容量构造一个无限双端队列</span></span><br><span class="line">ArrayDeque();</span><br><span class="line">ArrayDeque(<span class="keyword">int</span> initialCapacity);</span><br></pre></td></tr></table></figure>

<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆（heap)。堆是一个可以自我调整的二叉树，对树执行添加（ add) 和删除（remove) 操作， 可以让最小的元素移动到根，而不必花费时间对元素进行排序。同TreeSet一样，优先级队列中的元素也是要实现Comparable接口，或者在构造器中提供Comparator对象</p>
<p>使用优先级队列的典型示例是任务调度，每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除（由于习惯上将 1 设为“ 最高” 优先级，所以会将最小的元素删除)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;LocalDate&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1906</span>,<span class="number">12</span>,<span class="number">9</span>));</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1815</span>,<span class="number">12</span>,<span class="number">10</span>));</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1903</span>,<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line">        pq.add(LocalDate.of(<span class="number">1910</span>,<span class="number">6</span>,<span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Iterating over elements..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (LocalDate date:pq)&#123;</span><br><span class="line">            System.out.println(date);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Removing elements..."</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            System.out.println(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.util.PriorityQueue&lt;E&gt;  5.0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个用于存放 Comparable 对象的优先级队列</span></span><br><span class="line">PriorityQueue();</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity);</span><br><span class="line"><span class="comment">//构造一个优先级队列， 并用指定的比较器对元素进行排序</span></span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity,Comparator&lt;? <span class="keyword">super</span> E&gt; c);</span><br></pre></td></tr></table></figure>

<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h4><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><h4 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h4><p>设计 WeakHashMap 类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再使用了， 将会出现什么情况呢？ 假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键 / 值对无法从映射中删除。</p>
<p>WeakHashMap 使用弱引用 （ weak references) 保存键。</p>
<h4 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h4><p>LinkedHashSet 和 LinkedHashMap类用来记住插入元素项的顺序。这样就可以避免在散歹表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。</p>
<p>访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。LinkedHashMap 对最近最少使用原则的简单实现方案就是重写<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现缓存100个元素</span></span><br><span class="line">Map&lt;K,V&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">128</span>,<span class="number">0.75F</span>,<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h4><p>EmimSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1</p>
<p>EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY,SUNDAY&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.FRIDAY,Weekday.SUNDAY);</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>在 EnumSet 的 API 文档中， 将会看到 E extends Enum<E> 这样奇怪的类型参数。简单地说， 它的意思是 “ E 是一个枚举类型。” 所有的枚举类型都扩展于泛型 Enum 类。例如，Weekday 4广展 Enum&lt;Weekday〉。</p>
<p>EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Weekday, Employee&gt;  personlnCharge = <span class="keyword">new</span> EnumMap&lt;&gt;(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h4><p>类 IdentityHashMap 有特殊的作用。在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。在实现对象遍历算<br>法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</p>
<h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用视图( views) 可以获得其他的实现了 Collection 接口和 Map 接口的对象。映射类的 keySet 方法就是一个这样的示例。keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><p>Arrays 类的静态方法 asList 将返回一个包装了普通 Java 数组的 List 包装器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line"><span class="comment">//返回的对象不是 ArrayList。它是一个视图对象， 带有访问底层数组的 get 和 set 方法。</span></span><br><span class="line"><span class="comment">//改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法）都会抛出一个Unsupported OperationException 异常。</span></span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br><span class="line"></span><br><span class="line"><span class="comment">//asList还可以接收可变参数</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span>,<span class="string">"Bob"</span>,<span class="string">"Carl"</span>);</span><br></pre></td></tr></table></figure>

<p>下 面 的 调 用 将 创 建 一 个 包 含 1 0 0 个 字 符 串 的 List, 每 个 串 都 被 设 置 为“ DEFAULT”:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储代价很小</span></span><br><span class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>,<span class="string">"default"</span>);</span><br></pre></td></tr></table></figure>

<p>Collections类包含很多实用方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个视图对象，该对象实现了一个不可修改的单元素集合，并且不需要新建数据结构，节省开销。singletonList和singletonMap方法类似</span></span><br><span class="line">Collections.singleton(anObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于集合框架中的每一个接口，还有一些方法可以生成空集、 列表、 映射，等等。</span></span><br><span class="line">Set&lt;String&gt; deepThoughts = Collections.emptySet();</span><br></pre></td></tr></table></figure>

<h4 id="子范围视图"><a href="#子范围视图" class="headerlink" title="子范围视图"></a>子范围视图</h4><p>比如subList方法就可以获得列表的一个子范围视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List group2 = staff.subList(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//前闭后开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况。</span></span><br><span class="line">group2.clear();<span class="comment">//group2为空，staff中也会清除</span></span><br></pre></td></tr></table></figure>

<p>对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些方法将返回大于等于 from 且小于 to 的所有元素子集。</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,E to)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回映射视图， 该映射包含键落在指定范围内的所有元素</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K from,K to)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Java SE 6 引人的 NavigableSet 接口赋予子范围操作更多的控制能力。可以指定是否包括边界：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive,E to, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p>可以使用下面 8 种方法获得不可修改视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.unmodifiableCollection;</span><br><span class="line">Collections.unmodifiableList;</span><br><span class="line">Collections.unmodifiableSet;</span><br><span class="line">Collections.unmodifiableSortedSet;</span><br><span class="line">Collections.unmodifiableNavigableSet;</span><br><span class="line">Collections.unmodifiableMap;</span><br><span class="line">Collections.unmodifiableSortedMap;</span><br><span class="line">Collections.unmodifiableNavigableMap;</span><br></pre></td></tr></table></figure>

<p>由于视图只是包装了接口而不是实际的集合对象， 所以只能访问接口中定义的方法。例如， LinkedList 类有一些非常方便的方法，addFirst 和 addLast，它们都不是 List 接口的方法，不能通过不可修改视图进行访问。</p>
<h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。</p>
<p><code>Collections.synchronized*</code>方法，比如<code>Collections.synchronizedMap</code></p>
<h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p>“ 受査” 视图用来对泛型类型发生问题时提供调试支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; safeStrings = Collections.checkedList(strings,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>视图的 add 方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//fill collection</span></span><br><span class="line">Collections.sort(staff);<span class="comment">//元素需要实现Comparable接口</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));<span class="comment">//自定义比较器</span></span><br><span class="line">staff.sort(Comparator.reverseOrder());<span class="comment">//降序</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee.getSalary).reversed());<span class="comment">//按照工资降序排列</span></span><br></pre></td></tr></table></figure>

<p>Collections 类有一个算法 shuffle, 其功能与排序刚好相反， 即随机地混排列表中元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);<span class="comment">//混排</span></span><br></pre></td></tr></table></figure>

<p>如果提供的列表没有实现 RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<p><code>java.util.Collections</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用稳定的排序算法， 对列表中的元素进行排序。这个算法的时间复杂度是 O(n logn), 其中 n 为列表的长度。</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;  <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; elements)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机地打乱列表中的元素。这个算法的时间复杂度是 0(na(n)), n 是列表的长度，a (n)是访问元素的平均时间。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; elements)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; elements,Random r)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>java.util.List&lt;E&gt;</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用给定比较器对列表排序</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>; <span class="comment">//Java 8</span></span><br></pre></td></tr></table></figure>

<p><code>java.util.Comparator&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个比较器， 将逆置 Comparable 接口提供的顺序</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//生成一个比较器， 将逆置这个比较器提供的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>Collections 类的 binarySearch方法实现了这个二分查找算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 binarySearch 方法返回的数值大于等于 0, 则表示匹配对象的索引。如果返回负值， 则表示没有匹配的兀素。但是，可以利用返回值计算应该将 element 插入到集合的哪个位置， 以保持集合的有序性。插人的位置是insertPoint = - i - 1;</span></span><br><span class="line">i = Collections.binarySearch(c,element);</span><br><span class="line">i = Collections.binarySearch(c,element,comparator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    c.add(-i-<span class="number">1</span>,element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有采用随机访问，二分査找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分査找就完全失去了优势。因此，如果为 binarySearch 算法提供一个链表， 它将自动地变为线性查找。</p>
<h4 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h4><h4 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h4><p>数组转集合Arrays.asList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] values = ...;</span><br><span class="line">HashSet&lt;String&gt; staff = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(values));</span><br></pre></td></tr></table></figure>

<p>集合转数组：不能直接使用toArray方法，因为该方法返回Object[]数组，强制类型转换会报错，所以需要使用toArray方法的一个变体形式，提供一个所需类型而且长度为0的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] values = (String[]) staff.toArray();<span class="comment">//Error</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//OK</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">staff.toArray(<span class="keyword">new</span> String[staff.size()]);</span><br></pre></td></tr></table></figure>

<h4 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h4><p>HashTable、Enumeration、Properties、Stack、BitSet</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/" rel="prev" title="算法第四版">
      <i class="fa fa-chevron-left"></i> 算法第四版
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/30/book-java-Concurrency-Concurrency-Programming/" rel="next" title="Java并发编程">
      Java并发编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#异常、断言和日志"><span class="nav-number">1.</span> <span class="nav-text">异常、断言和日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常错误"><span class="nav-number">1.1.</span> <span class="nav-text">异常错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常分类"><span class="nav-number">1.1.1.</span> <span class="nav-text">异常分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM异常处理过程"><span class="nav-number">1.1.2.</span> <span class="nav-text">JVM异常处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#默认异常处理"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">默认异常处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义异常处理"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">自定义异常处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#声明受查异常"><span class="nav-number">1.1.3.</span> <span class="nav-text">声明受查异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何抛出异常"><span class="nav-number">1.1.4.</span> <span class="nav-text">如何抛出异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建异常类"><span class="nav-number">1.1.5.</span> <span class="nav-text">创建异常类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#捕获异常"><span class="nav-number">1.2.</span> <span class="nav-text">捕获异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获异常-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#再次抛出异常与异常链"><span class="nav-number">1.2.2.</span> <span class="nav-text">再次抛出异常与异常链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally子句"><span class="nav-number">1.2.3.</span> <span class="nav-text">finally子句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带资源的try语句"><span class="nav-number">1.2.4.</span> <span class="nav-text">带资源的try语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析堆栈轨迹元素"><span class="nav-number">1.2.5.</span> <span class="nav-text">分析堆栈轨迹元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用异常机制的技巧"><span class="nav-number">1.2.6.</span> <span class="nav-text">使用异常机制的技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断言"><span class="nav-number">1.3.</span> <span class="nav-text">断言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启用和禁用断言"><span class="nav-number">1.3.1.</span> <span class="nav-text">启用和禁用断言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录日志"><span class="nav-number">1.4.</span> <span class="nav-text">记录日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用泛型"><span class="nav-number">2.1.</span> <span class="nav-text">为什么要使用泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义简单泛型类"><span class="nav-number">2.2.</span> <span class="nav-text">定义简单泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型方法"><span class="nav-number">2.3.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型变量的限定"><span class="nav-number">2.4.</span> <span class="nav-text">类型变量的限定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型代码和虚拟机"><span class="nav-number">2.5.</span> <span class="nav-text">泛型代码和虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型擦除"><span class="nav-number">2.5.1.</span> <span class="nav-text">类型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#翻译泛型表达式"><span class="nav-number">2.5.2.</span> <span class="nav-text">翻译泛型表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#翻译泛型方法"><span class="nav-number">2.5.3.</span> <span class="nav-text">翻译泛型方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束与局限性"><span class="nav-number">2.6.</span> <span class="nav-text">约束与局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不能用基本类型实例化类型参数"><span class="nav-number">2.6.1.</span> <span class="nav-text">不能用基本类型实例化类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时类型查询只适用于原始类型"><span class="nav-number">2.6.2.</span> <span class="nav-text">运行时类型查询只适用于原始类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能创建参数化类型的数组"><span class="nav-number">2.6.3.</span> <span class="nav-text">不能创建参数化类型的数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Varargs警告"><span class="nav-number">2.6.4.</span> <span class="nav-text">Varargs警告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能实例化类型变量"><span class="nav-number">2.6.5.</span> <span class="nav-text">不能实例化类型变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能构造泛型数组"><span class="nav-number">2.6.6.</span> <span class="nav-text">不能构造泛型数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型类的静态上下文中类型变量无效"><span class="nav-number">2.6.7.</span> <span class="nav-text">泛型类的静态上下文中类型变量无效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能抛出或捕获泛型类的实例"><span class="nav-number">2.6.8.</span> <span class="nav-text">不能抛出或捕获泛型类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可以消除对受查异常的检查"><span class="nav-number">2.6.9.</span> <span class="nav-text">可以消除对受查异常的检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意擦除后的冲突"><span class="nav-number">2.6.10.</span> <span class="nav-text">注意擦除后的冲突</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型类型的继承规则"><span class="nav-number">2.7.</span> <span class="nav-text">泛型类型的继承规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通配符类型"><span class="nav-number">2.8.</span> <span class="nav-text">通配符类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符概念"><span class="nav-number">2.8.1.</span> <span class="nav-text">通配符概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符的超类型限定"><span class="nav-number">2.8.2.</span> <span class="nav-text">通配符的超类型限定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无限定通配符"><span class="nav-number">2.8.3.</span> <span class="nav-text">无限定通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符捕获"><span class="nav-number">2.8.4.</span> <span class="nav-text">通配符捕获</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射和泛型"><span class="nav-number">2.9.</span> <span class="nav-text">反射和泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型类"><span class="nav-number">2.9.1.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Class参数进行类型匹配"><span class="nav-number">2.9.2.</span> <span class="nav-text">使用Class参数进行类型匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机中的泛型类型信息"><span class="nav-number">2.9.3.</span> <span class="nav-text">虚拟机中的泛型类型信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">3.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java集合框架"><span class="nav-number">3.1.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器"><span class="nav-number">3.1.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型使用方法"><span class="nav-number">3.1.2.</span> <span class="nav-text">泛型使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合框架中的接口"><span class="nav-number">3.1.3.</span> <span class="nav-text">集合框架中的接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体的集合"><span class="nav-number">3.2.</span> <span class="nav-text">具体的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">3.2.1.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组列表"><span class="nav-number">3.2.2.</span> <span class="nav-text">数组列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#散列表"><span class="nav-number">3.2.3.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树"><span class="nav-number">3.2.4.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列与双端队列"><span class="nav-number">3.2.5.</span> <span class="nav-text">队列与双端队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级队列"><span class="nav-number">3.2.6.</span> <span class="nav-text">优先级队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射"><span class="nav-number">3.3.</span> <span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本映射操作"><span class="nav-number">3.3.1.</span> <span class="nav-text">基本映射操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#映射视图"><span class="nav-number">3.3.2.</span> <span class="nav-text">映射视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱散列映射"><span class="nav-number">3.3.3.</span> <span class="nav-text">弱散列映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接散列集与映射"><span class="nav-number">3.3.4.</span> <span class="nav-text">链接散列集与映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举集与映射"><span class="nav-number">3.3.5.</span> <span class="nav-text">枚举集与映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标识散列映射"><span class="nav-number">3.3.6.</span> <span class="nav-text">标识散列映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图与包装器"><span class="nav-number">3.4.</span> <span class="nav-text">视图与包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级集合包装器"><span class="nav-number">3.4.1.</span> <span class="nav-text">轻量级集合包装器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子范围视图"><span class="nav-number">3.4.2.</span> <span class="nav-text">子范围视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可修改的视图"><span class="nav-number">3.4.3.</span> <span class="nav-text">不可修改的视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步视图"><span class="nav-number">3.4.4.</span> <span class="nav-text">同步视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#受查视图"><span class="nav-number">3.4.5.</span> <span class="nav-text">受查视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法"><span class="nav-number">3.5.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序与混排"><span class="nav-number">3.5.1.</span> <span class="nav-text">排序与混排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找"><span class="nav-number">3.5.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单算法"><span class="nav-number">3.5.3.</span> <span class="nav-text">简单算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合与数组的转换"><span class="nav-number">3.5.4.</span> <span class="nav-text">集合与数组的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遗留的集合"><span class="nav-number">3.5.5.</span> <span class="nav-text">遗留的集合</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZGQ"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZGQ</p>
  <div class="site-description" itemprop="description">Java</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengguoqiang927" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengguoqiang927" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengguoqiang927@gmail.com" title="E-Mail → mailto:zhengguoqiang927@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">左耳朵耗子</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;" rel="noopener" target="_blank">廖雪峰</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZGQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://johnson-5.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/04/21/book-java-Core-Java-Fundamentals-Two/";
    this.page.identifier = "2020/04/21/book-java-Core-Java-Fundamentals-Two/";
    this.page.title = "Java核心技术 - 基础知识卷2";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://johnson-5.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
