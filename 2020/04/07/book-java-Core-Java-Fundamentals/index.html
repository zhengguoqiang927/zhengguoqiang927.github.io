<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Georgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.Java程序设计概述Java的特点 简单性 面向对象   与面向过程的区别： 面向过程：性能高。面向过程语言大多都是编译成机器能直接运行的机器码，而java需要多一步解释执行的过程。首先编译器将Java源代码编译成字节码，字节码再由JVM虚拟机解释成机器码运行。但现在Java性能已经提升了很多并不比一些面向过程的脚本语言差，因为虚拟机支持即时编译。 即时编译：https:&#x2F;&#x2F;www.ibm.c">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术 - 基础知识卷">
<meta property="og:url" content="http://yoursite.com/2020/04/07/book-java-Core-Java-Fundamentals/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="1.Java程序设计概述Java的特点 简单性 面向对象   与面向过程的区别： 面向过程：性能高。面向过程语言大多都是编译成机器能直接运行的机器码，而java需要多一步解释执行的过程。首先编译器将Java源代码编译成字节码，字节码再由JVM虚拟机解释成机器码运行。但现在Java性能已经提升了很多并不比一些面向过程的脚本语言差，因为虚拟机支持即时编译。 即时编译：https:&#x2F;&#x2F;www.ibm.c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/corejava_compile_run.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_primitive_type.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_number_convert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_print_symbol.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_printf_sign.png">
<meta property="og:image" content="https://www.geeksforgeeks.org/wp-content/uploads/d.jpeg">
<meta property="article:published_time" content="2020-04-07T04:01:08.000Z">
<meta property="article:modified_time" content="2020-05-07T11:12:16.920Z">
<meta property="article:author" content="ZGQ">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/corejava_compile_run.png">

<link rel="canonical" href="http://yoursite.com/2020/04/07/book-java-Core-Java-Fundamentals/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java核心技术 - 基础知识卷 | Z's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/book-java-Core-Java-Fundamentals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ZGQ">
      <meta itemprop="description" content="Java">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java核心技术 - 基础知识卷
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 12:01:08" itemprop="dateCreated datePublished" datetime="2020-04-07T12:01:08+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-07 19:12:16" itemprop="dateModified" datetime="2020-05-07T19:12:16+08:00">2020-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/04/07/book-java-Core-Java-Fundamentals/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/07/book-java-Core-Java-Fundamentals/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-Java程序设计概述"><a href="#1-Java程序设计概述" class="headerlink" title="1.Java程序设计概述"></a>1.Java程序设计概述</h2><h3 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h3><ul>
<li>简单性</li>
<li>面向对象</li>
</ul>
<blockquote>
<p>与面向过程的区别：</p>
<p>面向过程：性能高。面向过程语言大多都是编译成机器能直接运行的机器码，而java需要多一步解释执行的过程。首先编译器将Java源代码编译成字节码，字节码再由JVM虚拟机解释成机器码运行。但现在Java性能已经提升了很多并不比一些面向过程的脚本语言差，因为虚拟机支持<strong>即时编译</strong>。</p>
<p>即时编译：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html）" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html）</a></p>
<p>面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</blockquote>
<ul>
<li>可移植（JVM实现平台无关）</li>
<li>安全性</li>
<li>健壮性</li>
<li>多线程</li>
<li>高性能（通过即时编译器实现）</li>
</ul>
<a id="more"></a>

<h2 id="2-Java程序设计环境"><a href="#2-Java程序设计环境" class="headerlink" title="2.Java程序设计环境"></a>2.Java程序设计环境</h2><h3 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM/JDK/JRE"></a>JVM/JDK/JRE</h3><p><strong>JVM</strong>：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>字节码以及采用字节码的好处</strong>：</p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>java程序从源代码到运行一般分三步</strong>：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/corejava_compile_run.png" alt="java_compile_run"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结</strong>：</p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处运行”的关键所在。</p>
<p>JDK：Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p><strong>JRE</strong>：Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<blockquote>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
</blockquote>
<h2 id="3-Java的基本程序设计结构"><a href="#3-Java的基本程序设计结构" class="headerlink" title="3.Java的基本程序设计结构"></a>3.Java的基本程序设计结构</h2><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_primitive_type.png" alt="java_primitive_type"></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 是一种强类型语言。这就意味着必须为每一个变量声明一种类型: 在 Java 中， 一共有 8<br>种基本类型（ primitive type ), 其中有 4 种整型、2 种浮点类型、 1 种用于表示 Unicode 编码的字符<br>单元的字符类型 char 和 1 种用于表示真值的 boolean 类型</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>占据字节大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节</td>
<td>-128～127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-32 768～32 767</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2 147 483 648～2 147 483 647 (正好超过 20 亿)</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-9 223 372 036 854 775 808 ～ 9 223 372 036 854 775 807</td>
</tr>
</tbody></table>
<p>长整型数值有一个后缀 L 或 1 ( 如 4000000000L)。 十六进制数值有一个前缀 0x 或 0X (如0xCAFEL)。八进制有一个前缀 0 , 例如， 010 对应八进制中的 8。很显然， 八进制表示法比较容易混淆， 所以建议最好不要使用八进制常数。</p>
<p>从 Java 7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0b1001就是 9。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用 1_000_000(或0b1111_0100_0010_0100_0000)表示一百万。这些下划线只是为了让人更易读。Java 编译器会去除这些下划线。</p>
<p><em>注意：Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。</em></p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>占据字节大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位）</td>
</tr>
</tbody></table>
<p>float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == Double.NaN)<span class="comment">//不能这样检测一个值是否为非数字,因为所有"非数值"的值都被认为是不相同的</span></span><br><span class="line"><span class="comment">//可以用Double.isNaN()方法判断一个值是否为非数值    </span></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(x))</span><br></pre></td></tr></table></figure>

<p><em>注意：如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类</em></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>两个数进行二元操作时，需要先将两个操作数转换为同一种类型，然后在进行计算。</p>
<ul>
<li>如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。</li>
<li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。</li>
<li>否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。</li>
<li>否则， 两个操作数都将被转换为 int 类型。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_number_convert.png" alt="java_number_convert"></p>
<p>6个实心箭头表示无信息丢失的转换</p>
<p>3个虚线箭头表示可能有精度损失的转换</p>
<h4 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h4><p> 如果运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。 例如，如果 X 是一个 int, 则以下语句<br>x += 3.5;<br>是合法的， 将把 X 设置为（int)(x + 3.5)。</p>
<h4 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h4><p>前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span> * ++m;<span class="comment">//now a is 16,m is 8</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span> * n++;<span class="comment">//now b is 14,n is 8</span></span><br></pre></td></tr></table></figure>

<p>即前++使用++之后的值，后++使用++之前的值。</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符包括&amp; (“and”)、 | (“or”)、 ^ (“xor”)、 ~ (“not”)、左移（&lt;&lt;）、右移（&gt;&gt;）、无符号右移（&gt;&gt;&gt;）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fourthBitFromRight = (n &amp; <span class="number">0b1000</span>) / <span class="number">0b1000</span>;<span class="comment">//如果n的二进制位表示，从有往左数的第四位为1则该表达式结果为1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。<strong>不可变字符串优点：编译器可以让字符串共享</strong></p>
<blockquote>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
</blockquote>
<h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p>可以使用 equals 方法检测两个字符串是否相等。一定不要使用==运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。因此，千万不要使甩== 运算符测试字符串的相等性</p>
<h4 id="空串与Null串"><a href="#空串与Null串" class="headerlink" title="空串与Null串"></a>空串与Null串</h4><p>空串 “” 是长度为 0 的字符串。空串是一个 Java 对象， 有自己的串长度（ 0 ) 和内容（空）。不过， String 变量还可以存放一个特殊的值， 名为 null, 这表示目前没有任何对象与该变量关联。</p>
<h4 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h4><p><strong>StringBuider 和 StringBuffer 的区别</strong></p>
<p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p>String：String 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p>AbstractStringBuilder类 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
<p>StringBuffer：对父类部分方法进行重写加了同步锁（synchronized），所以是线程安全的。</p>
<p>StringBuilder：并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。单线程情况下建议使用StringBuilder。</p>
<p><strong>总结</strong>：</p>
<ol>
<li>操作少量数据：适用String</li>
<li>单线程操作字符串缓冲区下大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下大量数据: 适用 StringBuffer</li>
</ol>
<h4 id="字符常量和字符串常量的区别"><a href="#字符常量和字符串常量的区别" class="headerlink" title="字符常量和字符串常量的区别"></a>字符常量和字符串常量的区别</h4><ol>
<li>形式上：字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li>
<li>含义上：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制台读取输入</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"What is your name?"</span>);</span><br><span class="line">String name = in.nextLine();</span><br><span class="line">String fistName = in.next();</span><br><span class="line"><span class="keyword">int</span> age = in.nextInt();</span><br><span class="line"><span class="keyword">double</span> = in.nextDouble();</span><br><span class="line"><span class="comment">//控制台读取密码</span></span><br><span class="line">Console cons = System.console();</span><br><span class="line">String username = cons.readLine(<span class="string">"User name:"</span>);</span><br><span class="line"><span class="keyword">char</span>[] passwd = cons.readPassword(<span class="string">"Passwrod:"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>Java SE 5.0 沿用了 C语言库函数中的 printf方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用 8 个字符的宽度和小数点后两个字符的精度打印 x</span></span><br><span class="line">System.out.printf(<span class="string">"%8.2f"</span>,x);<span class="comment">//结果  3333.33</span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"Hello, %s. Next year, you'll be %d"</span>,name,age);</span><br></pre></td></tr></table></figure>

<p>每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_print_symbol.png" alt="java_printf_symbol"></p>
<p>另外，还可以给出控制格式化输出的各种标志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逗号标志增加了分组的分隔符</span></span><br><span class="line">System.out.printf(<span class="string">"%,.2f"</span>,<span class="number">1000.0</span>/<span class="number">3.0</span>)<span class="comment">//结果：3,333,33</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/java_printf_sign.png" alt="java_printf_sign"></p>
<p>可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>,name,age);</span><br></pre></td></tr></table></figure>

<p>API(Java 7提供)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path path = java.nio.file.Paths.get(String pathname);</span><br></pre></td></tr></table></figure>

<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h4 id="多重选择：switch语句"><a href="#多重选择：switch语句" class="headerlink" title="多重选择：switch语句"></a>多重选择：switch语句</h4><p>case标签可以是：</p>
<ul>
<li>类型为char、byte、short或int的常量表达式</li>
<li>枚举常量</li>
<li>Java SE7开始，支持字符串字面量</li>
</ul>
<h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>BigInteger和BigDecimal</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h4><p>foreach 循环语句的循环变量将会遍历数组中的每个元素， 而不需要使用下标值。</p>
<p>在很多场合下， 还是需要使用传统的 for 循环t 例如，如果不希望遍历集合中的每个元素， 或者在循环内部需要使用下标值等。</p>
<blockquote>
<p>有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调用 Arrays.toString(a), 返回一个包含数组元素的字符串，这些元素被放置在括号内， 并用逗号分隔， 例如 “ [2,3,5,7，11，13]”</p>
</blockquote>
<h4 id="数组初始化及匿名数组"><a href="#数组初始化及匿名数组" class="headerlink" title="数组初始化及匿名数组"></a>数组初始化及匿名数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> smallPrimes = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化一个匿名数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="comment">//这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。</span></span><br><span class="line">smallPrimes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p>一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, <span class="number">2</span>* luckyNumbers.length);</span><br></pre></td></tr></table></figure>

<p>第 2 个参数是新数组的长度，这个方法通常用来增加数组的大小。如果数组元素是数值型，那么多余的元素将赋值为 0 ; 如果数组元素是布尔型，则将赋值为 false。相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Message -g cruel world</span><br></pre></td></tr></table></figure>

<p>Message类的main方法接收String类型的数组，args[0] = “-g”，args[1]=”cruel”，args[2]=”world”</p>
<h4 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] odds =  <span class="keyword">new</span>  <span class="keyword">int</span>[NMAX + <span class="number">1</span>][];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n &lt;= NMAX;n++)&#123;</span><br><span class="line">    odds[n] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;odds.length;n++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;odds[n].length;k++)&#123;</span><br><span class="line">        odds[n][k] = lotteryOdds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-对象与类"><a href="#4-对象与类" class="headerlink" title="4.对象与类"></a>4.对象与类</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final是java中的关键字，用于限制某些功能(restricting some functionalities)。我们可以使用final关键字声明变量，方法和类</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>声明变量为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。对于基本类型，final 使数值不变；对于引用对象，final 使引用不变，也就是不能引用其它对象，但是被引用的对象本身是可以修改的，比如可以从final数组或者final集合里添加元素或者删除元素。</p>
<p>final修饰的变量的初始化方式有三种：</p>
<ol>
<li>声明的时候直接初始化，这种方式最常见</li>
<li>声明的时候没有初始化，我们把这种final变量叫做空final变量(blank final variable)，空final变量可以在实例初始化块或者构造函数内部初始化，如果有多个构造函数那么每个构造函数都要进行初始话，否则编译不通过</li>
<li>空的静态final变量在静态代码块中初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Java program to demonstrate different </span></span><br><span class="line"><span class="comment">// ways of initializing a final variable </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gfg</span>  </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// a final variable </span></span><br><span class="line">    <span class="comment">// direct initialize </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">5</span>; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// a blank final variable </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// another blank final variable </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>  MINIMUM; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// a final static variable PI </span></span><br><span class="line">    <span class="comment">// direct initialize </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// a  blank final static  variable </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EULERCONSTANT; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// instance initializer block for  </span></span><br><span class="line">    <span class="comment">// initializing CAPACITY </span></span><br><span class="line">    &#123; </span><br><span class="line">        CAPACITY = <span class="number">25</span>; </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// static initializer block for  </span></span><br><span class="line">    <span class="comment">// initializing EULERCONSTANT </span></span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        EULERCONSTANT = <span class="number">2.3</span>; </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// constructor for initializing MINIMUM </span></span><br><span class="line">    <span class="comment">// Note that if there are more than one </span></span><br><span class="line">    <span class="comment">// constructor, you must initialize MINIMUM </span></span><br><span class="line">    <span class="comment">// in them also </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GFG</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        MINIMUM = -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，for-each循环里也可以使用final修饰局部变量，因为每次循环迭代，这个局部变量都是被重新声明的，所以可以用final修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// final with for-each statement </span></span><br><span class="line">        <span class="comment">// legal statement </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> i : arr) </span><br><span class="line">            System.out.print(i + <span class="string">" "</span>); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p> final声明的方法不能被重写(overridden)。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类被声明final时有两个用处：1. 禁止继承(prevent  inheritance)，比如包装类Integer，Float等等；2.创建不可变类（immutable class），比如String</p>
<p>另外，如果一个类被声明成final，则默认情况下该类中的所有方法也是final的，但是变量不是final的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to illustrate final keyword </span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// by default it is final. </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// by default it is not final. </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">30</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">// See modified contents of variable j. </span></span><br><span class="line">		j = <span class="number">36</span>; </span><br><span class="line">		System.out.println(j); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>36</p>
</blockquote>
<h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><p>final 上面已经介绍过</p>
<p>finally 通常与try/catch块一起使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java program to demonstrate finally. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Geek</span> </span>&#123; </span><br><span class="line">	<span class="comment">// A method that throws an exception and has finally. </span></span><br><span class="line">	<span class="comment">// This method will be called inside try-catch. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			System.out.println(<span class="string">"inside A"</span>); </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"demo"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123; </span><br><span class="line">			System.out.println(<span class="string">"A's finally"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// This method also calls finally. This method </span></span><br><span class="line">	<span class="comment">// will be called outside try-catch. </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			System.out.println(<span class="string">"inside B"</span>); </span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123; </span><br><span class="line">			System.out.println(<span class="string">"B's finally"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123; </span><br><span class="line">			A(); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">			System.out.println(<span class="string">"Exception caught"</span>); </span><br><span class="line">		&#125; </span><br><span class="line">		B(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>inside A</p>
<p>A’s finally</p>
<p>Exception caught</p>
<p>inside B</p>
<p>B’s finally</p>
</blockquote>
<p>finally 块中通常用来进行资源的释放，jdk7中提供了try-with-resources 语法来自动关闭资源而不用再写finally块。</p>
<p>finalize 不是一个保留关键字，而final、finally是Java中保留的关键字。finalize是Object类中定义的方法，而Object类又是所有类的基类，所以所有类都可以重写finalize方法。该方法是由垃圾收集器销毁可回收对象之前调用，以进行清理活动。主要清理跟该对象有关联的资源比如数据库连接、网络连接，目的就是取消该对象上的资源分配，该方法执行完之后垃圾收集器立即销毁该对象。</p>
<p>finalize方法相关的几个例子：</p>
<ol>
<li>可回收的对象在被垃圾收集器回收之前，执行该对象的finalize方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		Hello s = <span class="keyword">new</span> Hello(<span class="string">"RR"</span>); </span><br><span class="line">		s = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Main Completes</p>
<p>finalize method overriden</p>
</blockquote>
<ol start="2">
<li>显式调用finalize方法，这时就跟普通方法没有区别，调用之后该对象也不会被销毁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bye</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		Bye m = <span class="keyword">new</span> Bye(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Calling finalize method Explicitly. </span></span><br><span class="line">		m.finalize(); </span><br><span class="line">		m.finalize(); </span><br><span class="line">		m = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>finalize method overriden</p>
<p>finalize method overriden</p>
<p>Main Completes</p>
<p>finalize method overriden</p>
</blockquote>
<ol start="3">
<li><p>当finalize方法抛出unchecked exception异常时，分两种情况处理：</p>
<ol>
<li>程序中显式调用finalize方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		Hi j = <span class="keyword">new</span> Hi(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Calling finalize method Explicitly. </span></span><br><span class="line">		j.finalize(); </span><br><span class="line"></span><br><span class="line">		j = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">		System.out.println(<span class="number">10</span> / <span class="number">0</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>exception in thread “main” java.lang.ArithmeticException:<br>/ by zero followed by stack trace.</p>
</blockquote>
<p>显式调用且没有进行异常捕获时，程序异常退出</p>
<ol start="2">
<li>垃圾收集器调用的finalize方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RR</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		RR q = <span class="keyword">new</span> RR(); </span><br><span class="line">		q = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Requesting JVM to call Garbage Collector method </span></span><br><span class="line">		System.gc(); </span><br><span class="line">		System.out.println(<span class="string">"Main Completes"</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here overriding finalize method </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"finalize method overriden"</span>); </span><br><span class="line">		System.out.println(<span class="number">10</span> / <span class="number">0</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>finalize method overriden</p>
<p>Main Completes</p>
</blockquote>
<p>如果是垃圾收集器调用的finalize方法，且抛出unchecked异常时，JVM会忽略该异常并继续执行，因此该程序正常退出</p>
</li>
</ol>
<p><strong>要点总结</strong>：</p>
<ol>
<li>finalize方法的调用时间不固定，只要对象可回收，垃圾收集器在销毁它之前都会调用finalize方法</li>
<li>JVM只忽略<strong><a href="https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java/" target="_blank" rel="noopener">Unchecked exceptions</a></strong>异常，其他异常不会忽略，并且如果有catch block也会执行</li>
<li>System.gc()只是请求JVM去执行垃圾回收，由JVM决定是否进行垃圾回收，通常情况下当堆空间不够或者可用内存较低时JVM才会调用垃圾收集器进行垃圾回收</li>
</ol>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>abstract 是java中的非访问修饰符(non-access modifier)，可以用来修饰类(classes)和方法(methods)，但是不能用来修饰变量(variables). 用于实现抽象</p>
<p><strong>类</strong> ：abstract修饰的类叫抽象类(abstract class)</p>
<p>以下是抽象类的几个重要特点：</p>
<ol>
<li>抽象类不能被实例化，但是可以引用抽象类类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Uncommenting the following line will cause compiler error as the </span></span><br><span class="line">		<span class="comment">// line tries to create an instance of abstract class. </span></span><br><span class="line">		<span class="comment">// Base b = new Base(); </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// We can have references of Base type. </span></span><br><span class="line">		Base b = <span class="keyword">new</span> Derived(); </span><br><span class="line">		b.fun(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Derived fun() called</p>
</blockquote>
<ol start="2">
<li>抽象类中可以含有构造方法，当子类实例化时抽象类的构造方法被调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An abstract class with constructor </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	Base() &#123; System.out.println(<span class="string">"Base Constructor Called"</span>); &#125; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	Derived() &#123; System.out.println(<span class="string">"Derived Constructor Called"</span>); &#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	Derived d = <span class="keyword">new</span> Derived(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Base Constructor Called</p>
<p>Derived Constructor Called</p>
</blockquote>
<ol start="3">
<li>抽象类中可以没有抽象方法，该类不能被实例化只能被继承，所以普通方法可以被继承到子类中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An abstract class without any abstract method </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Base fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">		Derived d = <span class="keyword">new</span> Derived(); </span><br><span class="line">		d.fun(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Base fun() called</p>
</blockquote>
<ol start="4">
<li>抽象类中可以有final方法，final方法不能被重写(overridden)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An abstract class with a final method </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived fun() called"</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	Base b = <span class="keyword">new</span> Derived(); </span><br><span class="line">	b.fun(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>Derived fun() called</p>
</blockquote>
<p><strong>方法</strong> ：当一些方法在父类中只需要声明（declare），子类来提供方法定义（method definition）时，可以将其用abstract修饰，即为抽象方法</p>
<p>表现形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> type method-name(parameter-list);</span><br></pre></td></tr></table></figure>

<p>抽象方法没有方法体，任何继承了抽象类的具体类必须实现所有抽象方法</p>
<p><strong>抽象方法的重要规则</strong> ：</p>
<ul>
<li>任何包含一个或多个抽象方法的类必须声明为抽象类</li>
<li>抽象方法上所有与abstract修饰符冲突的修饰符<ul>
<li>abstract final</li>
<li>abstract native</li>
<li>abstract synchronized</li>
<li>abstract static</li>
<li>abstract private</li>
<li>abstract strictfp</li>
</ul>
</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 是java中的非访问修饰符(non-access modifier)，可以用来修饰块(blocks)、变量(variables)、方法(methods)、嵌套类(nested classes)</p>
<p><strong>静态代码块(static block)</strong> ：用于类的静态初始化</p>
<ol>
<li>静态代码块只会被执行一次，当第一次创建该类的对象或者第一次访问该类的静态成员时执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: Main.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line">	<span class="keyword">int</span> j; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// start of static block </span></span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		i = <span class="number">10</span>; </span><br><span class="line">		System.out.println(<span class="string">"static block called "</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// end of static block </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Although we don't have an object of Test, static block is </span></span><br><span class="line">		<span class="comment">// called because i is being accessed in following statement. </span></span><br><span class="line">		System.out.println(Test.i); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output ：</p>
<blockquote>
<p>static block called </p>
<p>10</p>
</blockquote>
<ol start="2">
<li>静态代码块在构造函数之前执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: Main.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line">	<span class="keyword">int</span> j; </span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		i = <span class="number">10</span>; </span><br><span class="line">		System.out.println(<span class="string">"static block called "</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	Test()&#123; </span><br><span class="line">		System.out.println(<span class="string">"Constructor called"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Although we have two objects, static block is executed only once. </span></span><br><span class="line">	Test t1 = <span class="keyword">new</span> Test(); </span><br><span class="line">	Test t2 = <span class="keyword">new</span> Test(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>static block called </p>
<p>Constructor called</p>
<p>Constructor called</p>
</blockquote>
<p><strong>静态变量(static variable)</strong> : 静态变量实质上就是全局变量，在该类的所有实例间共享</p>
<ol>
<li>只能在类级别创建静态变量，方法内部创建静态变量编译不通过</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">	System.out.println(fun()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x= <span class="number">10</span>; <span class="comment">//Error: Static local variables are not allowed </span></span><br><span class="line">	<span class="keyword">return</span> x--; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>静态代码块和静态变量按照他们在程序中的顺序执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java program to demonstrate execution </span></span><br><span class="line"><span class="comment">// of static blocks and variables </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// static variable </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = m1(); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static block </span></span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		System.out.println(<span class="string">"Inside static block"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"from m1"</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">20</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method(main !!) </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">	System.out.println(<span class="string">"Value of a : "</span>+a); </span><br><span class="line">	System.out.println(<span class="string">"from main"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output :</p>
<blockquote>
<p>from m1</p>
<p>Inside static block</p>
<p>Value of a : 20</p>
<p>“from main</p>
</blockquote>
<p><strong>静态方法(static method)</strong> : 可通过类直接访问</p>
<p>静态方法的一些使用限制：</p>
<ol>
<li>只能直接调用其他的静态方法</li>
<li>只能直接访问静态数据</li>
<li>静态方法里不能引用this和super</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java program to demonstrate(演示) restriction(限制) on static methods </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// static variable </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// instance variable </span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		a = <span class="number">20</span>; </span><br><span class="line">		System.out.println(<span class="string">"from m1"</span>); </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Cannot make a static reference to the non-static field b </span></span><br><span class="line">		b = <span class="number">10</span>; <span class="comment">// compilation error </span></span><br><span class="line">				</span><br><span class="line">		<span class="comment">// Cannot make a static reference to the </span></span><br><span class="line">				<span class="comment">// non-static method m2() from the type Test </span></span><br><span class="line">		m2(); <span class="comment">// compilation error </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Cannot use super in a static context </span></span><br><span class="line">		System.out.println(<span class="keyword">super</span>.a); <span class="comment">// compiler error </span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// instance method </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;	 </span><br><span class="line">		System.out.println(<span class="string">"from m2"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">// main method </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态变量和静态方法的使用</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A java program to demonstrate use of </span></span><br><span class="line"><span class="comment">// static keyword with methods and variables </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student class </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	String name; </span><br><span class="line">	<span class="keyword">int</span> rollNo; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static variable </span></span><br><span class="line">	<span class="keyword">static</span> String cllgName; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static counter to set unique roll no </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.name = name; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.rollNo = setRollNo(); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// getting unique rollNo </span></span><br><span class="line">	<span class="comment">// through static variable(counter) </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setRollNo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		counter++; </span><br><span class="line">		<span class="keyword">return</span> counter; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static method </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCllg</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">		cllgName = name ; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// instance method </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getStudentInfo</span><span class="params">()</span></span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"name : "</span> + <span class="keyword">this</span>.name); </span><br><span class="line">		System.out.println(<span class="string">"rollNo : "</span> + <span class="keyword">this</span>.rollNo); </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// accessing static variable </span></span><br><span class="line">		System.out.println(<span class="string">"cllgName : "</span> + cllgName); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//Driver class </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="comment">// calling static method </span></span><br><span class="line">		<span class="comment">// without instantiating Student class </span></span><br><span class="line">		Student.setCllg(<span class="string">"XYZ"</span>); </span><br><span class="line">	</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student(<span class="string">"Alice"</span>); </span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="string">"Bob"</span>); </span><br><span class="line">		</span><br><span class="line">		s1.getStudentInfo(); </span><br><span class="line">		s2.getStudentInfo(); </span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<blockquote>
<p>name : Alice</p>
<p>rollNo : 1</p>
<p>cllgName : XYZ</p>
<p>name : Bob</p>
<p>rollNo : 2</p>
<p>cllgName : XYZ</p>
</blockquote>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/d.jpeg" alt="静态变量内存存储结构"></p>
<p><strong>静态内部类(static inner classes)</strong> ：Java中允许一个类定义在另一个类的内部，称为嵌套类(nested classes)。定义嵌套类的类称为外部类(outer class)。非静态的嵌套类(non-static nested classes)也被称为内部类(inner classes)。内部类也可以是静态的，即为静态内部类(static inner classes)</p>
<p>静态内部类与内部类主要的不同点：</p>
<ol>
<li>静态内部类的实例化不依赖于其外部类的实例</li>
<li>内部类可以访问外部类的静态和非静态成员，而静态内部类只能访问外部类的静态成员</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to demonstrate how to </span></span><br><span class="line"><span class="comment">// implement static and non-static </span></span><br><span class="line"><span class="comment">// classes in a Java program. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String msg = <span class="string">"GeeksForGeeks"</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Static nested class </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedStaticClass</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only static members of Outer class </span></span><br><span class="line">		<span class="comment">// is directly accessible in nested </span></span><br><span class="line">		<span class="comment">// static class </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">		</span>&#123; </span><br><span class="line"></span><br><span class="line">			<span class="comment">// Try making 'message' a non-static </span></span><br><span class="line">			<span class="comment">// variable, there will be compiler error </span></span><br><span class="line">			System.out.println( </span><br><span class="line">				<span class="string">"Message from nested static class: "</span></span><br><span class="line">				+ msg); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Non-static nested class - </span></span><br><span class="line">	<span class="comment">// also called Inner class </span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Both static and non-static members </span></span><br><span class="line">		<span class="comment">// of Outer class are accessible in </span></span><br><span class="line">		<span class="comment">// this Inner class </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">		</span>&#123; </span><br><span class="line">			System.out.println( </span><br><span class="line">				<span class="string">"Message from non-static nested class: "</span></span><br><span class="line">				+ msg); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">	<span class="comment">// How to create instance of static </span></span><br><span class="line">	<span class="comment">// and non static nested class? </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create instance of nested Static class </span></span><br><span class="line">		OuterClass.NestedStaticClass printer </span><br><span class="line">			= <span class="keyword">new</span> OuterClass.NestedStaticClass(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Call non static method of nested </span></span><br><span class="line">		<span class="comment">// static class </span></span><br><span class="line">		printer.printMessage(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// In order to create instance of </span></span><br><span class="line">		<span class="comment">// Inner class we need an Outer class </span></span><br><span class="line">		<span class="comment">// instance. Let us create Outer class </span></span><br><span class="line">		<span class="comment">// instance for creating </span></span><br><span class="line">		<span class="comment">// non-static nested class </span></span><br><span class="line">		OuterClass outer = <span class="keyword">new</span> OuterClass(); </span><br><span class="line">		OuterClass.InnerClass inner </span><br><span class="line">			= outer.<span class="keyword">new</span> InnerClass(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Calling non-static method of Inner class </span></span><br><span class="line">		inner.display(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// We can also combine above steps in one </span></span><br><span class="line">		<span class="comment">// step to create instance of Inner class </span></span><br><span class="line">		OuterClass.InnerClass innerObject </span><br><span class="line">			= <span class="keyword">new</span> OuterClass().<span class="keyword">new</span> InnerClass(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Similarly we can now call Inner class method </span></span><br><span class="line">		innerObject.display(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>按值调用 （call by value) 表示方法接收的是调用者提供的值。而按引用调用 （ call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<p>Java 程序设计语言总是采用按值调用。也就是说， 方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<p>方法参数共有两种类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用（按值传递的）</li>
</ul>
<p>基本数据类型传的是值的拷贝，但是对象引用传的是引用地址的拷贝，也就是参数对象和原对象指向同一个地址，即引用的是同一个对象。</p>
<p>证明对象引用是按值传递的典型例子(交换对象)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x,Employee y)</span></span>&#123;</span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee a = <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>);</span><br><span class="line">Employee b = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line">swap(a,b);</span><br><span class="line"><span class="comment">//方法并没有改变存储在变量 a 和 b 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</span></span><br><span class="line"><span class="comment">//x refers to Alice ,y to Bob</span></span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line"><span class="comment">//now x refers to Bob, y to Alice</span></span><br><span class="line"><span class="comment">//但是方法结束时x和y就被丢弃了，a和b引用并没有变</span></span><br></pre></td></tr></table></figure>

<p>下面总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数</li>
<li>一个方法可以改变一个对象参数的状态（对象引用的拷贝与原对象指向同一个对象，当拷贝改变对象内容时，原对象也会就跟随改变了）</li>
<li>一个方法不能让对象参数引用一个新的对象（不能改变原引用的指向）</li>
</ul>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p><strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p>
<p>Java 允许重载任何方法， 而不只是构造器方法。因此，要完整地描述一个法，需要指出方法名以及参数类型。这叫做<strong>方法的签名（signature)</strong>。例如， String 类有 4 个称为 indexOf 的公有方法。它们的签名是</p>
<ul>
<li>indexOf(int)</li>
<li>indexOf(int,int)</li>
<li>indexOf(String)</li>
<li>indexOf(String,int)</li>
</ul>
<p><strong>返回类型不是方法签名的一部分。也就是说， 不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。</strong></p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>重载与重写的区别</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类中</td>
<td>子类中</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以减少或删除，一定不能抛出新的异常或更广的异常</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>范围大于等于父类</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h4 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h4><p>如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是， 实例域中的数值型数据设置为 0、 布尔型数据设置为 false、 所有对象变量将设置为 null。</p>
<p><strong>如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。</strong></p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>初始化属性的方法：</p>
<ul>
<li>构造器中设置值</li>
<li>声明时赋值</li>
</ul>
<p>初始化块也可以执行初始化，但不常用。<strong>首先运行初始化块在运行构造器。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//object initialization block</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0、false 或 null)</li>
<li>按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static initialization block</span></span><br><span class="line"><span class="comment">//在类第一次加载的时候， 将会进行静态域的初始化。</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">    nextId = generator.nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象析构与finalize方法"><a href="#对象析构与finalize方法" class="headerlink" title="对象析构与finalize方法"></a>对象析构与finalize方法</h4><p>因为Java有自动的垃圾回收机制，所以Java不支持析构器。但是存在某些对象使用了内存之外的其他资源， 例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时， 将其回收和再利用将显得十分重要。</p>
<p>可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个方法什么时候才能够调用。</p>
<p>有个名为<code>System.mnFinalizersOnExit(true)</code>的方法能够确保 finalizer 方法在 Java 关闭前被调用。不过，这个方法并不安全，也不鼓励大家使用。有一种代替的方法是使用方法<code>Runtime.addShutdownHook</code> 添加”关闭钩子”（shutdown hook),</p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><p>类路径所列出的目录和归档文件是搜寻类的起始点。下面看一个类路径示例：<br>/home/user/classdir:.:/home/user/archives/archive.jar</p>
<p>假定虚拟机要搜寻 com.horstmann.corejava.Employee 类文件。它首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找以下文件：</p>
<ul>
<li>/home/user/classdir/com/horstmann/corejava/Employee.class</li>
<li>com/horstmann/corejava/Employee.class 从当前目录开始</li>
<li>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</li>
</ul>
<p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并查询所有的 import 指令，确定其中是否包含了被引用的类。例如， 假定源文件包含指令：</p>
<p>import java.util.<em>;<br>import com.horstmann.corejava.</em>;</p>
<p>并且源代码引用了 Employee 类。 编译器将试图查找 java.lang.Employee (因为java.lang 包被默认导入）、java.util.Employee、 com.horstmann.corejava.Employee 和当前包中的 Employee。</p>
<p>对这个类路径的所有位置中所列出的每一个类进行逐一查看。如果找到了一个以上的类， 就会产生编译错误（因为类必须是唯一的，而 import 语句的次序却无关紧要）。</p>
<h4 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h4><p>最好采用 -classpath (或 -cp) 选项指定类路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath /home/user/classdir:.:/home/user/archives/archives MyProg</span><br></pre></td></tr></table></figure>

<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol>
<li><p>一定要保证数据私有</p>
</li>
<li><p>一定要对数据初始化</p>
</li>
<li><p>不要在类中使用过多的基本类型</p>
</li>
<li><p>不是所有的域都需要独立的域访问器和域更改器</p>
</li>
<li><p>将职责过多的类进行分解</p>
</li>
<li><p>类名和方法名要能够体现它们的职责</p>
</li>
<li><p>优先使用不可变的类</p>
</li>
</ol>
<h2 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h2><h3 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><h4 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name,<span class="keyword">double</span> salary,<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">    bonus=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 super 实现对超类构造器的调用。使用super 调用构造器的语句必须是子类构造器的第一条语句。</p>
<p>如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在 Java 程序设计语言中，对象变量是多态的。 一个 Employee 变量既可以引用一个Employee 类对象， 也可以引用一个 Employee 类的任何一个子类的对象（例如， Manager、Executive、Secretary 等）。</p>
<p>一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为<strong>多态（ polymorphism)</strong>。<br>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定（ dynamic binding）</strong>。</p>
<h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><p>以 <strong>x.f(args)，隐式参数 x 声明为类 C 的一个对象</strong> 为例，分析方法调用如下：</p>
<ol>
<li>编译器査看对象的声明类型和方法名。假设调用 x.f(param)， 且隐式参数 x 声明为 C类的对象。需要注意的是：有可能存在多个名字为 f, 但参数类型不一样的方法。例如，可能存在方法 f(int) 和方法 f(String)。 编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）</li>
<li>接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重栽解析（ overloading resolution)。</li>
<li>如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding )。 与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。在我们列举的示例中， 编译器采用动态绑定的方式生成一条调用 f(String) 的指令。</li>
<li>当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了方法 f(String)， 就直接调用它；否则， 将在 D 类的超类中寻找 f(String)， 以此类推。</li>
</ol>
<p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。在前面的例子中， 虚拟机搜索 D 类的方法表， 以便寻找与调用 f(Sting) 相匹配的方法。这个方法既有可能是 D.f(String), 也有可能是X.f(String), 这里的 X 是 D 的超类。这里需要提醒一点，如果调用 super.f(param), 编译器将对隐式参数超类的方法表进行搜索。</p>
<p>简化后：</p>
<ol>
<li>虚拟机查询出所有x的声明类型及方法名为f的方法（利用方法表）</li>
<li>虚拟机根据x的实际类型以及调用参数确定最终调用的方法（利用运行时动态绑定）</li>
<li>调用方法</li>
</ol>
<h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h4><p>不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。final类中只有其中的方法自动地成为 final,而不包括域。</p>
<p>在早期的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。这是一项很有意义的改进， 这是由于 CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而，如果 getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。<br>幸运的是， 虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、 被频繁调用且没有真正地被覆盖， 那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖， 那么将会发生什么情况呢？ 优化器将取消对覆盖方法的内联。这个过程很慢， 但却很少发生。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>将一个类型强制转换成另外一个类型的过程被称为类型转换。</p>
<p>将一个子类的引用赋给一个超类变量， 编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行类型转换，一个好的设计习惯是在进行类型转换之前，先查看一下是否能够成功地转换（避免抛出ClassCastException异常）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manager boss = <span class="keyword">null</span>;</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[]&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager)&#123;</span><br><span class="line">    boss = (Manager)staff[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类不能被实例化。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractPerson</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>如果希望超类中的某些方法允许被子类访问， 或允许子类的方法访问超类的某个域。可以将这些方法或域声明为 protected。protected修饰的属性或方法只允许在本类及子类中访问，在其他类中无法访问。典型示例就是Object 类中的 clone 方法。</p>
<h3 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h3><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>Java 语言规范要求 equals 方法具有下面的特性：</p>
<ol>
<li>自反性：对于任何非空引用 x, x.equals(x) 应该返回 true</li>
<li>对称性：对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true , x.equals(y) 也应该返回 true</li>
<li>传递性：对于任何引用 x、 y 和 z, 如果 x.equals(y) 返回 true， y.equals(z) 返回 true,x.equals(z) 也应该返回 true。</li>
<li>一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果</li>
<li>对于任意非空引用 x, x.equals(null) 应该返回 false,</li>
</ol>
<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>编写一个完美equals方法的建议：</p>
<ol>
<li>显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。</li>
<li>检测 this 与 otherObject 是否引用同一个对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将 otherObject 转换为相应的类类型变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName other = (ClassName)otherObject;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>现在开始对所有需要比较的域进行比较了。使用 =比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1 &amp;&amp; Objects.equals(field1,field2) &amp;&amp; ...;</span><br></pre></td></tr></table></figure>



<p>注意：如果在子类中重新定义 equals, 就要在其中包含调用 super.equals(other)。</p>
<h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><p>如果重新定义 equals方法，就必须重新定义 hashCode 方法。Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值。</p>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>强烈建议为自定义的每一个类增加 toString 方法。</p>
<h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到固定的对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line">a = <span class="number">1000</span>;</span><br><span class="line">b = <span class="number">1000</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：装箱和拆箱是编译器的行为，而不是虚拟机的行为。编译器在生成类的字节码时， 插人必要的方法调用。虚拟机只是执行这些字节码。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size&#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>),MEDIUM(<span class="string">"M"</span>),LARGE(<span class="string">"L"</span>),EXTRA_LARGE(<span class="string">"XL"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String abbr;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbr)</span> </span>&#123; <span class="keyword">this</span>.abbr = abbr;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.abbr;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上， 这个声明定义的类型是一个类， 它刚好有 4 个实例， 在此尽量不要构造新对象。因此， 在比较两个枚举类型的值时， 永远不需要调用 equals, 而直接使用“= =” 就可以了</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序称为<strong>反射（reflective )</strong>。</p>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>获取Class类对象的三种方式（eg：Employee  e）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">Class c = e.getClass();</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.bean.Employee"</span>);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">Class c = Employee<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>虚拟机为每个类型管理一个 Class 对象。 因此，可以利用 == 运算符实现两个类对象比较的操作。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.getClass() == Employee<span class="class">.<span class="keyword">class</span>) ...</span></span><br></pre></td></tr></table></figure>

<p>还有一个很有用的方法 newlnstance( )， 可以用来动态地创建一个类的实例。newlnstance方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常 。</p>
<h4 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h4><p>Class类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的public 域、 方法和构造器数组， 其中包括超类的公有成员。Class 类的 getDeclareFields、getDeclareMethods 和getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。</p>
<p>API如下：</p>
<p><code>java.lang.Class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回本类及父类中所有public属性，如果没有满足条件的将返回长度为0的数组（以下几种情况均适用）</span></span><br><span class="line">Field[] getFields();</span><br><span class="line"><span class="comment">//只返回本类中的全部属性</span></span><br><span class="line">Field[] getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回本类及父类或者父接口中所有public的方法</span></span><br><span class="line">Method[] getMethods();</span><br><span class="line"><span class="comment">//只返回本类中所有的方法</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回本类中所有public的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] getConstructors();</span><br><span class="line"><span class="comment">//返回本类中所有的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Field</code>、<code>java.lang.reflect.Method</code>、<code>java.lang.reflect.Constructor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返冋一个用于描述类中定义的构造器、 方法或域的 Class 对象。</span></span><br><span class="line">Class&lt;?&gt; getDeclaringClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述构造器、 方法或域的修饰符的整型数值。使用 Modifier 类中的方法可以分析这个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返冋一个用于描述构造器、 方法、属性的名字。</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述方法抛出的异常类型的 Class 对象数组（只在Method和Constructor中存在）</span></span><br><span class="line">Class&lt;?&gt;[] getExceptionTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述参数类型的 Class 对象数组（只在Method和Constructor中存在）</span></span><br><span class="line">Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用于描述返H类型的 Class 对象(只在Method中存在)</span></span><br><span class="line">Class&lt;?&gt; getReturnType();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Modifier</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回对应 modifiers 中位设置的修饰符的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测修饰符中是否含有相应的修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPublic</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrivate</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProtected</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFinal</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSynchronized</span><span class="params">(<span class="keyword">int</span> mod)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="运行时使用反射分析对象"><a href="#运行时使用反射分析对象" class="headerlink" title="运行时使用反射分析对象"></a>运行时使用反射分析对象</h4><p>通过反射获取属性值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name属性为private的</span></span><br><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>);</span><br><span class="line"><span class="comment">//1.获取实例对象所属的类</span></span><br><span class="line">Class cl = harry.getClass();</span><br><span class="line"><span class="comment">//2.获取类的name属性信息</span></span><br><span class="line">Field f = cl.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//设置访问权限</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//3.通过unsafe获取对象中该属性的值，如果属性类型是基础类型，反射机制将会自动地将这个域值打包到相应的对象包装器中，比如double =&gt; Double</span></span><br><span class="line">Object v = f.get(harry);</span><br></pre></td></tr></table></figure>

<p>另外，反射机制的默认行为受限于 Java 的访问控制。所以需要通过<code>f.setAccessible(true)</code>将属性、方法或者构造器设置成可访问的。</p>
<h4 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span>(!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType,newLength);</span><br><span class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:这个 CopyOf 方法可以用来扩展任意类型的数组， 而不仅是对象数组。因为基础类型数组比如int[] 可以被转换成Object，而不能被转成Object[]。</p>
<h4 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h4><ol>
<li>先获取Method对象<code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>，比如<code>Math.class.getMethod(&quot;sqrt&quot;,double.class)</code></li>
<li>调用方法<code>Object invoke(Object obj, Object... args)</code>，比如<code>f.invoke(harry,35000)</code>，如果调用的是静态方法，obj参数设置成null即可</li>
</ol>
<h2 id="6-接口、内部类、lambda表达式"><a href="#6-接口、内部类、lambda表达式" class="headerlink" title="6. 接口、内部类、lambda表达式"></a>6. 接口、内部类、lambda表达式</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>在 Java 程序设计语言中， 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<p>接口中的所有方法自动地属于 public。 因此，在接口中声明方法时，不必提供关键字public 。</p>
<p><code>java.util.Arrays</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了Comparable 接口的类， 并且元素之间必须是可比较的。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h4><p>在接口中不能包含实例域或静态方法，但却可以包含常量。</p>
<p>与接口中的方法都自动地被设置为 public—样，接口中的域将被自动设为 public static final。</p>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在 Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">get</span><span class="params">(String first,String... more)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystems.getDefault().getPath(first,more);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个默认实现。 必须用<code>default</code> 修饰符标记这样一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>规则如下：</p>
<ol>
<li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会<br>被忽略。</li>
<li>接口冲突。 如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法， 必须覆盖这个方法来解决冲突。</li>
</ol>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>Java8之后该接口进行了增强（结合lambda表达式）</p>
<p>典型示例：<code>Arrays.sort(T[],Comparator)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>默认的克隆操作是“ 浅拷贝”，并没有克隆对象中引用的其他对象。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类（ inner class) 是定义在另一个类中的类。内部类解决的需求有以下三点：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较<br>便捷。</li>
</ol>
<h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>创建内部类实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerObject.<span class="keyword">new</span> InnerClass(construction parameters);</span><br></pre></td></tr></table></figure>

<p>在外围类的作用域之外，可以这样引用内部类：<code>OuterClass.InnerClass</code>。内部类中声明的所有静态域都必须是 final。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于构造器的名字必须与类名相同， 而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类（ superclass) 构造器。尤其是在内部类实现接口的时候， 不能有任何构造参数。</p>
<p><strong>双括号初始化</strong>：利用了内部类的语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">friends.add(<span class="string">"Harry"</span>);</span><br><span class="line">friends.add(<span class="string">"Tony"</span>);</span><br><span class="line">invite(friends);</span><br><span class="line"></span><br><span class="line"><span class="comment">//双括号初始化法表示</span></span><br><span class="line"><span class="comment">//注意这里的双括号。外层括号建立了 ArrayList 的一个匿名子类。内层括号则是一个对象构造块</span></span><br><span class="line">invite(<span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123; add(<span class="string">"Harry"</span>); add(<span class="string">"Tony"</span>);&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>获取当前类的类名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过this.getClass()方法获取，但对于静态方法不奏效</span></span><br><span class="line">Systen.err.println(<span class="string">"Something awful happened in "</span> + getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法使用</span></span><br><span class="line"><span class="comment">//newObject()&#123;&#125; 会建立 Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类， 也就是包含这个静态方法的类。</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;&#125;.getCIass().getEndosingClass(); <span class="comment">// gets class of static method</span></span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>当内部类不需要引用外部类的对象，只是为了把一个类藏到另一个类的内部，此时可以将内部类声明为<code>static</code>，以便取消产生的引用，该内部类即静态内部类。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>在内部类不需要访问外围类对象的时候， 应该使用静态内部类。</li>
<li>与常规内部类不同，静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类。</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>通过Proxy 类的 newProxylnstance 方法，三个参数：</p>
<ul>
<li>一个类加栽器（class loader）</li>
<li>一个 Class 对象数组， 每个元素都是需要实现的接口</li>
<li>一个调用处理器（invocation  handler）</li>
</ul>
<p>调用处理器是实现了InvocationHandler接口的类对象，这个接口只有一个方法<code>public Object invoke(Object proxy, Method method, Object[] args)</code>，无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用， 并向其传递Method 对象和原始的调用参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            Integer value = i + <span class="number">1</span>;</span><br><span class="line">            InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(<span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;Comparable<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">handler</span>)</span>;</span><br><span class="line">            elements[i] = proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer key = <span class="keyword">new</span> Random().nextInt(elements.length) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分查找通过元素的compareTo方法与key进行比较,int cmp = midVal.compareTo(key);</span></span><br><span class="line">        <span class="keyword">int</span> result = Arrays.binarySearch(elements, key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) System.out.println(elements[result]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TraceHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.print(target);</span><br><span class="line">            System.out.print(<span class="string">"."</span> + method.getName() + <span class="string">"("</span>);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    System.out.print(args[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; args.length - <span class="number">1</span>) System.out.print(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h4><p>所有的代理类都扩展于 Proxy 类。一个代理类只有一个实例域—调用处理器，它定义在 Proxy 类中。</p>
<p>没有定义代理类的名字，Sun 虚拟机中的 Proxy类将生成一个以字符串 $Proxy 开头的类名。对于特定的类加载器和预设的一组接口来说，只能有一个代理类。 也就是说，如果使用同一个类加载器和接口数组调用两次newProxylustance方法的话， 那么只能够得到同一个类的两个对象。</p>
<p><code>API</code></p>
<p><code>java.lang.reflect.InvocationHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了代理对象调用方法时希望执行的动作</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Proxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回实现指定接口的代理类</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,</span><br><span class="line">                                         Class&lt;?&gt;... interfaces);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造实现指定接口的代理类的一个新实例。</span></span><br><span class="line"><span class="comment">//所有代理对象的方法调用都会调用给定处理器对象的 invoke 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span>;</span><br><span class="line"><span class="comment">//判断类是否是代理类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span>;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/27/blog-hexo-hexo-github/" rel="prev" title="Hexo + Github搭建个人博客">
      <i class="fa fa-chevron-left"></i> Hexo + Github搭建个人博客
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/07/book-java-Core-Java-HashMap/" rel="next" title="HashMap 源码分析">
      HashMap 源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java程序设计概述"><span class="nav-number">1.</span> <span class="nav-text">1.Java程序设计概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的特点"><span class="nav-number">1.1.</span> <span class="nav-text">Java的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java程序设计环境"><span class="nav-number">2.</span> <span class="nav-text">2.Java程序设计环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-JDK-JRE"><span class="nav-number">2.1.</span> <span class="nav-text">JVM&#x2F;JDK&#x2F;JRE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java的基本程序设计结构"><span class="nav-number">3.</span> <span class="nav-text">3.Java的基本程序设计结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">3.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整型"><span class="nav-number">3.1.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浮点类型"><span class="nav-number">3.1.2.</span> <span class="nav-text">浮点类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">3.2.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数值类型之间的转换"><span class="nav-number">3.2.1.</span> <span class="nav-text">数值类型之间的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结合赋值和运算符"><span class="nav-number">3.2.2.</span> <span class="nav-text">结合赋值和运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自增与自减运算符"><span class="nav-number">3.2.3.</span> <span class="nav-text">自增与自减运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位运算符"><span class="nav-number">3.2.4.</span> <span class="nav-text">位运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">3.3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不可变字符串"><span class="nav-number">3.3.1.</span> <span class="nav-text">不可变字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测字符串是否相等"><span class="nav-number">3.3.2.</span> <span class="nav-text">检测字符串是否相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空串与Null串"><span class="nav-number">3.3.3.</span> <span class="nav-text">空串与Null串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构建字符串"><span class="nav-number">3.3.4.</span> <span class="nav-text">构建字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符常量和字符串常量的区别"><span class="nav-number">3.3.5.</span> <span class="nav-text">字符常量和字符串常量的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入输出"><span class="nav-number">3.4.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#读取输入"><span class="nav-number">3.4.1.</span> <span class="nav-text">读取输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化输出"><span class="nav-number">3.4.2.</span> <span class="nav-text">格式化输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制流程"><span class="nav-number">3.5.</span> <span class="nav-text">控制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多重选择：switch语句"><span class="nav-number">3.5.1.</span> <span class="nav-text">多重选择：switch语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大数值"><span class="nav-number">3.6.</span> <span class="nav-text">大数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.7.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#foreach循环"><span class="nav-number">3.7.1.</span> <span class="nav-text">foreach循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组初始化及匿名数组"><span class="nav-number">3.7.2.</span> <span class="nav-text">数组初始化及匿名数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组拷贝"><span class="nav-number">3.7.3.</span> <span class="nav-text">数组拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令行参数"><span class="nav-number">3.7.4.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不规则数组"><span class="nav-number">3.7.5.</span> <span class="nav-text">不规则数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-对象与类"><span class="nav-number">4.</span> <span class="nav-text">4.对象与类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">4.1.</span> <span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">4.1.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">4.1.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类"><span class="nav-number">4.1.3.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final、finally、finalize的区别"><span class="nav-number">4.1.4.</span> <span class="nav-text">final、finally、finalize的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract"><span class="nav-number">4.2.</span> <span class="nav-text">abstract</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">4.3.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法"><span class="nav-number">4.4.</span> <span class="nav-text">工厂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法参数"><span class="nav-number">4.5.</span> <span class="nav-text">方法参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象构造"><span class="nav-number">4.6.</span> <span class="nav-text">对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载"><span class="nav-number">4.6.1.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无参构造器"><span class="nav-number">4.6.2.</span> <span class="nav-text">无参构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化块"><span class="nav-number">4.6.3.</span> <span class="nav-text">初始化块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象析构与finalize方法"><span class="nav-number">4.6.4.</span> <span class="nav-text">对象析构与finalize方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类路径"><span class="nav-number">4.7.</span> <span class="nav-text">类路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设置类路径"><span class="nav-number">4.7.1.</span> <span class="nav-text">设置类路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档注释"><span class="nav-number">4.8.</span> <span class="nav-text">文档注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类设计技巧"><span class="nav-number">4.9.</span> <span class="nav-text">类设计技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-继承"><span class="nav-number">5.</span> <span class="nav-text">5.继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类、超类和子类"><span class="nav-number">5.1.</span> <span class="nav-text">类、超类和子类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子类构造器"><span class="nav-number">5.1.1.</span> <span class="nav-text">子类构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">5.1.2.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解方法调用"><span class="nav-number">5.1.3.</span> <span class="nav-text">理解方法调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻止继承：final类和方法"><span class="nav-number">5.1.4.</span> <span class="nav-text">阻止继承：final类和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换"><span class="nav-number">5.1.5.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类"><span class="nav-number">5.1.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#受保护访问"><span class="nav-number">5.1.7.</span> <span class="nav-text">受保护访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object：所有类的超类"><span class="nav-number">5.2.</span> <span class="nav-text">Object：所有类的超类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals方法"><span class="nav-number">5.2.1.</span> <span class="nav-text">equals方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相等测试与继承"><span class="nav-number">5.2.2.</span> <span class="nav-text">相等测试与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode方法"><span class="nav-number">5.2.3.</span> <span class="nav-text">hashCode方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString方法"><span class="nav-number">5.2.4.</span> <span class="nav-text">toString方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象包装器与自动装箱"><span class="nav-number">5.3.</span> <span class="nav-text">对象包装器与自动装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类"><span class="nav-number">5.4.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射"><span class="nav-number">5.5.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Class类"><span class="nav-number">5.5.1.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用反射分析类的能力"><span class="nav-number">5.5.2.</span> <span class="nav-text">利用反射分析类的能力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时使用反射分析对象"><span class="nav-number">5.5.3.</span> <span class="nav-text">运行时使用反射分析对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用反射编写泛型数组代码"><span class="nav-number">5.5.4.</span> <span class="nav-text">使用反射编写泛型数组代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用任意方法"><span class="nav-number">5.5.5.</span> <span class="nav-text">调用任意方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-接口、内部类、lambda表达式"><span class="nav-number">6.</span> <span class="nav-text">6. 接口、内部类、lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">6.1.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口概念"><span class="nav-number">6.1.1.</span> <span class="nav-text">接口概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口特性"><span class="nav-number">6.1.2.</span> <span class="nav-text">接口特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口与抽象类"><span class="nav-number">6.1.3.</span> <span class="nav-text">接口与抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法"><span class="nav-number">6.1.4.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认方法"><span class="nav-number">6.1.5.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决默认方法冲突"><span class="nav-number">6.1.6.</span> <span class="nav-text">解决默认方法冲突</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口示例"><span class="nav-number">6.2.</span> <span class="nav-text">接口示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator接口"><span class="nav-number">6.2.1.</span> <span class="nav-text">Comparator接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象克隆"><span class="nav-number">6.2.2.</span> <span class="nav-text">对象克隆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">6.3.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类的特殊语法规则"><span class="nav-number">6.3.1.</span> <span class="nav-text">内部类的特殊语法规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名内部类"><span class="nav-number">6.3.2.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态内部类"><span class="nav-number">6.3.3.</span> <span class="nav-text">静态内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理"><span class="nav-number">6.4.</span> <span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建代理对象"><span class="nav-number">6.4.1.</span> <span class="nav-text">创建代理对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理类的特性"><span class="nav-number">6.4.2.</span> <span class="nav-text">代理类的特性</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZGQ"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZGQ</p>
  <div class="site-description" itemprop="description">Java</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengguoqiang927" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengguoqiang927" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengguoqiang927@gmail.com" title="E-Mail → mailto:zhengguoqiang927@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">左耳朵耗子</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;" rel="noopener" target="_blank">廖雪峰</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZGQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://johnson-5.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/04/07/book-java-Core-Java-Fundamentals/";
    this.page.identifier = "2020/04/07/book-java-Core-Java-Fundamentals/";
    this.page.title = "Java核心技术 - 基础知识卷";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://johnson-5.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
