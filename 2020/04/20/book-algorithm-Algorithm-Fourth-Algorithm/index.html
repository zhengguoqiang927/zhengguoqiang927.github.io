<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Georgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基础数据结构与算法简介数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。 数据结构与算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法第四版">
<meta property="og:url" content="http://yoursite.com/2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="基础数据结构与算法简介数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。 数据结构与算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_merge_sort_time.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarysearch_trace.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarysearchtree.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_mapping_line.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_put.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_analyze.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_floor.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_select.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_delete.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_keys.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_definition.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_search.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_2node_insert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_single3node_insert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_23node_insert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_33node_insert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_splitroot.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_split4node.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_propositionF.png">
<meta property="article:published_time" content="2020-04-20T07:28:45.000Z">
<meta property="article:modified_time" content="2020-06-12T10:21:09.403Z">
<meta property="article:author" content="ZGQ">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_merge_sort_time.png">

<link rel="canonical" href="http://yoursite.com/2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法第四版 | Z's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ZGQ">
      <meta itemprop="description" content="Java">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法第四版
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 15:28:45" itemprop="dateCreated datePublished" datetime="2020-04-20T15:28:45+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-12 18:21:09" itemprop="dateModified" datetime="2020-06-12T18:21:09+08:00">2020-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>38k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>35 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据结构与算法简介"><a href="#数据结构与算法简介" class="headerlink" title="数据结构与算法简介"></a>数据结构与算法简介</h3><p>数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。</p>
<p>数据结构与算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p>
<a id="more"></a>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>复杂度分析就是分析算法的执行效率和资源消耗与数据规模之间的增长关系。</p>
<h4 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h4><p>所有代码的执行时间T(n)与每行代码的执行次数n成正比，公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n) &#x3D; O(f(n));</span><br></pre></td></tr></table></figure>

<p>T(n)表示代码执行的时间；n表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>这就是<strong>大O时间复杂度表示法</strong>  。大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong> (asymptotic time complexity)，简称<strong>时间复杂度</strong>。</p>
<p>随着n的增长，公司中的低阶、常量、系数并不左右增长趋势，所以都可以忽略，只需要记住最大量级就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//1个unit_time</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//1个unit_time</span></span><br><span class="line"> <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;<span class="comment">//n个unit_time</span></span><br><span class="line">	sum = sum + i;<span class="comment">//n个unit_time</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时间T(n) = (2n + 2) * unit_time ，可以记为 T(n) = O(n)。</p>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>分析时间复杂度时主要关注点：</p>
<ol>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<h4 id="常见时间复杂度实例分析"><a href="#常见时间复杂度实例分析" class="headerlink" title="常见时间复杂度实例分析"></a>常见时间复杂度实例分析</h4><p>常见时间复杂度量级：</p>
<p>Algorithm_O_complex.png</p>
<p>以上复杂度量级可以粗略的分为：<strong>多项式量级</strong>和<strong>非多项式量级</strong>，而非多项式量级只有两个：O($2^n$) 和 O(n!)</p>
<p>随着数据规模n的增长，非多项式量级算法的执行时间会急剧增加，非常低效，不做讨论。这里只列举多项式量级的复杂度实例分析。</p>
<ol>
<li>O(1)</li>
</ol>
<p><strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千 上万行的代码，其时间复杂度也是Ο(1)</strong>。</p>
<ol start="2">
<li>O(logn) 、O(nlogn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码执行次数最多的是第三行，所以只要知道第三行代码的执行次数就能分析出该段代码的时间复杂度。这行代码最多执行次数满足条件 $2^x$ = n，x = logn。所以T(n) = O(logn).</p>
<ol start="3">
<li>O(m+n)、O(m*n)</li>
</ol>
<h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>(asymptotic space complexity)，<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//存储变量i的空间</span></span><br><span class="line"> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存储n个整型的数组所需的空间</span></span><br><span class="line"> <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">	a[i] = i * i;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"> print out a[i]</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码只有第三行申请了一个大小为n的int类型数组，所以空间复杂度为O(n).</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O($n^2$)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到.</p>
<p>常见的复杂度从低阶到高阶：O(1)、O(logn)、O(n)、O(nlogn)、O($n ^ 2$)</p>
<h4 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h4><p><strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。</strong></p>
<p><strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的意图是在长度为n的数组里查找x，那么最理想的情况是x恰好就在数组第一个位置，那么最好情况时间复杂度就是O(1)，最糟糕情况就是x不在数组中，那么就要遍历整个数组，那么最坏情况时间复杂度就是O(n)</p>
<h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>上面的代码平均情况时间复杂度分析：</p>
<p>要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p>
<p>1+2+3+….+n+n / n + 1 = n(n+3)/2(n+1) ~ O(n)</p>
<p>上面这种计算方式存在一个问题，就是没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，计算方式如下：</p>
<p>我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)，计算公式如下：</p>
<p>algorithm_average_time_complexity.png</p>
<p>这个值就是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p>
<p>这个公式的结果去掉常量及系数后，平均时间复杂度为O(n)</p>
<h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><p>均摊时间复杂度就是一种特殊的平均时间复杂度</p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是一种非常高效、简洁的编码技巧。递归求解问题就是将问题拆分成求解思路一样的子问题，子问题在拆分成子子问题，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。</p>
<h4 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h4><ol>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>问题与分解后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ol>
<p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。总结为：<strong>写出递推公式，找到终止条件</strong> </p>
<h4 id="递归要警惕的问题"><a href="#递归要警惕的问题" class="headerlink" title="递归要警惕的问题"></a>递归要警惕的问题</h4><ul>
<li>堆栈溢出</li>
</ul>
<p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出站。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p>避免堆栈溢出的方法：通过限制递归调用的最大深度来解决。通过计数器记录调用的深度，当深度到达某个值之后就不在继续往下递归，直接返回报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量，表示递归的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ++depth;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"递归深度范围过大"</span>);</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重复计算</li>
</ul>
<p>algorithm_recursion_repeat.png</p>
<p>图中的f(3)被重复计算了多次。</p>
<p>解决重复计算的方法：采用一个数据结构（比如散列表）来存储求解过的f(k)，当递归调用到f(k)时，判断是否求解过f(k)，如果求解过直接返回即可。</p>
<ul>
<li>时间复杂度和空间复杂度增加</li>
</ul>
<p>时间复杂度：递归实现里多了很多函数调用，当函数调用的数量较大时，就会积聚成一个可观的时间成本。</p>
<p>空间复杂度：每递归调用一次，内存栈都需要保存一次现场数据，这也需要额外的空间开销。</p>
<blockquote>
<p>递归调试技巧：</p>
<ol>
<li>打印日志输出递归值</li>
<li>结合条件断点进行调试</li>
</ol>
</blockquote>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找（Binary Search）算法，也叫折半查找算法。思想非常简单，<strong>二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong></p>
<p>algorithm_binary_search.png</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<p>algorithm_binary_search_time.png</p>
<p>可以看出来，这是一个等比数列。其中 n/2k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。</p>
<p>扩展：数据采用链表存储时，也就是有序的链表二分查找的时间复杂度为O(n)</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>非递归实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//注意点1：循环退出条件是low &lt;= high</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    <span class="comment">//注意点2：也可以采用 low + ((high-low)&gt;&gt;1),效率更高，但不推荐 (low+high)/2,因为如果low和high都很大的话，两者之和可能发生溢出</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == a[mid])&#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; a[mid])&#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchByRecusive</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (value == a[mid])&#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; a[mid])&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchByRecusive(a,mid + <span class="number">1</span>,hi,value);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearchByRecusive(a,lo,mid - <span class="number">1</span>,value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景的局限"><a href="#适用场景的局限" class="headerlink" title="适用场景的局限"></a>适用场景的局限</h4><ol>
<li>二分查找依赖于顺序表结构，其实就是必须用数组来存储数据</li>
</ol>
<p>因为二分查找算法需要按照下标随机访问元素</p>
<ol start="2">
<li>二分查找针对的是有序数据</li>
</ol>
<p>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。因为动态变化的数据集合，要维护它的有序性，需要花费很高的成本</p>
<ol start="3">
<li>二分查找的数据量不能太大也不能太小</li>
</ol>
<p>如果需要处理的数据量较少，直接使用顺序遍历就可以了，因为两者的处理速度差不多。但有一个例外，当数据的比较操作非常耗时，比如长度超过300的字符串，这时应该尽量减少比较次数，所以应该采用二分查找</p>
<p>同样，数据量也不能太大，因为二分查找依赖支持随机访问的数组，而数组需要连续的内存空间，如果数据量过大的话，需要有够大的连续的内存空间的支持，而通常内存空间是零散的，很难申请一个非常大的连续的内存空间，所以这种情况下二分查找也无法使用</p>
<blockquote>
<p>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</p>
</blockquote>
<h4 id="二分查找变形问题"><a href="#二分查找变形问题" class="headerlink" title="二分查找变形问题"></a>二分查找变形问题</h4><p>algorithm_binary_search_mutation.png</p>
<h5 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h5><p>algorithm_binary_search_m1.png</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h5><h5 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h5><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>定义中的几个关键词：</p>
<ol>
<li><strong>线性表（Linear List）</strong></li>
</ol>
<p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<p>Algorithm_array_linear_list.png</p>
<p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<p>Algorithm_array_non_linear_list.png</p>
<ol start="2">
<li><strong>连续的内存空间和相同类型的数据</strong></li>
</ol>
<p>因为其连续的内存空间，所以支持根据下标随机访问，但同时使插入和删除操作变得低效，因为需要大量的移动元素。</p>
<p>当内存中没有连续的、足够大的创建数组所需要的存储空间时，会申请失败。</p>
<h4 id="高效的随机访问"><a href="#高效的随机访问" class="headerlink" title="高效的随机访问"></a>高效的随机访问</h4><p>Algorithm_array_memory.png</p>
<p>该图是int[] a = new int[10] 数组的内存空间分配图，因为int类型占用4个字节，所以该数组占用一块40个字节的连续内存空间，内存块的首地址为 base_address = 1000。计算机通过地址访问内存中数据，随机访问数组中某个元素的寻址公式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size;<span class="comment">//data_type_size在这里为4个字节</span></span><br></pre></td></tr></table></figure>

<p>数组和链表的区别：</p>
<p>链表适合做插入、删除操作，时间复杂度为O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。当在一个有序的数组中进行查找的时候，可以采用二分查找，时间复杂度为O(logn).</p>
<h4 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h4><p>将一个数据插入到一个长度为n的数组中的第k个位置时，需要将k~n的元素向后移动一位，为该元素腾出第k个位置。最好情况时间复杂度(即k=n，从数组末尾插入)：O(1)；最坏情况时间复杂度(即k=0，从数组开头插入)：O(n)；平均情况时间复杂度(即k在各个位置出现的概率相等，为1/n)：(1+2+…+ n)/n = O(n).</p>
<p>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>
<p>algorithm_array_insert_simple.png</p>
<p>这种情况下的时间复杂度降为O(1).</p>
<p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)</p>
<p>举个例子，数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>
<p>algorithm_array_delete_eg.png</p>
<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。这正是<strong>JVM 标记清除垃圾回收算法的核心思想</strong>。</p>
<h4 id="容器和数组"><a href="#容器和数组" class="headerlink" title="容器和数组"></a>容器和数组</h4><p>容器最大的优势就是将很多数组操作的细节进行了封装，并且支持动态扩容。比如插入、删除操作时的移动数据，容器已经封装好，程序员可以直接使用。</p>
<p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。不过，这里需要注意一点，因为<strong>扩容操作涉及内存申请和数据搬移，是比较耗时的</strong>。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建 ArrayList 的时候事先指定数据大小</strong>。</p>
<p>适合使用数组的场景：</p>
<ol>
<li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li>
<li>当表示多为数组时，Object[][] array更为直观；而用容器的话需要这样定义：ArrayList<ArrayList> array</li>
</ol>
<h4 id="数组要从-0-开始编号，而不是从-1-开始"><a href="#数组要从-0-开始编号，而不是从-1-开始" class="headerlink" title="数组要从 0 开始编号，而不是从 1 开始"></a>数组要从 0 开始编号，而不是从 1 开始</h4><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure>

<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-<span class="number">1</span>)*type_size</span><br></pre></td></tr></table></figure>

<p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>链表也是一种线性表数据结构，不像数组那样需要一块连续的内存空间，链表通过”指针“将一组零散的内存块串联起来</p>
<p>algorithm_linkedlist_define.png</p>
<h4 id="常见的链表"><a href="#常见的链表" class="headerlink" title="常见的链表"></a>常见的链表</h4><p>常见的链表结构：单链表、双向链表、循环链表</p>
<p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。指针分为<strong>前驱指针</strong> 和 <strong>后继指针</strong> ，前驱指针prev用来记录上一个结点的地址，后继指针next用来记录下一个结点的地址。并且把链表的第一个结点叫头结点，最后一个结点叫尾结点。头结点用来记录链表的基地址，尾结点的后继指针指向一个<strong>空地址NULL</strong> </p>
<p>algorithm_linkedlist_single.png</p>
<p>针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。但是链表不支持随机访问，无法像数组那样通过首地址和下标，通过寻址公式直接计算内存地址，链表要想随机访问第k个元素只能进行遍历</p>
<p>algorithm_linkedlist_insert_delete.png</p>
<p><strong>循环链表是一种特殊的单链表</strong> ，它跟单链表唯一的区别就在尾结点，循环链表的尾结点指针是指向链表的头结点</p>
<p>algorithm_linkedlist_cycle.png</p>
<p>和单链表相比，<strong>循环链表</strong>的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/约瑟夫斯问题" target="_blank" rel="noopener">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<p><strong>双向链表</strong>，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p>algorithm_linkedlist_double.png</p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间</p>
<p>双向链表的典型应用：Java中的LinkedHashMap，双向链表采用空间换时间的设计思想，缓存也是采用了该设计思想。</p>
<p>双向循环链表就是双向链表和循环链表的结合</p>
<p>algorithm_linkedlist_double_cycle.png</p>
<h4 id="链表数组性能对比"><a href="#链表数组性能对比" class="headerlink" title="链表数组性能对比"></a>链表数组性能对比</h4><p>插入、删除、随机访问操作的时间复杂度对比如下图：</p>
<p>algorithm_linkedlist_performance.png</p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<p>数组动态扩容时，需要进行大量的复制操作，比较耗时；链表天然支持动态扩容。</p>
<p>如果对内存的要求比较严格，则数组更适合，因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍</p>
<h4 id="LRU（Least-Recently-Used）缓存淘汰策略链表简单实现"><a href="#LRU（Least-Recently-Used）缓存淘汰策略链表简单实现" class="headerlink" title="LRU（Least Recently Used）缓存淘汰策略链表简单实现"></a>LRU（Least Recently Used）缓存淘汰策略链表简单实现</h4><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部</li>
</ol>
</li>
</ol>
<p>这种方式缓存访问的时间复杂度为O(n)，因为需要遍历链表，可以采用散列表（Hash Table）保存结点的位置，使时间复杂度降为O(1).</p>
<h4 id="单链表存储的回文字符串判断"><a href="#单链表存储的回文字符串判断" class="headerlink" title="单链表存储的回文字符串判断"></a>单链表存储的回文字符串判断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.快慢指针定位中间结点</span></span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.逆序后半部分结点</span></span><br><span class="line">        slow = reverse(slow.next);</span><br><span class="line">        <span class="comment">//3.对称比较值是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != slow.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归反转</span></span><br><span class="line">        ListNode p = reverse(head.next);</span><br><span class="line">        <span class="comment">//让下一个结点的后继指针指向自己，实现反转</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<h4 id="写出优雅链表代码的技巧"><a href="#写出优雅链表代码的技巧" class="headerlink" title="写出优雅链表代码的技巧"></a>写出优雅链表代码的技巧</h4><h5 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h5><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; next = q;<span class="comment">//p结点中的next指针存储了q结点的内存地址</span></span><br><span class="line">p -&gt; next = p-&gt;next-&gt;next;<span class="comment">//p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址</span></span><br></pre></td></tr></table></figure>

<h5 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h5><ol>
<li><strong>插入结点时，一定要注意操作的顺序</strong></li>
<li><strong>删除链表结点时，也一定要记得手动释放内存空间</strong></li>
</ol>
<h5 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h5><p>哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，比如针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</p>
<p>Algorithm_linkedlist_sentinel.png</p>
<p><strong>带头链表</strong>就是带有哨兵节点的链表，<strong>不带头链表</strong>就是不带哨兵节点的链表</p>
<h5 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h5><h5 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h5><h5 id="多写多练，没有捷径"><a href="#多写多练，没有捷径" class="headerlink" title="多写多练，没有捷径"></a>多写多练，没有捷径</h5><h4 id="常见的链表操作"><a href="#常见的链表操作" class="headerlink" title="常见的链表操作"></a>常见的链表操作</h4><p>206，141，21，19，876</p>
<ul>
<li>单链表反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案一 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归反转</span></span><br><span class="line">  Node p = reverse(head.next);</span><br><span class="line">  head.next.next = head;</span><br><span class="line">  head.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案二 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseNormal</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">  Node cur = head;</span><br><span class="line">  Node prev = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">    Node temp = cur.next;</span><br><span class="line">    cur.next = prev;</span><br><span class="line">    prev = cur;</span><br><span class="line">    cur = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表中环的检测</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案一 哈希表</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n),空间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solutionOne</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  Set&lt;ListNode&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeSet.contains(head))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      nodeSet.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案二 快慢指针</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n),空间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solutionTwo</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  ListNode slow = head,fast = head;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;<span class="keyword">while</span> (slow != fast);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个有序的链表合并</li>
</ul>
<ul>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈也是一种特殊的线性表，其特性为先进后出、后进先出 ，<strong>后进先出</strong>是栈最大的特点。很多应用场景都是基于栈的后进先出特性。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</strong>。</p>
<p>用数组实现的栈，叫作<strong>顺序栈</strong>，用链表实现的栈，叫作<strong>链式栈</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈实现</span></span><br></pre></td></tr></table></figure>

<p>不管是顺序栈还是链式栈，入栈和出站的时间和空间复杂度都为O(1)</p>
<h4 id="动态扩容的顺序栈"><a href="#动态扩容的顺序栈" class="headerlink" title="动态扩容的顺序栈"></a>动态扩容的顺序栈</h4><p>底层采用支持动态扩容的数组实现即可</p>
<p>Algorithm_stack_dynamic.png</p>
<p>时间复杂度分析：出栈时间复杂度O(1)。入栈时间复杂度需要分情况，当入栈时恰好有空间，时间复杂度也为O(1)；当入栈时空间已满则需要重新申请内存并进行数据复制，这时时间复杂度为O(n)。</p>
<p>也就是说，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。平均情况下的时间复杂度可以采用摊还分析法来分析</p>
<p>algorithm_stack_dynamic_time.png</p>
<p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。入栈操作的均摊时间复杂度就为 O(1)。正好印证了<strong>均摊时间复杂度一般都等于最好情况时间复杂度</strong>。</p>
<p>大体思路就是：在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p>
<h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><h5 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h5><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(<span class="string">"%d"</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>algorithm_stack_function_call.png</p>
<h5 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h5><p>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p>algorithm_stack_operation.png</p>
<h5 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h5><h5 id="浏览器的页面前进-后退功能"><a href="#浏览器的页面前进-后退功能" class="headerlink" title="浏览器的页面前进/后退功能"></a>浏览器的页面前进/后退功能</h5><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列也是一种特殊的线性表数据结构，其特点是先进先出。</p>
<p>algorithm_queue_definition.png</p>
<p>两个基本操作：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。</p>
<p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用数组实现的队列</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用链表实现的队列</span></span><br></pre></td></tr></table></figure>

<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>algorithm_queue_cyclic.png</p>
<p>循环队列避免非循环队列中的数据移动操作，也就是入队时直接将元素放入下标为tail的位置，然后tail在环中向后移动一位。</p>
<p>循环队列的队空判定条件：head==tail，队满判定条件：(tail + 1)%n == head。</p>
<p>另外当队列满时，tail所指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。效果图：</p>
<p>algorithm_queue_cyclic_full.png</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h4><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。</p>
<p>algorithm_queue_blocked.png</p>
<p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。</p>
<p>algorithm_queue_multi_consumer.png</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>常用的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序</p>
<p>algorithm_sort_category.png</p>
<h3 id="排序算法的衡量指标"><a href="#排序算法的衡量指标" class="headerlink" title="排序算法的衡量指标"></a>排序算法的衡量指标</h3><h4 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h4><p>执行效率的衡量指标同样有以下几种：</p>
<ol>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数、低阶</li>
<li>比较次数和交换（或移动）次数</li>
</ol>
<h4 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h4><p>内存消耗可以通过空间复杂度衡量。<strong>原地排序</strong>（Sorted in place）：就是特指空间复杂度是 O(1) 的排序算法。也就是说不需要额外的辅助空间。</p>
<h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p><strong>稳定性</strong> ： 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>algorithm_sort_stability.png</p>
<p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p>
<h3 id="基于比较的排序算法"><a href="#基于比较的排序算法" class="headerlink" title="基于比较的排序算法"></a>基于比较的排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>algorithm_sort_bubble.png</p>
<p>冒泡排序优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</p>
<p>algorithm_sort_bubble_optimize.png</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;=<span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="comment">//提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(a[j+<span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Comparable tmp = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;<span class="comment">//表示有数据交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;<span class="comment">//没有数据交换，表示数组已经有序，直接退出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析"><a href="#衡量指标分析" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>冒泡排序是原地排序</li>
</ol>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<ol start="2">
<li>冒泡排序是稳定的排序算法</li>
</ol>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<ol start="3">
<li>冒泡排序的时间复杂度</li>
</ol>
<p>最好情况时间复杂度为O(n)，也就是在完全有序的情况下，只需要执行1次冒泡过程，即比较n-1次</p>
<p>最坏情况时间复杂度为O($n ^ 2$)，就是在完全逆序的情况下，需要执行n次冒泡过程</p>
<p>平均情况时间复杂度为O($n^2$)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先，找到元素中最小的元素并与第一个元素交换位置，在从剩余的元素中找到最小的元素并与第二个元素交换位置，以此类推，直到整个数组有序。</p>
<p>algorithm_sort_select.png</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="comment">//min用来标记最小元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SortUtil.less(a[j], a[min])) min = j;</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtil.exch(a,i,min);</span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-1"><a href="#衡量指标分析-1" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>选择排序是原地排序</li>
<li>选择排序是不稳定的排序算法</li>
</ol>
<p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<ol start="3">
<li>选择排序的时间复杂度</li>
</ol>
<p>选择排序的最好、最坏、平均情况时间复杂度都为O($N^2$ )</p>
<p>​    比较次数：第n个元素需要比较的次数为(N-n)，总的比较次数为(N-1) + (N-2) + (N-3) + … + 3 + 2 + 1 = N(N-1)/2</p>
<p>​    交换次数：N次</p>
<p>特点：</p>
<ul>
<li>运行时间与元素的初始顺序无关</li>
<li>数据移动最少</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h5><ol>
<li>每插入一个元素，就从该元素开始与左侧的元素进行比较，如果小于则交换位置，然后在与交换后的位置前面的元素进行比较，如果小于则交换位置，以此类推。</li>
<li>然后在插入一个元素，重复步骤1，直到插入最后一个元素。</li>
</ol>
<p>要点就是每插入一个元素之前，其左侧元素已然有序，插入该元素后进行比较和交换，保证当前索引左侧所有元素有序</p>
<p>algorithm_sort_insert.png</p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(a[j - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable tmp = a[j];</span><br><span class="line">        a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换时只需一个赋值操作的实现</span></span><br><span class="line"><span class="comment">     * 该算法比同样时间复杂度的冒泡排序算法要快</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertTwo</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    Comparable value = a[i];<span class="comment">//要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];<span class="comment">//将比插入元素大的元素后移</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入新元素，注意循环时j--多执行了一次，所以需要j+1</span></span><br><span class="line">    a[j+<span class="number">1</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-2"><a href="#衡量指标分析-2" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>插入排序是原地排序</li>
</ol>
<p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。</p>
<ol start="2">
<li>插入排序是稳定的排序算法</li>
</ol>
<p>插入排序算法对于新插入的元素与已排序好的元素进行比较，元素相等时是不进行交换的，所以可以保持相等元素的原有相对顺序，所以插入排序是稳定的排序算法。</p>
<ol start="3">
<li>插入排序的时间复杂度</li>
</ol>
<p>最好情况时间复杂度：O(n)</p>
<p>​        输入元素的顺序正好是正向的（与你所期望的顺序一样），只需要比较不需要交换</p>
<p>​        比较次数：N-1 次</p>
<p>最坏情况时间复杂度：O($n ^ 2$)</p>
<p>​        输入元素的顺序正好是反向的，每次插入都相当于在数组的第一个位置插入新的数据</p>
<p>​        比较次数：1 + 2 + 3 + … + (N-3) + (N-2) + (N-1) = N(N-1)/2</p>
<p>​        交换次数：1 + 2 + 3 + … + (N-3) + (N-2) + (N-1) = N(N-1)/2</p>
<p>平均情况时间复杂度：O($n ^ 2$)</p>
<p>​        可以理想化为最坏情况下有一半元素是正向的</p>
<p>​        比较次数：1/2 + 2/2 + …. + (N-2)/2 + (N-1)/2 = N(N-1)/4</p>
<p>​        交换次数：1/2 + 2/2 + …. + (N-2)/2 + (N-1)/2 = N(N-1)/4 </p>
<p>​        还可以理解为在数组中插入一个元素的平均时间复杂度，并执行n次的效果，数组中插入一个元素的平均时间复杂度为O(n)，循环执行n次插入复杂度为O($n ^ 2$)</p>
<p>特点：</p>
<ul>
<li>插入排序对部分有序的数组十分高效</li>
<li>适合小规模数组</li>
</ul>
<p><strong>部分有序</strong>的数组特征：</p>
<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h5><p>实际上就是使用不同增量的插入排序。插入排序是相邻元素之间的交换，而希尔排序是间隔为h的元素之间交换。其中h是按照某种序列递减，比如从N/3开始递减至1，这种序列被称为<strong>递增序列</strong></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//1,4,13,40,121,364,...</span></span><br><span class="line">  <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&gt;=h &amp;&amp; SortUtil.less(a[j],a[j-h]);j-=h)&#123;</span><br><span class="line">        SortUtil.exch(a,j,j-h);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h = h/<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-3"><a href="#衡量指标分析-3" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><p>时间复杂度：O($N^{5/4}$)</p>
<p>​    不到平方级别，具体执行时间依赖于递增序列，通常应用中采用上面代码中的序列[$1/2(3^k - 1)$]就足够了。</p>
<p>特点：</p>
<ul>
<li>数组越大，优势越大</li>
</ul>
<p>高效原因：</p>
<p>​    权衡了子数组的规模和有序性，排序之前，子数组都很短，排序之后子数组都是部分有序的，这两种情况正好适合插入排序。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h5><p>算法设计中分治思想的典型实现。先将数组拆分成两半分别排序，然后在将结果归并起来，使得数组整体有序，再递归的对两半数组分别拆分排序归并。正是分治思想将大的任务拆解成小的任务，再把小任务分别解决从而解决大任务的体现。</p>
<p>algorithm_sort_merge.png</p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo,hi]排序</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);<span class="comment">//左半边排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);<span class="comment">//右半边排序</span></span><br><span class="line">        merge(a, lo, mid, hi);<span class="comment">//归并排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组拷贝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;       <span class="comment">//左半边用尽，直接取右半边元素</span></span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;  <span class="comment">//右半边用尽，直接取左半边元素</span></span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SortUtil.less(aux[j], aux[i])) &#123;<span class="comment">//右半边的元素小于左半边的元素，取右半边元素</span></span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右半边元素大于等于左半边元素，取左半边元素</span></span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"M"</span>, <span class="string">"E"</span>, <span class="string">"R"</span>, <span class="string">"G"</span>, <span class="string">"E"</span>, <span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-4"><a href="#衡量指标分析-4" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>归并排序不是原地排序算法</li>
</ol>
<p>在合并的时候使用了辅助空间，所以该算法的空间复杂度为O(n)</p>
<ol start="2">
<li>归并排序是稳定的排序算法</li>
</ol>
<p>归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码，当两个元素相等时，取左半部分元素，这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p>
<ol start="3">
<li>归并排序的时间复杂度</li>
</ol>
<p>最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_merge_sort_time.png" alt="归并排序时间复杂度计算"></p>
<p>上图中每层需要比较的次数为N，所以需要比较的总次数为NlgN</p>
<p><strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p>
<p>假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C;n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) &#x3D; 2 * T(n&#x2F;2) + n;</span><br></pre></td></tr></table></figure>

<p>计算公式推到过程：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n</span><br><span class="line">     = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>) + n/<span class="number">2</span>) + n = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n</span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n</span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n</span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>

<p>得到T(n) = $2^k$  * T(n/$2^k$) + k * n ，当T(n/$2^k$) = T(1)时终止，即 n/$2^k$ = 1,k = $\log_2{n}$  , T(n) = Cn + n*$\log_2n$ ,采用大O标记法表示 T(n) = O(nlogn)，所以归并排序的时间复杂度为O(nlogn).</p>
<p>从实现思路及代码分析可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<p>特点：</p>
<ul>
<li>辅助数组需要占用额外的空间，并且大小与N成正比</li>
<li>可以处理大规模数组</li>
</ul>
<p>优化：</p>
<ul>
<li><p>对小规模子数组使用插入排序</p>
<p>因为递归会使小规模问题中方法的调用过于频繁，所以使用插入排序处理小规模子数组（比如长度小于15），一般可以将归并排序的时间缩短10% ~ 15%</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>归并的时候可以通过判断a[mid] &lt;= a[mid+1] 来避免merge过程</p>
</li>
<li><p>不将元素复制到辅助数组</p>
</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h5><p>也是基于分治思想。归并排序是将数组分成两个子数组分别排序，并将有序的子数组归并使整个数组有序。而快速排序是在拆分子数组的时候就确保了左子数组中的最大元素小于右子数组中的最小元素，通过partition切分，然后在进行递归调用。归并排序数组等分为两半；快速排序切分(partition)的位置取决于数组的内容</p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo,i-1],a[i],a[i+1,hi]</span></span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//停留在不小于v的元素下标上</span></span><br><span class="line">            <span class="keyword">while</span> (SortUtil.less(a[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//停留在不大于v的元素下标上</span></span><br><span class="line">            <span class="keyword">while</span> (SortUtil.less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//左右扫描指针相交时退出</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            SortUtil.exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将切分元素放入正确的位置</span></span><br><span class="line">        SortUtil.exch(a,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"Q"</span>, <span class="string">"U"</span>, <span class="string">"I"</span>, <span class="string">"C"</span>, <span class="string">"K"</span>, <span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//混排：将数组随机排序就是为了避免切分不平衡，比如每次选的切分元素恰好是最小或者最大的元素，则会导致一个子数组为空，每次排序只能排好一个元素，类似于选择排序</span></span><br><span class="line">        Collections.shuffle(Arrays.asList(arr));</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-5"><a href="#衡量指标分析-5" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>快速排序是原地排序算法</li>
<li>快速排序不是稳定的排序算法</li>
<li>快速排序的时间复杂度</li>
</ol>
<p>快速排序的执行时间取决于切分元素（pivot 又叫分区点）的选择，如果每次分区恰好二分，那么时间复杂度递推公式与归并排序是相同的，时间复杂度就是O(nlogn)。如果每次分区后，一侧为空，一侧为满，则需要进行n次分区，每次分区只能排序一个元素，这时就有点类似选择排序，时间复杂度降为O($n^2$)。分别对应着快速排序的最好情况时间复杂度O(nlogn)和最坏情况时间复杂度 O($n^2$)。平均情况时间复杂度可以采用<strong>递归树</strong>进行分析，平均情况时间复杂度为O(nlogn)。</p>
<p>特点：</p>
<ul>
<li>原地排序（只需要很小的辅助栈）</li>
<li>切分不平衡时可能极为低效</li>
</ul>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ol>
<li><p>切换到插入排序</p>
<p>对于小数组，快速排序比插入排序要慢，因为在小数组中，sort()方法还是会递归的调用自己。(个人理解：从元素重复度分析排序效率：1. 重复元素很少：当数组拆分的足够小且重复元素较少，这时大概率数组中元素已经部分有序，这时的递归调用效率要比插入排序低。2.重复元素较多：与产生三向切分的原因一样，在大量重复元素的情况下，再次递归经常会产生数组元素完全重复的子数组，而这样的子数组就不需要排序了)</p>
<p>切换到插入排序的做法只需将sort()方法中的语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换参数M的最佳值与系统先关，通常情况下采用5 ~ 15 之间的任意值</span></span><br><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M) &#123;</span><br><span class="line">  Insertion.sort(a,lo,hi);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三取样切分</p>
<p>使用子数组的一小部分元素的中位数来切分数组，代价是需要计算中位数。</p>
</li>
<li><p>三向切分快速排序</p>
<p>排序库函数的最佳算法选择。</p>
<p>实现思路：从左到右遍历数组，维护三个指针：一个指针lt使得a[lo,lt-1]的元素都小于v，一个指针gt使得a[gt+1,hi]的元素都大于v，一个指针i使得a[lt,i-1]的元素都等于v，a[i,gt]的元素待排序。具体处理步骤如下：</p>
<ol>
<li>a[i] 小于 v，交换a[i]和a[lt]，i 和 lt 加一</li>
<li>a[i] 大于 v，交换a[i]和a[gt]，gt 减一</li>
<li>a[i] 等于 v，i 加一</li>
</ol>
<p>示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way.png" alt="三向切分示意图"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3way</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                SortUtil.exch(a, i++, lt++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                SortUtil.exch(a, i, gt--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"R"</span>, <span class="string">"B"</span>, <span class="string">"W"</span>, <span class="string">"W"</span>, <span class="string">"R"</span>, <span class="string">"W"</span>, <span class="string">"B"</span>, <span class="string">"R"</span>, <span class="string">"R"</span>, <span class="string">"W"</span>, <span class="string">"B"</span>, <span class="string">"R"</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h5><ol>
<li>O(n)时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</li>
</ol>
<p>其实就是利用快速排序分区的思想，选取数组区间A[0…n-1]的第一个元素A[0]作为pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找。</p>
<p>algorithm_sort_pivot_topk.png</p>
<p>时间复杂度计算：就是每次分区后遍历元素之和，即n + n/2 + n/4 + … + 1 = 2n-1,所以时间复杂度为O(n)</p>
<h3 id="非基于比较的排序算法-线性排序"><a href="#非基于比较的排序算法-线性排序" class="headerlink" title="非基于比较的排序算法-线性排序"></a>非基于比较的排序算法-线性排序</h3><p>三种非基于比较的排序算法：桶排序、计数排序、基数排序，这些排序算法的时间复杂度都为O(n)，因为这些算法的时间复杂度都是线性的，所以也将这类排序算法称为<strong>线性排序(Linear Sort)</strong></p>
<h4 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序(Bucket Sort)"></a>桶排序(Bucket Sort)</h4><h5 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h5><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p>algorithm_sort_bucket.png</p>
<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<h4 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h4><h5 id="实现思路-7"><a href="#实现思路-7" class="headerlink" title="实现思路"></a>实现思路</h5><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>举个例子：假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8] 中，它们分别是：2，5，3，0，2，3，0，3。</p>
<p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6] 的值。</p>
<p>algorithm_sort_count_1.png</p>
<p>然后对 C[6] 数组顺序求和，C[6] 存储的数据就变成了下面这样子。C[k] 里存储小于等于分数 k 的考生个数。</p>
<p>algorithm_sort_count_2.png</p>
<p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。以此类推。</p>
<p>algorithm_sort_count_3.png</p>
<p><strong>注意：扫描数组A的时候必须从末尾开始，这样才能保证计数排序是稳定排序算法</strong></p>
<h5 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<h4 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h4><p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</strong>。</p>
<h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>algorithm_skiplist.png</p>
<p>这种链表加多级索引的结构就是跳表</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，*<em>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/ $2 ^ k$ *</em>。</p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/ $2^h$ =2，从而求得 h = $log_2 n$ - 1。如果包含原始链表这一层，整个跳表的高度就是 $log_2 n$  。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>
<p>m的取值取决于构建每层索引时间隔的结点数，假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>
<p>algorithm_skiplist_time.png</p>
<p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。跳表之所以查询效率这么高，是因为我们花费了空间为其建立很多级索引，典型的空间换时间的设计思想。</p>
<p>跳表插入、删除操作的时间复杂度也是O(logn)</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>跳表的空间复杂度分析并不难，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<p>algorithm_skiplist_space.png</p>
<p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。</p>
<p>如果构建索引时采用每3个结点抽一个到上级索引，那么索引的结点总和就是n/3 + n/9 + n/27 + …. + 9 + 3 + 1 =  n/2 尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p>
<h4 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h4><p>跳表是通过随机函数来维护索引与原始链表大小之间的平衡。也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p>algorithm_skiplist_dynamic.png</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>   优先队列是一种抽象数据类型，类似于队列和栈。不同的是，优先队列中的每个元素都有优先级，优先级高的元素先于优先级低的元素出队，如果两个元素的优先级相等则看其具体实现采取的措施。跟排序有关但是又不需要所有元素完全排序。</p>
<h4 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a>初级实现</h4><ul>
<li><p>数组实现（无序）：删除操作类似于选择排序</p>
</li>
<li><p>数组实现（有序）：插入操作类似于插入排序</p>
</li>
<li><p>链表表示法：分无序和有序，类似于数组的无序和有序实现</p>
<p>各种实现的时间复杂度如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入元素</th>
<th>删除最大元素</th>
</tr>
</thead>
<tbody><tr>
<td>有序数组</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>有序数组</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>堆（高级实现）</td>
<td>logN</td>
<td>logN</td>
</tr>
</tbody></table>
<p>   通常情况下，优先队列采用二叉堆表示，采用数组存储，第0个位置不存储，存储于第1到N个位置上。即pq[0]不使用，使用pq[1….N]存储元素</p>
<h4 id="堆实现"><a href="#堆实现" class="headerlink" title="堆实现"></a>堆实现</h4><p>   <strong>堆有序</strong>：当一棵二叉树的每个结点都大于等于它的两个子结点时，称为堆有序。</p>
<p>   从堆有序可知，根结点是堆有序的二叉树中最大的结点。</p>
<p>   <strong>二叉堆</strong>：实际上就是一棵堆有序的完全二叉树，结点按照层级存储在数组中（不使用数组的第一个位置）。根结点储存在位置1上，子结点存储在位置2和3上，子结点的子结点存储在4、5、6、7上，以此类推。</p>
<p>   <strong>二叉堆的特点</strong>：</p>
<ul>
<li>位置k的结点的父结点的位置为k/2的向下取整，它的子结点的位置分别为2k和2k+1</li>
<li>元素个数为N的二叉堆的高度lgN的向下取整</li>
</ul>
<p><strong>由下至上的堆有序化——上浮</strong>：当新增元素至数组末尾时，有可能因为当前元素大于其父结点而破坏堆的有序状态，所以就需要交换该结点和父结点，交换之后可能比当前父结点还要大，继续向上移动，直到碰到一个比它大的父结点为止。这个过程就是<strong>上浮</strong></p>
<p><strong>由上至下的堆有序化</strong>——下沉：当从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，有可能因为其比两个子结点或者其中一个子结点小而破坏堆的有序状态，所以需要将其和两个子结点中的较大者进行交换，交换之后可能比当前的子结点还要小，继续向下移动，直到不在小于它的子结点或者到达堆的底部。这个过程就是<strong>下沉</strong></p>
<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueSimple</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueueSimple</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Key t = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 位置为k的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">            exch(k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 位置为k的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//取两个子结点中较大者</span></span><br><span class="line">            <span class="keyword">if</span> (j&lt;N &amp;&amp; less(j,j+<span class="number">1</span>)) j++;</span><br><span class="line">            <span class="comment">//当父结点不在小于子结点时，停止下沉</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,j)) <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span>&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];<span class="comment">//取出最大元素</span></span><br><span class="line"><span class="comment">//        pq[1] = pq[N--];//与最后一个结点交换</span></span><br><span class="line">        exch(<span class="number">1</span>,N--);</span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;<span class="comment">//防止对象游离</span></span><br><span class="line">        sink(<span class="number">1</span>);<span class="comment">//下沉</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"A"</span>,<span class="string">"O"</span>,<span class="string">"R"</span>,<span class="string">"T"</span>,<span class="string">"H"</span>,<span class="string">"N"</span>,<span class="string">"G"</span>,<span class="string">"S"</span>,<span class="string">"E"</span>,<span class="string">"I"</span>,<span class="string">"P"</span>&#125;;</span><br><span class="line">        PriorityQueueSimple&lt;String&gt; simple = <span class="keyword">new</span> PriorityQueueSimple&lt;&gt;(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">for</span> (String a:arr)&#123;</span><br><span class="line">            simple.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!simple.isEmpty())&#123;</span><br><span class="line">            System.out.print(simple.delMax() + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<p>​    元素个数为N的基于堆的优先队列，插入元素需要不超过lgN次比较，删除元素需要不超过2lgN次比较。</p>
<p>​    插入元素因为从根结点到堆底元素比较次数不会超过二叉树的深度（lgN），删除元素每一层需要两次比较（父结点与子结点、子结点与兄弟结点），总共lgN层，所以为2lgN次比较</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序分为两个阶段：1、构造堆；2、下沉排序</p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//构造堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            sink(a, k, N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下沉排序</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            SortUtil.exch(a, <span class="number">1</span>, N--);</span><br><span class="line">            sink(a, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：(2NlgN + 2N)次比较（以及一半次数的交换）</p>
<ol>
<li><p>构造堆</p>
<p>用下沉构造N个元素的堆，所需要的比较次数少于2N次，交换次数少于N次</p>
<p>比如构造一个127个元素的堆，我们需要处理1个大小为127的堆，2个大小为63的堆，4个大小为31的堆，8个大小为15的堆，16个大小为7的堆和32个大小为3的堆，因此最会情况下需要32 × 1 + 16 × 2 + 8 × 3 + 4 × 4 + 2 × 5 + 1 × 6 = 120次交换（以及两倍的比较）</p>
</li>
<li><p>下沉排序</p>
<p>下沉操作每下一层需要2次比较，最坏情况下沉lgN层，即每下沉一个元素最多需要2lgN次比较，总共N个元素，最多需要N*2lgN次比较（交换次数减半）</p>
</li>
</ol>
<p>优缺点：</p>
<p>优点：能够同时最优的利用时间和空间，时间复杂度线性对数级。当空间十分紧张的情况下，非常适用，几行简单的代码就能提供较好的性能</p>
<p>缺点：现代系统许多应用很少适用堆排序，因为它无法利用缓存。数组元素很少和相邻的元素进行比较，而是对半比较，因此缓存命中的次数较和相邻元素进行比较的算法（比如快速排序、归并排序）要低的多</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>TopM</strong>：N个元素中找出前M个最大的（或者最小的）元素</p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>时间</th>
<th>空间</th>
</tr>
</thead>
<tbody><tr>
<td>排序算法</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td>初级实现的优先队列</td>
<td>NM</td>
<td>M</td>
</tr>
<tr>
<td>基于堆实现的优先队列</td>
<td>NlogM</td>
<td>M</td>
</tr>
</tbody></table>
<p>基于堆实现的优先队列代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopM</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//设置优先队列的大小为M+1</span></span><br><span class="line">        MinPQ&lt;Transaction&gt; pq = <span class="keyword">new</span> MinPQ&lt;Transaction&gt;(M+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(StdIn.hasNextLine())&#123;</span><br><span class="line">            <span class="comment">//插入元素并调整优先队列</span></span><br><span class="line">            pq.insert(<span class="keyword">new</span> Transaction(StdIn.readLine()));</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; M)&#123;</span><br><span class="line">                <span class="comment">//如果队列中元素个数大于M个（也就是M+1个），则删除队列中最小的元素（即第一个元素pq[1]）</span></span><br><span class="line">                pq.delMin();</span><br><span class="line">            &#125;<span class="comment">//最大的M个元素正好都在优先对列中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中位数</strong>：更为通用的问题是找到一组数中第k小的元素（当k为中间值时，即不大于一半的元素又不小于另一半元素，为中位数），TopM的解决方案对于中位数（M=N/2）也同样适用，但效率都不高，下面的解决方案是线性级别的。</p>
<p>实现思路：利用快速排序的切分法，返回的整数j使得a[lo..j-1]小于等于a[j]且a[j+1..hi]大于等于a[j]。当j=k=N/2时，两边元素的个数相等，a[j]=a[k]即为中位数。如果j != k说明两边元素个数不相等，继续切分子数组直到j落到中间位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k即为N/2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">select</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//混排，随机打散数组元素</span></span><br><span class="line">    StdRandom.shuffle(a);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>,hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//切分位置刚好处于中间</span></span><br><span class="line">        <span class="keyword">if</span>(j == k) <span class="keyword">return</span> a[k];</span><br><span class="line">        <span class="comment">//切分位置在中间右侧，再切分左子数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( j &gt; k) hi = j - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分位置在中间左侧，再切分右子数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) lo = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：比较的总次数为 N + N/2 + N/4 + N/8 + …  &lt; 2N，所以是线性级别的</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p><strong>定义</strong>：一种存储键值对的数据结构，支持插入和查找操作。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>不允许重复的键：每个键对应一个值，插入已存在的键时更新其值</li>
<li>不允许空键和空值：插入空键会产生运行时异常；空值可以用来判断键不存在，查找某个键如果返回空则表示该键不存在；插入空值可以对该键进行延时删除</li>
<li>延时删除和即时删除：延时删除是将键对应的值置为空，然后在将来的某个时候删除所有值为空的键；即时删除表示立刻从表中删除指定的键。当插入空值操作put(key,null)时即时删除<code>if(value == null) {delete(key); return;}</code>所以表中不存在空值的键</li>
</ul>
<h4 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h4><p><strong>特征</strong>：</p>
<ul>
<li>最大键和最小键</li>
<li>向下取整和向上取整</li>
<li>排名和选择：排名（rank），找出小于指定键的键的数量；选择（select），找出排名为k的键；对于0到size() - 1的所有i都满足 i == rank(select(i))，且所有的键都满足 key == select(rank(key))。</li>
<li>范围查找</li>
</ul>
<h4 id="无序链表中的顺序查找"><a href="#无序链表中的顺序查找" class="headerlink" title="无序链表中的顺序查找"></a>无序链表中的顺序查找</h4><p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       Key key;</span><br><span class="line">       Value value;</span><br><span class="line">       Node next;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> Node first;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node x = first;x != <span class="keyword">null</span>;x = x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key))&#123;</span><br><span class="line">                <span class="keyword">return</span> x.value;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node x = first;x != <span class="keyword">null</span>;x = x.next)&#123;</span><br><span class="line">           <span class="keyword">if</span> (key.equals(x.key))&#123;</span><br><span class="line">               x.value = value;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//未命中 新建头结点</span></span><br><span class="line">       first = <span class="keyword">new</span> Node(key,value,first);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>含有N对键值对的基于无序链表的符号表中，未命中的查找和插入操作都需要N次比较，命中的查找在最坏情况下也需要N次比较。向一个空表中插入N个不同的键需要$N^{2}/2$次比较</p>
<h4 id="有序数组中的二分查找"><a href="#有序数组中的二分查找" class="headerlink" title="有序数组中的二分查找"></a>有序数组中的二分查找</h4><p>该实现的核心是rank()方法，当key存在时，返回的整数i表示表中小于key的键的数量，并且keys[i] == key成立。当key不存在时，返回的整数i表示该key应该插入的位置（同时也表示表中小于key的键的数量）。另外采用一组平行的数组分别用来存储键和值。</p>
<p>二分查找的轨迹如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarysearch_trace.png" alt="有序数组二分查找轨迹"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> values[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="comment">//Key存在更新value</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Key不存在，则将排名之后的元素后移，插入新元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j--) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            values[j] = values[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归的二分查找</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果表中存在该键，rank()返回该键的位置，同时也表示表中小于该键的键的数量</span></span><br><span class="line"><span class="comment">     * 如果表中不存在该键，rank()还是返回表中小于该键的键的数量，同时也表示在何处插入新键</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hi</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> lo;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, lo, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">return</span> key.compareTo(keys[i]) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">return</span> keys[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rank(lo); i &lt; rank(hi); i++) &#123;</span><br><span class="line">            list.add(keys[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains(hi)) &#123;</span><br><span class="line">            list.add(keys[rank(hi)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：二分查找最多需要 lgN + 1次比较。但是构造一个基于有序数组的符号表需要访问数组的次数是数组长度的平方级别。因为有序数组中插入一个元素在最坏情况下需要访问2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问 $N^{2}$次数组</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>二叉树</strong>  定义为一个空链接或者是一个具有两个链接的结点，每个链接都指向一棵独立的子二叉树。</p>
<p><strong>二叉查找树（BST）</strong> 是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中任意结点的键而小于其右子树中任意结点的键。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_binarysearchtree.png" alt="二叉查找树图示"></p>
<p>如果将一棵二叉查找树的所有键投影到一条直线上，保证一个结点的左子树中的键出现在它的左边，右子树中的键出现在它的右边，那么一定可以得到一条有序的键列，这条键列刚好可以存到数组中。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_mapping_line.png" alt="两棵表示同一组键列的二叉查找树"></p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>基于二叉查找树实现的符号表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">private</span> Node left,right;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//以该结点为根的树中的结点总数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            N = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉查找树的查找和插入实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果key存在于以x为根结点的子树中则更新它的值</span></span><br><span class="line">        <span class="comment">//否则将以key和value为键值对的新结点插入到该子树中</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = put(x.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> x.value = value;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当查找一个不存在于树中的结点并结束于一条空链接时，需要做的就是将链接指向一个含有被查找的键的新结点。查找和插入都采用递归实现，可以将递归调用前的代码想象成<strong>沿着树向下走</strong>：它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。递归调用后的代码想象成<strong>沿着数向上爬</strong>：对于get()方法，对应着一系列的返回指令（return），对于put()方法，插入新结点后需要重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中计数器的值。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_put.png" alt="二叉查找树插入"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。最好情况下，树是完全平衡的，每条空链接和根结点的距离都是lgN，也就是树的高度为lgN。最坏情况下，树的高度为N。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_analyze.png" alt="二叉查找树的可能形状"></p>
<p>在由N个随机键构造的二叉查找树中，查找命中，查找未命中和插入操作平均所需的比较次数为2lnN（约为1.39lgN）</p>
<h4 id="有序性相关的操作"><a href="#有序性相关的操作" class="headerlink" title="有序性相关的操作"></a>有序性相关的操作</h4><h5 id="最大键和最小键"><a href="#最大键和最小键" class="headerlink" title="最大键和最小键"></a>最大键和最小键</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="向上取整和向下取整"><a href="#向上取整和向下取整" class="headerlink" title="向上取整和向下取整"></a>向上取整和向下取整</h5><p>如果给定的键小于根结点的键，那么小于等于key的最大键floor(key)一定在左子树中；如果给定的键大于根结点的键，那么只有当右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中，否则根结点就是小于等于key的最大键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node x = floor(root,key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left,key);</span><br><span class="line">        <span class="comment">//右子树中可能存在比key小的最大键，也可能不存在，当不存在时直接返回根结点</span></span><br><span class="line">        Node t = floor(x.right,key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_floor.png" alt="二叉查找树的floor函数"></p>
<h5 id="选择和排名"><a href="#选择和排名" class="headerlink" title="选择和排名"></a>选择和排名</h5><p>选择select：查找排名为k的键（即树中正好有k个小于它的键）。如果左子树中的结点数t大于k，那么递归的在左子树中查找排名为k的键；如果t等于k，就返回根结点的键；如果t小于k，就递归的在右子树中查找排名为（k-t-1）的键。</p>
<p>排名rank：返回给定键的排名。如果给定的键和根结点的键相等，则返回左子树中的结点总数t；如果给定的键小于根结点，则递归的计算左子树中的排名；如果给定的键大于根结点，则返回t+1（根结点）加上右子树中的排名（递归计算）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,k).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回排名为k的结点</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> t = size(x.left);</span><br><span class="line">        <span class="keyword">if</span> (t &gt; k) <span class="keyword">return</span> select(x.left,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) <span class="keyword">return</span> select(x.right,k-t-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回以x为根结点的子树中小于key的键的数量</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> rank(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(x.right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> size(x.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_select.png" alt="二叉查找树select函数"></p>
<h5 id="删除最大键和删除最小键"><a href="#删除最大键和删除最小键" class="headerlink" title="删除最大键和删除最小键"></a>删除最大键和删除最小键</h5><p>deleteMin:不断的深入根结点的左子树中直到遇见一个空链接，然后将指向该结点的链接指向该结点的右子树。deleteMax实现类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">        x.left = deleteMin(x.left);</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>思路是采用该结点的后继结点填补它的位置。后继结点就是其右子树中的最小结点，这样的替换仍然能够保证树的有序性，因为x.key和它的后继结点的键之间不存在其他的键。实现这个过程需要4步：</p>
<ol>
<li>将指向即将被删除的结点的链接保存为t</li>
<li>将x指向它的后继结点min(r.right)</li>
<li>将x的右链接（原本指向一棵所有结点都大于x.key的二叉查找树）指向deleteMin(t.right)，也就是在删除后所有结点仍然大于x.key的子二叉查找树</li>
<li>将x的左链接设置为t.left(其下所有的键都小于被删除的结点和它的后继结点)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_delete.png" alt="二叉查找树delete函数"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left =  delete(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = delete(x.right,key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left;</span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">            Node t = x;</span><br><span class="line">            x = min(t.right);</span><br><span class="line">            x.right = deleteMin(t.right);</span><br><span class="line">            x.left = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h5><p>类似与中序遍历（先遍历左子树，根结点，再遍历右子树）</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_bst_keys.png" alt="二叉查找树keys函数"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Key&gt;(<span class="number">16</span>);</span><br><span class="line">        keys(root, queue, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> cmplo = lo.compareTo(x.key);</span><br><span class="line">        <span class="keyword">int</span> cmphi = hi.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt; <span class="number">0</span>) keys(x.left, queue, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt;= <span class="number">0</span> &amp;&amp; cmphi &gt;= <span class="number">0</span>) queue.add(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmphi &gt; <span class="number">0</span>) keys(x.right, queue, lo, hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比</p>
<h3 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h3><h4 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h4><p>一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两个链接)，那么3-结点就含两个键和三条链接</p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>一棵2-3查找树或为一棵空树，或由以下结点组成：</p>
<ul>
<li>2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点</li>
<li>3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_definition.png" alt="2-3查找树定义"></p>
<p>一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_search.png" alt="2-3树查找过程"></p>
<h5 id="2-结点中插入新键"><a href="#2-结点中插入新键" class="headerlink" title="2-结点中插入新键"></a>2-结点中插入新键</h5><p>需要先进行一次未命中的查找，然后将空链接所对应的2-结点转换为一个包含新键的3-结点</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_2node_insert.png" alt="2-结点插入过程"></p>
<h5 id="只含有一个3-结点的树中插入新键"><a href="#只含有一个3-结点的树中插入新键" class="headerlink" title="只含有一个3-结点的树中插入新键"></a>只含有一个3-结点的树中插入新键</h5><p>需要创建一个临时的4-结点，即含有3个键和4条链接的结点。然后再将其转换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_single3node_insert.png" alt="单个3-结点插入过程"></p>
<h5 id="父结点为2-结点的3-结点插入新键"><a href="#父结点为2-结点的3-结点插入新键" class="headerlink" title="父结点为2-结点的3-结点插入新键"></a>父结点为2-结点的3-结点插入新键</h5><p>将新键插入到3-结点使其成为临时4-结点，在将其分解，中间的键提到父结点，将2-结点的父结点转换为3-结点</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_23node_insert.png" alt="父结点为2-结点的3结点插入过程"></p>
<h5 id="父结点为3-结点的3-结点插入新键"><a href="#父结点为3-结点的3-结点插入新键" class="headerlink" title="父结点为3-结点的3-结点插入新键"></a>父结点为3-结点的3-结点插入新键</h5><p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_33node_insert.png" alt="父结点为3-结点的3结点插入过程"></p>
<h5 id="分解根结点"><a href="#分解根结点" class="headerlink" title="分解根结点"></a>分解根结点</h5><p>如果从插入结点到根结点的路径上全是3-结点时，最终根结点会变成一个临时的4-结点。将其分解成3个2-结点，树高加1。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_splitroot.png" alt="根结点分解"></p>
<h5 id="局部变换"><a href="#局部变换" class="headerlink" title="局部变换"></a>局部变换</h5><p>将一个4-结点分解为一棵2-3树可能有6中情况，如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_split4node.png" alt="4结点分解情况汇总"></p>
<p>每个变换都会将4-结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p>
<h5 id="全局性质"><a href="#全局性质" class="headerlink" title="全局性质"></a>全局性质</h5><p>局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。</p>
<p><strong>在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_23tree_propositionF.png" alt="2-3树高度计算"></p>
<h4 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h4>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/17/blog-Architect-Road-CPU-Online/" rel="prev" title="线上服务CPU过载问题快速定位">
      <i class="fa fa-chevron-left"></i> 线上服务CPU过载问题快速定位
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/21/book-java-Core-Java-Fundamentals-Two/" rel="next" title="Java核心技术 - 基础知识卷2">
      Java核心技术 - 基础知识卷2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构与算法简介"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构与算法简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度分析"><span class="nav-number">1.2.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#大O复杂度表示法"><span class="nav-number">1.2.1.</span> <span class="nav-text">大O复杂度表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度分析"><span class="nav-number">1.2.2.</span> <span class="nav-text">时间复杂度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见时间复杂度实例分析"><span class="nav-number">1.2.3.</span> <span class="nav-text">常见时间复杂度实例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度分析"><span class="nav-number">1.2.4.</span> <span class="nav-text">空间复杂度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最好、最坏情况时间复杂度"><span class="nav-number">1.2.5.</span> <span class="nav-text">最好、最坏情况时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平均情况时间复杂度"><span class="nav-number">1.2.6.</span> <span class="nav-text">平均情况时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#均摊时间复杂度"><span class="nav-number">1.2.7.</span> <span class="nav-text">均摊时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">1.3.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归需要满足的三个条件"><span class="nav-number">1.3.1.</span> <span class="nav-text">递归需要满足的三个条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归要警惕的问题"><span class="nav-number">1.3.2.</span> <span class="nav-text">递归要警惕的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">1.4.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度"><span class="nav-number">1.4.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现"><span class="nav-number">1.4.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适用场景的局限"><span class="nav-number">1.4.3.</span> <span class="nav-text">适用场景的局限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找变形问题"><span class="nav-number">1.4.4.</span> <span class="nav-text">二分查找变形问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查找第一个值等于给定值的元素"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">查找第一个值等于给定值的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找最后一个值等于给定值的元素"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">查找最后一个值等于给定值的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找第一个大于等于给定值的元素"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">查找第一个大于等于给定值的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找最后一个小于等于给定值的元素"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">查找最后一个小于等于给定值的元素</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础数据结构"><span class="nav-number">2.</span> <span class="nav-text">基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">2.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高效的随机访问"><span class="nav-number">2.1.2.</span> <span class="nav-text">高效的随机访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#低效的插入和删除"><span class="nav-number">2.1.3.</span> <span class="nav-text">低效的插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器和数组"><span class="nav-number">2.1.4.</span> <span class="nav-text">容器和数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组要从-0-开始编号，而不是从-1-开始"><span class="nav-number">2.1.5.</span> <span class="nav-text">数组要从 0 开始编号，而不是从 1 开始</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">2.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的链表"><span class="nav-number">2.2.2.</span> <span class="nav-text">常见的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表数组性能对比"><span class="nav-number">2.2.3.</span> <span class="nav-text">链表数组性能对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU（Least-Recently-Used）缓存淘汰策略链表简单实现"><span class="nav-number">2.2.4.</span> <span class="nav-text">LRU（Least Recently Used）缓存淘汰策略链表简单实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单链表存储的回文字符串判断"><span class="nav-number">2.2.5.</span> <span class="nav-text">单链表存储的回文字符串判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写出优雅链表代码的技巧"><span class="nav-number">2.2.6.</span> <span class="nav-text">写出优雅链表代码的技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#理解指针或引用的含义"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">理解指针或引用的含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#警惕指针丢失和内存泄漏"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">警惕指针丢失和内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#利用哨兵简化实现难度"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">利用哨兵简化实现难度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重点留意边界条件处理"><span class="nav-number">2.2.6.4.</span> <span class="nav-text">重点留意边界条件处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#举例画图，辅助思考"><span class="nav-number">2.2.6.5.</span> <span class="nav-text">举例画图，辅助思考</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多写多练，没有捷径"><span class="nav-number">2.2.6.6.</span> <span class="nav-text">多写多练，没有捷径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的链表操作"><span class="nav-number">2.2.7.</span> <span class="nav-text">常见的链表操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">2.3.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态扩容的顺序栈"><span class="nav-number">2.3.1.</span> <span class="nav-text">动态扩容的顺序栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的应用"><span class="nav-number">2.3.2.</span> <span class="nav-text">栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数调用栈"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">函数调用栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#表达式求值"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">表达式求值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#括号匹配"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">括号匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#浏览器的页面前进-后退功能"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">浏览器的页面前进&#x2F;后退功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">2.4.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#循环队列"><span class="nav-number">2.4.1.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞队列和并发队列"><span class="nav-number">2.4.2.</span> <span class="nav-text">阻塞队列和并发队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">3.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的衡量指标"><span class="nav-number">3.1.</span> <span class="nav-text">排序算法的衡量指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法的执行效率"><span class="nav-number">3.1.1.</span> <span class="nav-text">排序算法的执行效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法的内存消耗"><span class="nav-number">3.1.2.</span> <span class="nav-text">排序算法的内存消耗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法的稳定性"><span class="nav-number">3.1.3.</span> <span class="nav-text">排序算法的稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于比较的排序算法"><span class="nav-number">3.2.</span> <span class="nav-text">基于比较的排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序"><span class="nav-number">3.2.1.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-1"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">3.2.2.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-1"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-2"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-1"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">3.2.3.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-2"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-3"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-2"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希尔排序"><span class="nav-number">3.2.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-3"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-4"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-3"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">3.2.5.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-4"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-5"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-4"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">3.2.6.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-5"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-6"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-5"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">衡量指标分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优化"><span class="nav-number">3.2.6.4.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#场景应用"><span class="nav-number">3.2.6.5.</span> <span class="nav-text">场景应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非基于比较的排序算法-线性排序"><span class="nav-number">3.3.</span> <span class="nav-text">非基于比较的排序算法-线性排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#桶排序-Bucket-Sort"><span class="nav-number">3.3.1.</span> <span class="nav-text">桶排序(Bucket Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-6"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">实现思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数排序-Counting-Sort"><span class="nav-number">3.3.2.</span> <span class="nav-text">计数排序(Counting Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-7"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-7"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#适用场景"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基数排序-Radix-Sort"><span class="nav-number">3.3.3.</span> <span class="nav-text">基数排序(Radix Sort)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级数据结构"><span class="nav-number">4.</span> <span class="nav-text">高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跳表"><span class="nav-number">4.1.</span> <span class="nav-text">跳表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度"><span class="nav-number">4.1.2.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳表索引动态更新"><span class="nav-number">4.1.3.</span> <span class="nav-text">跳表索引动态更新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#散列表"><span class="nav-number">4.2.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先队列"><span class="nav-number">4.3.</span> <span class="nav-text">优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初级实现"><span class="nav-number">4.3.1.</span> <span class="nav-text">初级实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆实现"><span class="nav-number">4.3.2.</span> <span class="nav-text">堆实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现-8"><span class="nav-number">4.3.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序"><span class="nav-number">4.3.4.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用"><span class="nav-number">4.3.5.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号表"><span class="nav-number">4.4.</span> <span class="nav-text">符号表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有序符号表"><span class="nav-number">4.4.1.</span> <span class="nav-text">有序符号表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无序链表中的顺序查找"><span class="nav-number">4.4.2.</span> <span class="nav-text">无序链表中的顺序查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有序数组中的二分查找"><span class="nav-number">4.4.3.</span> <span class="nav-text">有序数组中的二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树"><span class="nav-number">4.5.</span> <span class="nav-text">二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-2"><span class="nav-number">4.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本实现"><span class="nav-number">4.5.2.</span> <span class="nav-text">基本实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析"><span class="nav-number">4.5.3.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有序性相关的操作"><span class="nav-number">4.5.4.</span> <span class="nav-text">有序性相关的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#最大键和最小键"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">最大键和最小键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向上取整和向下取整"><span class="nav-number">4.5.4.2.</span> <span class="nav-text">向上取整和向下取整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择和排名"><span class="nav-number">4.5.4.3.</span> <span class="nav-text">选择和排名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除最大键和删除最小键"><span class="nav-number">4.5.4.4.</span> <span class="nav-text">删除最大键和删除最小键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除操作"><span class="nav-number">4.5.4.5.</span> <span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#范围查找"><span class="nav-number">4.5.4.6.</span> <span class="nav-text">范围查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#性能分析"><span class="nav-number">4.5.4.7.</span> <span class="nav-text">性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡查找树"><span class="nav-number">4.6.</span> <span class="nav-text">平衡查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3查找树"><span class="nav-number">4.6.1.</span> <span class="nav-text">2-3查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义-3"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-结点中插入新键"><span class="nav-number">4.6.1.3.</span> <span class="nav-text">2-结点中插入新键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#只含有一个3-结点的树中插入新键"><span class="nav-number">4.6.1.4.</span> <span class="nav-text">只含有一个3-结点的树中插入新键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#父结点为2-结点的3-结点插入新键"><span class="nav-number">4.6.1.5.</span> <span class="nav-text">父结点为2-结点的3-结点插入新键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#父结点为3-结点的3-结点插入新键"><span class="nav-number">4.6.1.6.</span> <span class="nav-text">父结点为3-结点的3-结点插入新键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分解根结点"><span class="nav-number">4.6.1.7.</span> <span class="nav-text">分解根结点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#局部变换"><span class="nav-number">4.6.1.8.</span> <span class="nav-text">局部变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局性质"><span class="nav-number">4.6.1.9.</span> <span class="nav-text">全局性质</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑二叉查找树"><span class="nav-number">4.6.2.</span> <span class="nav-text">红黑二叉查找树</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZGQ"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZGQ</p>
  <div class="site-description" itemprop="description">Java</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengguoqiang927" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengguoqiang927" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengguoqiang927@gmail.com" title="E-Mail → mailto:zhengguoqiang927@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">左耳朵耗子</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;" rel="noopener" target="_blank">廖雪峰</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZGQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://johnson-5.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/";
    this.page.identifier = "2020/04/20/book-algorithm-Algorithm-Fourth-Algorithm/";
    this.page.title = "算法第四版";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://johnson-5.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
