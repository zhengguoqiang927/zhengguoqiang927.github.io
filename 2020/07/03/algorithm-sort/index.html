<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Georgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="排序常用的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序">
<meta property="og:type" content="article">
<meta property="og:title" content="算法 —— 排序">
<meta property="og:url" content="http://yoursite.com/2020/07/03/algorithm-sort/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="排序常用的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_category.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_stability.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bubble.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bubble_optimize.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_select.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_insert.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge_trace.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge_complexity.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_overview.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_trace.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_partition_trace.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way_partition_overview.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way_trace.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_pivot_topk.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bucket.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_radix.png">
<meta property="article:published_time" content="2020-07-03T02:30:40.000Z">
<meta property="article:modified_time" content="2020-07-05T15:29:32.146Z">
<meta property="article:author" content="ZGQ">
<meta property="article:tag" content="算法,排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_category.png">

<link rel="canonical" href="http://yoursite.com/2020/07/03/algorithm-sort/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法 —— 排序 | Z's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/03/algorithm-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ZGQ">
      <meta itemprop="description" content="Java">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法 —— 排序
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-03 10:30:40" itemprop="dateCreated datePublished" datetime="2020-07-03T10:30:40+08:00">2020-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-05 23:29:32" itemprop="dateModified" datetime="2020-07-05T23:29:32+08:00">2020-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/07/03/algorithm-sort/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/07/03/algorithm-sort/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>常用的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、计数排序、基数排序、桶排序</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_category.png" alt="常用排序算法"></p>
<a id="more"></a>

<h3 id="排序算法的衡量指标"><a href="#排序算法的衡量指标" class="headerlink" title="排序算法的衡量指标"></a>排序算法的衡量指标</h3><h4 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h4><p>执行效率的衡量指标同样有以下几种：</p>
<ol>
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
</li>
<li><p>时间复杂度的系数、常数、低阶</p>
<p> 当数据规模比较大时，我们通常只关注高阶项，而忽略低阶、常数、系数项，但通常情况我们排序的规模并不大，这时这些低阶、常数、系数也要考虑进去</p>
</li>
<li><p>比较次数和交换（或移动）次数</p>
</li>
</ol>
<h4 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h4><p>内存消耗可以通过空间复杂度衡量。</p>
<p><strong>原地排序</strong>（Sorted in place）：就是特指空间复杂度是 O(1) 的排序算法。也就是说不需要额外的辅助空间。</p>
<h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p><strong>稳定性</strong> ： 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_stability.png" alt="稳定排序"></p>
<p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p>
<h3 id="基于比较的排序算法"><a href="#基于比较的排序算法" class="headerlink" title="基于比较的排序算法"></a>基于比较的排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bubble.png" alt="冒泡排序"></p>
<p>冒泡排序优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bubble_optimize.png" alt="冒泡排序优化"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;=<span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="comment">//提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(a[j+<span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Comparable tmp = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;<span class="comment">//表示有数据交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;<span class="comment">//没有数据交换，表示数组已经有序，直接退出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析"><a href="#衡量指标分析" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>冒泡排序是原地排序</li>
</ol>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<ol start="2">
<li>冒泡排序是稳定的排序算法</li>
</ol>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<ol start="3">
<li>冒泡排序的时间复杂度</li>
</ol>
<p>最好情况时间复杂度为O(n)，也就是在完全有序的情况下，只需要执行1次冒泡过程，即比较n-1次</p>
<p>最坏情况时间复杂度为O($n^2$)，就是在完全逆序的情况下，需要执行n次冒泡过程</p>
<p>平均情况时间复杂度为O($n^2$)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先，找到元素中最小的元素并与第一个元素交换位置，在从剩余的元素中找到最小的元素并与第二个元素交换位置，以此类推，直到整个数组有序。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_select.png" alt="选择排序"></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="comment">//min用来标记最小元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SortUtil.less(a[j], a[min])) min = j;</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtil.exch(a,i,min);</span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-1"><a href="#衡量指标分析-1" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>选择排序是原地排序</li>
<li>选择排序是不稳定的排序算法</li>
</ol>
<p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<ol start="3">
<li>选择排序的时间复杂度</li>
</ol>
<p>选择排序的最好、最坏、平均情况时间复杂度都为O($N^2$ )</p>
<p>​    比较次数：第n个元素需要比较的次数为(N-n)，总的比较次数为(N-1) + (N-2) + (N-3) + … + 3 + 2 + 1 = N(N-1)/2</p>
<p>​    交换次数：N次</p>
<p>特点：</p>
<ul>
<li>运行时间与元素的初始顺序无关</li>
<li>数据移动最少</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h5><ol>
<li>每插入一个元素，就从该元素开始与左侧的元素进行比较，如果小于则交换位置，然后在与交换后的位置前面的元素进行比较，如果小于则交换位置，以此类推。</li>
<li>然后在插入一个元素，重复步骤1，直到插入最后一个元素。</li>
</ol>
<p>要点就是每插入一个元素之前，其左侧元素已然有序，插入该元素后进行比较和交换，保证当前索引左侧所有元素有序</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_insert.png" alt="插入排序"></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(a[j - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable tmp = a[j];</span><br><span class="line">        a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j - <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换时只需一个赋值操作的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertTwo</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    Comparable value = a[i];<span class="comment">//要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j].compareTo(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];<span class="comment">//将比插入元素大的元素后移</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入新元素，注意循环时j--多执行了一次，所以需要j+1</span></span><br><span class="line">    a[j+<span class="number">1</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-2"><a href="#衡量指标分析-2" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>插入排序是原地排序</li>
</ol>
<p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。</p>
<ol start="2">
<li>插入排序是稳定的排序算法</li>
</ol>
<p>插入排序算法对于新插入的元素与已排序好的元素进行比较，元素相等时是不进行交换的，所以可以保持相等元素的原有相对顺序，所以插入排序是稳定的排序算法。</p>
<ol start="3">
<li>插入排序的时间复杂度</li>
</ol>
<p>最好情况时间复杂度：O(n)</p>
<p>​        输入元素的顺序正好是正向的（与你所期望的顺序一样），只需要比较不需要交换</p>
<p>​        比较次数：N-1 次</p>
<p>最坏情况时间复杂度：O($n ^ 2$)</p>
<p>​        输入元素的顺序正好是反向的，每次插入都相当于在数组的第一个位置插入新的数据</p>
<p>​        比较次数：1 + 2 + 3 + … + (N-3) + (N-2) + (N-1) = N(N-1)/2</p>
<p>​        交换次数：1 + 2 + 3 + … + (N-3) + (N-2) + (N-1) = N(N-1)/2</p>
<p>平均情况时间复杂度：O($n ^ 2$)</p>
<p>​        可以理想化为最坏情况下有一半元素是正向的</p>
<p>​        比较次数：1/2 + 2/2 + …. + (N-2)/2 + (N-1)/2 = N(N-1)/4</p>
<p>​        交换次数：1/2 + 2/2 + …. + (N-2)/2 + (N-1)/2 = N(N-1)/4 </p>
<p>​        还可以理解为在数组中插入一个元素的平均时间复杂度，并执行n次的效果，数组中插入一个元素的平均时间复杂度为O(n)，循环执行n次插入复杂度为O($n ^ 2$)</p>
<p>特点：</p>
<ul>
<li>插入排序对部分有序的数组十分高效</li>
<li>适合小规模数组</li>
</ul>
<p><strong>部分有序</strong>的数组特征：</p>
<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h5><p>实际上就是使用不同增量的插入排序。插入排序是相邻元素之间的交换，而希尔排序是间隔为h的元素之间交换。其中h是按照某种序列递减，比如从N/3开始递减至1，这种序列被称为<strong>递增序列</strong></p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//1,4,13,40,121,364,...</span></span><br><span class="line">  <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&gt;=h &amp;&amp; SortUtil.less(a[j],a[j-h]);j-=h)&#123;</span><br><span class="line">        SortUtil.exch(a,j,j-h);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h = h/<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SortUtil.show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="衡量指标分析-3"><a href="#衡量指标分析-3" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><p>时间复杂度：O($N^{5/4}$)</p>
<p>​    不到平方级别，具体执行时间依赖于递增序列，通常应用中采用上面代码中的序列[$1/2(3^k - 1)$]就足够了。</p>
<p>特点：</p>
<ul>
<li>数组越大，优势越大</li>
</ul>
<p>高效原因：</p>
<p>​    权衡了子数组的规模和有序性，排序之前，子数组都很短，排序之后子数组都是部分有序的，这两种情况正好适合插入排序。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h5><p>算法设计中分治思想的典型实现。先将数组拆分成两半分别排序，然后在将结果归并起来，使得数组整体有序，再递归的对两半数组分别拆分排序归并。正是分治思想将大的任务拆解成小的任务，再把小任务分别解决从而解决大任务的体现。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge.png" alt="归并排序"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo,hi]排序</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);<span class="comment">//左半边排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);<span class="comment">//右半边排序</span></span><br><span class="line">        merge(a, lo, mid, hi);<span class="comment">//归并排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组拷贝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;       <span class="comment">//左半边用尽，直接取右半边元素</span></span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;  <span class="comment">//右半边用尽，直接取左半边元素</span></span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SortUtil.less(aux[j], aux[i])) &#123;<span class="comment">//右半边的元素小于左半边的元素，取右半边元素</span></span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右半边元素大于等于左半边元素，取左半边元素</span></span><br><span class="line">                a[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"M"</span>, <span class="string">"E"</span>, <span class="string">"R"</span>, <span class="string">"G"</span>, <span class="string">"E"</span>, <span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge_trace.png" alt="归并排序路径追踪"></p>
<h5 id="衡量指标分析-4"><a href="#衡量指标分析-4" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>归并排序不是原地排序算法</li>
</ol>
<p>在合并的时候使用了辅助空间，所以该算法的空间复杂度为O(n)</p>
<ol start="2">
<li>归并排序是稳定的排序算法</li>
</ol>
<p>归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码，当两个元素相等时，取左半部分元素，这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p>
<ol start="3">
<li>归并排序的时间复杂度</li>
</ol>
<p>最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_merge_complexity.png" alt="归并排序时间复杂度计算"></p>
<p>上图中每层需要比较的次数为N，所以需要比较的总次数为NlgN</p>
<p><strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p>
<p>假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C;n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) &#x3D; 2 * T(n&#x2F;2) + n;</span><br></pre></td></tr></table></figure>

<p>计算公式推到过程：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n</span><br><span class="line">     = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>) + n/<span class="number">2</span>) + n = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n</span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n</span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n</span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>

<p>得到T(n) = $2^k$  * T(n/$2^k$) + k * n ，当T(n/$2^k$) = T(1)时终止，即 n/$2^k$ = 1,k = $\log_2{n}$  , T(n) = Cn + n*$\log_2n$ ,采用大O标记法表示 T(n) = O(nlogn)，所以归并排序的时间复杂度为O(nlogn).</p>
<p>从实现思路及代码分析可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<p>特点：</p>
<ul>
<li>辅助数组需要占用额外的空间，并且大小与N成正比</li>
<li>可以处理大规模数组</li>
</ul>
<p>优化：</p>
<ul>
<li><p>对小规模子数组使用插入排序</p>
<p>  因为递归会使小规模问题中方法的调用过于频繁，所以使用插入排序处理小规模子数组（比如长度小于15），一般可以将归并排序的时间缩短10% ~ 15%</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>  归并的时候可以通过判断a[mid] &lt;= a[mid+1] 来避免merge过程</p>
</li>
<li><p>不将元素复制到辅助数组</p>
</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h5><p>也是基于分治思想。归并排序是将数组分成两个子数组分别排序，并将有序的子数组归并使整个数组有序。而快速排序是在拆分子数组的时候就确保了左子数组中的最大元素小于右子数组中的最小元素，通过partition切分，然后在进行递归调用。归并排序数组等分为两半；快速排序切分(partition)的位置取决于数组的内容</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_overview.png" alt="快排概览"></p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo,i-1],a[i],a[i+1,hi]</span></span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//停留在不小于v的元素下标上</span></span><br><span class="line">            <span class="keyword">while</span> (SortUtil.less(a[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//停留在不大于v的元素下标上</span></span><br><span class="line">            <span class="keyword">while</span> (SortUtil.less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//左右扫描指针相交时退出</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            SortUtil.exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将切分元素放入正确的位置</span></span><br><span class="line">        SortUtil.exch(a,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"Q"</span>, <span class="string">"U"</span>, <span class="string">"I"</span>, <span class="string">"C"</span>, <span class="string">"K"</span>, <span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        <span class="comment">//混排：将数组随机排序就是为了避免切分不平衡，比如每次选的切分元素恰好是最小或者最大的元素，则会导致一个子数组为空，每次排序只能排好一个元素，类似于选择排序</span></span><br><span class="line">        Collections.shuffle(Arrays.asList(arr));</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排执行流程跟踪如图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_trace.png" alt="快排执行流程"></p>
<p>快排分区的执行流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick_partition_trace.png" alt="快排分区执行流程"></p>
<h5 id="衡量指标分析-5"><a href="#衡量指标分析-5" class="headerlink" title="衡量指标分析"></a>衡量指标分析</h5><ol>
<li>快速排序是原地排序算法</li>
<li>快速排序不是稳定的排序算法</li>
<li>快速排序的时间复杂度</li>
</ol>
<p>快速排序的执行时间取决于切分元素（pivot 又叫分区点）的选择，如果每次分区恰好二分，那么时间复杂度递推公式与归并排序是相同的，时间复杂度就是O(nlogn)。如果每次分区后，一侧为空，一侧为满，则需要进行n次分区，每次分区只能排序一个元素，这时就有点类似选择排序，时间复杂度降为O($n^2$)。分别对应着快速排序的最好情况时间复杂度O(nlogn)和最坏情况时间复杂度 O($n^2$)。平均情况时间复杂度可以采用<strong>递归树</strong>进行分析，平均情况时间复杂度为O(nlogn)。</p>
<p>特点：</p>
<ul>
<li>原地排序（只需要很小的辅助栈）</li>
<li>切分不平衡时可能极为低效</li>
</ul>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ol>
<li><p>切换到插入排序</p>
<p> 对于小数组，快速排序比插入排序要慢，因为在小数组中，sort()方法还是会递归的调用自己。(个人理解：从元素重复度分析排序效率：1. 重复元素很少：当数组拆分的足够小且重复元素较少，这时大概率数组中元素已经部分有序，这时的递归调用效率要比插入排序低。2.重复元素较多：与产生三向切分的原因一样，在大量重复元素的情况下，再次递归经常会产生数组元素完全重复的子数组，而这样的子数组就不需要排序了)</p>
<p> 切换到插入排序的做法只需将sort()方法中的语句</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p> 替换为</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换参数M的最佳值与系统先关，通常情况下采用5 ~ 15 之间的任意值</span></span><br><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M) &#123;</span><br><span class="line">  Insertion.sort(a,lo,hi);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三取样切分</p>
<p> 使用子数组的一小部分元素的中位数来切分数组，代价是需要计算中位数。</p>
</li>
<li><p>三向切分快速排序</p>
<p> 排序库函数的最佳算法选择。</p>
<p> 实现思路：从左到右遍历数组，维护三个指针：一个指针lt使得a[lo,lt-1]的元素都小于v，一个指针gt使得a[gt+1,hi]的元素都大于v，一个指针i使得a[lt,i-1]的元素都等于v，a[i,gt]的元素待排序。具体处理步骤如下：</p>
<ol>
<li><p>a[i] 小于 v，交换a[i]和a[lt]，i 和 lt 加一</p>
</li>
<li><p>a[i] 大于 v，交换a[i]和a[gt]，gt 减一</p>
</li>
<li><p>a[i] 等于 v，i 加一</p>
<p>示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way_partition_overview.png" alt="三向切分示意图"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3way</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                SortUtil.exch(a, i++, lt++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                SortUtil.exch(a, i, gt--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"R"</span>, <span class="string">"B"</span>, <span class="string">"W"</span>, <span class="string">"W"</span>, <span class="string">"R"</span>, <span class="string">"W"</span>, <span class="string">"B"</span>, <span class="string">"R"</span>, <span class="string">"R"</span>, <span class="string">"W"</span>, <span class="string">"B"</span>, <span class="string">"R"</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        SortUtil.show(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>三项快速切分执行轨迹：</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_quick3way_trace.png" alt="三项快速切分执行轨迹"></p>
<h5 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h5><ol>
<li>O(n)时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</li>
</ol>
<p>其实就是利用快速排序分区的思想，选取数组区间A[0…n-1]的第一个元素A[0]作为pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_pivot_topk.png" alt="快排TopK问题"></p>
<p>时间复杂度计算：就是每次分区后遍历元素之和，即n + n/2 + n/4 + … + 1 = 2n-1,所以时间复杂度为O(n)</p>
<h3 id="非基于比较的排序算法-线性排序"><a href="#非基于比较的排序算法-线性排序" class="headerlink" title="非基于比较的排序算法-线性排序"></a>非基于比较的排序算法-线性排序</h3><p>三种非基于比较的排序算法：桶排序、计数排序、基数排序，这些排序算法的时间复杂度都为O(n)，因为这些算法的时间复杂度都是线性的，所以也将这类排序算法称为<strong>线性排序(Linear Sort)</strong></p>
<h4 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序(Bucket Sort)"></a>桶排序(Bucket Sort)</h4><h5 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h5><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_bucket.png" alt="桶排序"></p>
<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<h4 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h4><h5 id="实现思路-7"><a href="#实现思路-7" class="headerlink" title="实现思路"></a>实现思路</h5><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>举个例子：假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8] 中，它们分别是：2，5，3，0，2，3，0，3。</p>
<p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6] 的值。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_1.png" alt="计数排序步骤一"></p>
<p>然后对 C[6] 数组顺序求和，C[6] 存储的数据就变成了下面这样子。C[k] 里存储小于等于分数 k 的考生个数。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_2.png" alt="计数排序步骤二"></p>
<p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。以此类推。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_count_3.png" alt="计数排序步骤三"></p>
<p><strong>注意：扫描数组A的时候必须从末尾开始，这样才能保证计数排序是稳定排序算法</strong></p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<h4 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h4><p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zhengguoqiang927/Figure-bed/master/img/algorithm_sort_radix.png" alt="基数排序"></p>
<p>上图中只需要进行三次桶排序，分别从字符串的最后一位进行第一次桶排序，到第一位进行最后一次桶排序，因为基于稳定的排序算法，所以三次桶排序后所有字符串已有序。</p>
<p>10万手机号号码，按照从小到大进行排序，用基数排序可以在线性时间复杂度内完成，原理跟上图类似。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" rel="tag"><i class="fa fa-tag"></i> 算法,排序</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/29/algorithm-complexity-analysis/" rel="prev" title="算法 —— 复杂度分析">
      <i class="fa fa-chevron-left"></i> 算法 —— 复杂度分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/03/algorithm-binary-search/" rel="next" title="算法 —— 二分查找">
      算法 —— 二分查找 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的衡量指标"><span class="nav-number">2.</span> <span class="nav-text">排序算法的衡量指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法的执行效率"><span class="nav-number">2.1.</span> <span class="nav-text">排序算法的执行效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法的内存消耗"><span class="nav-number">2.2.</span> <span class="nav-text">排序算法的内存消耗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法的稳定性"><span class="nav-number">2.3.</span> <span class="nav-text">排序算法的稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于比较的排序算法"><span class="nav-number">3.</span> <span class="nav-text">基于比较的排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序"><span class="nav-number">3.1.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路"><span class="nav-number">3.1.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现"><span class="nav-number">3.1.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析"><span class="nav-number">3.1.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">3.2.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">3.3.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-2"><span class="nav-number">3.3.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-2"><span class="nav-number">3.3.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-2"><span class="nav-number">3.3.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希尔排序"><span class="nav-number">3.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-3"><span class="nav-number">3.4.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-3"><span class="nav-number">3.4.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-3"><span class="nav-number">3.4.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">3.5.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-4"><span class="nav-number">3.5.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-4"><span class="nav-number">3.5.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-4"><span class="nav-number">3.5.3.</span> <span class="nav-text">衡量指标分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">3.6.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-5"><span class="nav-number">3.6.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-5"><span class="nav-number">3.6.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#衡量指标分析-5"><span class="nav-number">3.6.3.</span> <span class="nav-text">衡量指标分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优化"><span class="nav-number">3.6.4.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#场景应用"><span class="nav-number">3.6.5.</span> <span class="nav-text">场景应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非基于比较的排序算法-线性排序"><span class="nav-number">4.</span> <span class="nav-text">非基于比较的排序算法-线性排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#桶排序-Bucket-Sort"><span class="nav-number">4.1.</span> <span class="nav-text">桶排序(Bucket Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-6"><span class="nav-number">4.1.1.</span> <span class="nav-text">实现思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数排序-Counting-Sort"><span class="nav-number">4.2.</span> <span class="nav-text">计数排序(Counting Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现思路-7"><span class="nav-number">4.2.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现-6"><span class="nav-number">4.2.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#适用场景"><span class="nav-number">4.2.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基数排序-Radix-Sort"><span class="nav-number">4.3.</span> <span class="nav-text">基数排序(Radix Sort)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZGQ"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZGQ</p>
  <div class="site-description" itemprop="description">Java</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengguoqiang927" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengguoqiang927" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengguoqiang927@gmail.com" title="E-Mail → mailto:zhengguoqiang927@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">左耳朵耗子</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;" rel="noopener" target="_blank">廖雪峰</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZGQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">201k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:03</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://johnson-5.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/07/03/algorithm-sort/";
    this.page.identifier = "2020/07/03/algorithm-sort/";
    this.page.title = "算法 —— 排序";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://johnson-5.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
